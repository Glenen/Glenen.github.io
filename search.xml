<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[java运行时数据区域]]></title>
      <url>https://glenen.github.io/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本博文所有内容均为本人阅读《深入理解java虚拟机：jvm高级特性与最佳实践》书时所记，所用图也是亲笔所画。转载请注明出处，仅供参考。</p>
<p>本书作者前面用了很多篇幅描述java虚拟机及JDK的发展历史，此部分并没有做笔记，如需了解，请移步阅读原著即可。</p>
<h5 id="java优点"><a href="#java优点" class="headerlink" title="java优点"></a>java优点</h5><p>摆脱硬件平台束缚，一次编写到处运行；相对安全的内存管理与访问机制，避免内存泄漏与指针越界；热点代码检测和运行时编译及优化，java应用能随着<br>运行时间的增加而获得更高的性能；拥有一套完善的API。</p>
<a id="more"></a>
<h5 id="java技术体系"><a href="#java技术体系" class="headerlink" title="java技术体系"></a>java技术体系</h5><p>组成部分：java程序设计语言，各种硬件平台上的java虚拟机，Class文件格式，java API类库，商业机构和开源社区的第三方java类库。</p>
<p>JDK：java程序设计语言，java虚拟机，，java API类库。</p>
<p>JRE：java SE API子集 和 java虚拟机，支持java程序运行的标准环境。</p>
<p>java虚拟机：编译器与解释器。发展历史中出现过各种虚拟机。通用平台上运行的商用虚拟机：HotSpot ，JRockit ，J9。 特定硬件平台专用虚拟机：Azul VM  和  BEA Liquid VM。总结如下图所示：</p>
<p><img src="/java运行时数据区域/java技术体系.png" alt="java技术体系"></p>
<h5 id="java未来"><a href="#java未来" class="headerlink" title="java未来"></a>java未来</h5><p>模块化：解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。</p>
<p>混合语言编程：每种语言解决自己擅长的问题。</p>
<p>多核并行：多线程，充分利用CPU。进一步丰富语法及64位虚拟机</p>
<h4 id="java运行时数据区域"><a href="#java运行时数据区域" class="headerlink" title="java运行时数据区域"></a>java运行时数据区域</h4><p>java虚拟机在运行java程序时会把它所管理的内存划分为不同的数据区域，有的区域会随着虚拟机进程的启动而存在，有的则依赖于用户线程的启动和结束而创建和销毁。大体划分图如下：</p>
<p><img src="/java运行时数据区域/jvm运行时内存图.png" alt="jvm运行时内存图"></p>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>线程私有的一块较小内存空间，可以看作是当前线程所执行字节码的行号指示器。虚拟机的模型概念里，字节码解释器工作时就是通过改变程序计数器的值来选取下一条需要执行的字节码指令。</p>
<p>为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器且互不影响独立存储。程序计数器是唯一一个在java虚拟机规范中没有规定任何OutOFMemoryError情况的区域，如果线程正在执行一个java方法，则其记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，则其值为空。</p>
<h5 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h5><p>线程私有，生命周期与线程相同，其描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址），其在帧中的内存空间大小在编译期已确定，运行期不会改变其大小。</p>
<p>StackOverFlowError：线程请求的栈深度大于虚拟机所允许的栈深度；OutOFMemoryError：虚拟机动态扩展时无法申请到足够的内存。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>与虚拟机栈发挥到作用非常相似，但其为虚拟机使用到的Native方法服务。甚至有的虚拟机（HotSpot）将它们合二为一，也会抛出StackOverFlowError 和 OutOFMemoryError异常。</p>
<h5 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h5><p>内存管理最大的一块，被所有线程共享，在虚拟机启动时创建。其唯一目的就是存放对象实例及数组。java堆可以处于物理上不连续的内存空间中，只要逻<br>辑上连续即可。如果在堆中没有内存来完成实例分配且无法再扩展时，抛出OutOFMemoryError异常。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>与java堆一样，各线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。此区域的内存回收目标主要是针对常<br>量池的回收和对类型的卸载，内存回收难但却必要。当其无法满足内存分配需求时，抛出OutOFMemoryError异常。</p>
<h5 id="运行时常量区"><a href="#运行时常量区" class="headerlink" title="运行时常量区"></a>运行时常量区</h5><p>方法区的一部分，Class文件常量池用于存放编译期生成的各种字面量和符号引用。运行时常量池相对于Class文件常量池具有动态性，且每一部分的格式<br>都没有严格规定。动态特性利用的比较多的是String  类的intern()方法。常量池无法再申请到内存时抛出OutOFMemoryError异常。</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>不属于虚拟机运行时数据区的一部分，也并非虚拟机规范中定义的内存区域。但该部分内存被频繁使用，且也可能导致OutOFMemoryError异常。NIO(New Input/output)类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，该种方式在一些场景中显著提高性能，因为避免了在java堆和Native堆中来回复制数据。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树遍历—借助栈]]></title>
      <url>https://glenen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E5%80%9F%E5%8A%A9%E6%A0%88/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本博文所设计内容均为本人亲自所著，为工作闲暇之余及大学时代所积累，涉及思路不会描述太仔细，仅供参考。</p>
<p>二叉树的遍历种类可谓多：深度优先遍历DFS——借助栈，打破砂锅问到底，控制好节点的访问权即可。广度优先遍历BFS——借助队列，浅尝则止。层序遍历——借助队列，父节点出队之时即它孩子入队之日。</p>
<p>今天所记录的是二叉树的先、中、后序遍历，遍历的方法也是很多：递归、借助栈、递归加迭代、Morris遍历(最佳方式，后续会补上博文)。前三种方式中，时间复杂度均为O(n)，空间复杂度O(logn)。递归方式也最简单，本质是借助函数栈。在此研究的是借助栈实现三种遍历，不难但却给我们传递了一种借助数据结构解决问题的思想，还是非常值得体会的。</p>
<a id="more"></a>
<h5 id="一棵二叉树图："><a href="#一棵二叉树图：" class="headerlink" title="一棵二叉树图："></a>一棵二叉树图：</h5><p><img src="/二叉树遍历——借助栈/二叉树.png" alt="二叉树"></p>
<h5 id="java定义二叉树数据结构："><a href="#java定义二叉树数据结构：" class="headerlink" title="java定义二叉树数据结构："></a>java定义二叉树数据结构：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 定义二叉树</div><div class="line"> */</div><div class="line">@Data</div><div class="line">private class Node &#123;</div><div class="line">    /**</div><div class="line">     * 节点值</div><div class="line">     */</div><div class="line">    private int dataValue;</div><div class="line">    /**</div><div class="line">     * 左孩子节点</div><div class="line">     */</div><div class="line">    private Node left;</div><div class="line">    /**</div><div class="line">     * 右孩子节点</div><div class="line">     */</div><div class="line">    private Node right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：因为本人IDE测试都写在一个类中，所有采用了内部类定义结构。</p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>头节点 —&gt; 左孩子节点 —&gt; 右孩子节点。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>头节点最先压入栈 —&gt; 弹出并打印其节点值 —&gt; 顺序检查其右、左孩子节点是否为null —&gt; 不为null的入栈 —&gt; 继续第二步骤及其后续 —&gt; 栈为空后退出循环。</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 二叉树先序遍历：借助栈</div><div class="line"> *</div><div class="line"> * @param head 头节点</div><div class="line"> */</div><div class="line">public static void preTraversal(Node head) &#123;</div><div class="line">    <span class="keyword">if</span> (head == null) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.print(<span class="string">"preTraversal:"</span>);</div><div class="line">        Stack&lt;Node&gt; temp = new Stack&lt;&gt;();</div><div class="line">        // 头节点压入栈</div><div class="line">        temp.push(head);</div><div class="line">        <span class="keyword">while</span> (!temp.isEmpty()) &#123;</div><div class="line">            head = temp.pop();</div><div class="line">            System.out.print(head.dataValue + <span class="string">" "</span>);</div><div class="line">            // 右孩子先入栈</div><div class="line">            <span class="keyword">if</span> (head.right != null) &#123;</div><div class="line">                temp.push(head.right);</div><div class="line">            &#125;</div><div class="line">            // 左孩子后入栈</div><div class="line">            <span class="keyword">if</span> (head.left != null) &#123;</div><div class="line">                temp.push(head.left);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>左孩子节点 —&gt; 头节点 —&gt; 右孩子节点。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>头节点压入栈 —&gt; 递归将其左孩子及左孩子一条斜线上的节点压入栈：左孩子及左孩子的左孩子… —&gt; 最左的左孩子为null时：弹出栈顶节点 —&gt; 打印其节点值，并把它右孩子节点入栈 —&gt; 继续第二步骤及后续 —&gt; 栈为空时退出循环。</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 二叉树中序遍历：借助栈</div><div class="line"> *</div><div class="line"> * @param head 头节点</div><div class="line"> */</div><div class="line">public static void midTraversal(Node head) &#123;</div><div class="line">    <span class="keyword">if</span> (head == null) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.print(<span class="string">"midTraversal:"</span>);</div><div class="line">        Stack&lt;Node&gt; temp = new Stack&lt;&gt;();</div><div class="line">        temp.push(head);</div><div class="line">        <span class="keyword">while</span> (!temp.isEmpty() || head != null) &#123;</div><div class="line">            // 连续把二叉树最左一条斜线上的节点压入栈</div><div class="line">            <span class="keyword">if</span> (head.left != null) &#123;</div><div class="line">                temp.push(head.left);</div><div class="line">                head = head.left;</div><div class="line">            // 弹出栈顶节点，让其右孩子继续上述过程</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                head = temp.pop();</div><div class="line">                System.out.print(head.dataValue + <span class="string">" "</span>);</div><div class="line">                head = head.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>左孩子节点 —&gt; 右孩子节点 —&gt; 头节点。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>此处借助两个栈实现，也更好理解，当然也可以借助一个栈结构实现。<br>头节点入栈1 —&gt; 栈1弹出节点并压入栈2 —&gt;  顺序检测弹出节点的左、右孩子是否为null —&gt; 不为null则顺序压入栈1 —&gt; 继续步骤2及其后续 —&gt; 栈1为空则退出循环 —&gt; 此时栈2中的节点顺序已是后序遍历顺序，循环弹出打印其节点即可。</p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code class="bash">/**
 * 二叉树后序遍历：借助栈
 *
 * @param head 头节点
 */
public static void behTraversal(Node head) {
    <span class="keyword">if</span> (head == null) {
        <span class="built_in">return</span>;
    } <span class="keyword">else</span> {
        // 借助两个栈来完成
        Stack&lt;Node&gt; temp1 = new Stack&lt;&gt;();
        Stack&lt;Node&gt; temp2 = new Stack&lt;&gt;();
        System.out.print(<span class="string">"behTraversal:"</span>);
        temp1.push(head);
        <span class="keyword">while</span> (!temp1.isEmpty()) {
            head = temp1.pop();
            temp2.push(head);
            // 入栈顺序很重要
            <span class="keyword">if</span> (head.left != null) {
                temp1.push(head.left);
            }
            <span class="keyword">if</span> (head.right != null) {
                temp1.push(head.right);
            }
        }
        // temp2栈中的顺序已是后序
        <span class="keyword">while</span> (!temp2.isEmpty()) {
            System.out.print(temp2.pop() + <span class="string">" "</span>);
        }
    }
    System.out.println();
}
</code></pre>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> 二叉树 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[韶华倾付]]></title>
      <url>https://glenen.github.io/%E9%9F%B6%E5%8D%8E%E5%80%BE%E4%BB%98/</url>
      <content type="html"><![CDATA[<p>情感此物很奇怪，总是会在生活里，慢慢忘记了回忆。</p>
<p>开始忘记，有那么一张脸，他最初走进我的世界，是以怎样的表情。<br>也许是在一个阳光明媚的午后。<br>也许是在一个风景秀丽的公园。<br>也许是在一座人声鼎沸的都市。<br>也许，你就这样带着来自幸福的期许。<br>如此翩翩舞动而来。</p>
<p><img src="/韶华倾付/timg-0.png" alt=""></p>
<a id="more"></a>
<p>爱的你，如今在一座据说很恐怖的城市独自工作和生活。<br>为了梦想，或者说为了生存，你留在了那里。<br>那座城市，也许只是你的一个想象。<br>它出现于一夜之间，像海市蜃楼一样虚幻而美丽。<br>你走得越近，就越看不清它。<br>你凝视着它，为它哭，为它笑。<br>久而久之，你终于发现，原来它只是你的一个影子。<br>偶有微光，照亮你前行的方向。</p>
<p><img src="/韶华倾付/timg-1.png" alt=""></p>
<p>自从你工作之后，诸多不易，诸多辛劳，即便不说，其实我也大略的知道。<br>然而，你给了我一个承诺，我就哪里都不会去，只是站在这里等着你。<br>恩爱两不疑，如此坚定和执着。</p>
<p>牵挂的人，未来已经在前方等着你。<br>请勇敢的去拥抱它。<br>别念过去，别畏将来。<br>我会是你最温暖的港湾。</p>
<p><img src="/韶华倾付/timg-2.png" alt=""></p>
<p>爱情许是最美好的感觉。<br>时光不会伤害它。<br>而它之于你我，不是肌肤之亲，也不是一蔬一饭。<br>它是一种不死的欲望，是平凡生活中的英雄梦想。<br>所以放心的去拼搏吧，站在你身后的，是永恒不变的我，和我的心。</p>
]]></content>
      
        <categories>
            
            <category> 心灵情感 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
