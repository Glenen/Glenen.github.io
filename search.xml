<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[虚拟机字节码执行引擎]]></title>
      <url>https://glenen.github.io/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>文中所涉及内容均为java虚拟机相关，但由于java虚拟机团队也一直在改进和优化java虚拟机，其中有的内容可能会与后续版本有差异，所以文中内容仅提供参考，不可作为任何定义为任何标准的准则，敬请谅解。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分详细讲述了虚拟机字节码执行引擎，方法栈帧的详细结构。方法的调用原理解析，从而揭示了java基础语法中的方法重载和java中多态机制的本质。还比较了基于寄存器和基于栈的指令集架构，而基于栈的指令集架构正是java虚拟机的执行引擎和指令集。</p>
<a id="more"></a>
<p>虚拟机与物理机都有代码执行能力，区别是物理机的执行引擎直接建立在处理器、硬件、指令集和操作系统层面上，而虚拟机的执行引擎是由自己实现的，可自行定制指令集和执行引擎的结构体系，且能够执行那些不被硬件直接支持的指令集格式。虚拟机可有解释执行和编译执行(通过即时编译器产生本地字节码执行)。</p>
<h4 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h4><p>栈帧用于支持虚拟机进行方法调用和执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素，存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。</p>
<p>一个栈帧需分配多少内存不会受到程序运行期变量数据影响，在编译期已确定，多大的局部变量表、多深的操作数栈都已确定写入了方法表带code属性中。</p>
<p>一个线程的方法调用链可能会很长，很多方法同时处于执行状态。只有位于栈顶的栈帧才是有效的，称当前栈帧和与之关联的当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。</p>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>一组变量值的存储空间，存放方法参数和内部定义的局部变量。其容量以变量槽variable slot为最小单位。</p>
<p>一个slot可存放一个32位以内的数据类型。java中32位以内的有：byte  boolean  char  short  int  float  reference  returnAddress。对于64位数据类型long和double，虚拟机会以高位对齐的方式为其分配两个连续的slot空间。因为局部变量表建立在线程的堆栈上，属于线程私有数据，无论读写两个连续的slot是否为原子操作，都不会引起数据安全问题。</p>
<p>虚拟机通过索引定位方式使用变量表，索引值从0到变量表的最大的slot数量。方法执行时，虚拟机使用局部变量表完成参数值到参数变量列表传递的过程。</p>
<p>为了尽可能节省栈帧空间，slot是可重用的，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那这个对应变量的slot可交给其他变量使用。如下代码示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 测试局部变量表中的slot重复:会直接影响到系统的垃圾回收行为</div><div class="line"> * 建议：如果遇到一个方法，其后面的方法有一些耗时很长的操作，而前面又定义了占用大量内存，</div><div class="line"> * 实际上已经不会在使用的变量，手动将其设置为null可当做一个特技来使用。</div><div class="line"> * 但不推荐：</div><div class="line"> * 1、编码角度而言，以恰当的变量作用域来控制变量回收时间才是最优雅的解决办法；</div><div class="line"> * 2、赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的。</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-21</div><div class="line"> */</div><div class="line">@SuppressWarnings(<span class="string">"unused"</span>)</div><div class="line">public class VariableSlotTest &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 不回收placeHolder所占用的空间</div><div class="line">     */</div><div class="line">    private static void <span class="function"><span class="title">caseOne</span></span>() &#123;</div><div class="line">        byte[] placeHolder = new byte[64 * 1024 * 1024];</div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 也不回收placeHolder所占用的空间，但经JIT编译器后，赋null值的操作在经过JIT编译优化后会被消除，因此可正常回收内存</div><div class="line">     */</div><div class="line">    private static void <span class="function"><span class="title">caseTwo</span></span>() &#123;</div><div class="line">        &#123;</div><div class="line">            byte[] placeHolder = new byte[64 * 1024 * 1024];</div><div class="line">        &#125;</div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 回收placeHolder所占用的空间</div><div class="line">     */</div><div class="line">    private static void <span class="function"><span class="title">caseThree</span></span>() &#123;</div><div class="line">        &#123;</div><div class="line">            byte[] placeHolder = new byte[64 * 1024 * 1024];</div><div class="line">        &#125;</div><div class="line">        int flag = 0;</div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 测试main方法</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        <span class="keyword">case</span>One();</div><div class="line">        <span class="keyword">case</span>Two();</div><div class="line">        <span class="keyword">case</span>Three();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>也称操作栈，同局部变量表一样操作数栈的最大深度也在编译的时候写到了code属性的Max_stacks数据项中。可操作java任意数据类型，32位数据类型所占栈容量为1，64位数据类型所占栈容量为2，方法执行时，其深度不会超过其编译时设定的最大值。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器严格保证这一点，在类校验阶段的数据流分析中还要再次验证。且在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。如下图所示演示了两个栈帧之间的数据共享：</p>
<p><img src="/虚拟机字节码执行引擎/两个栈帧之间的数据共享.png" alt=""></p>
<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就是以常量池中指向这个方法的符号引用作为参数。</p>
<p>静态解析：这些符号引用一部分会在类加载阶段或者第一次使用时候就转化为直接引用。</p>
<p>动态链接：另一部分将在每次运行期间转化为直接引用。</p>
<h5 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h5><p>一个方法开始执行后，退出方法：</p>
<p>1、正常完成出口：执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给传递给上层方法的调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定。调用者的PC计数器的值可以作为返回值，栈帧中很可能会保存这个计数器的值。</p>
<p>2、异常完成出口：方法执行过程中遇到了异常，且这个异常在方法体内没有得到处理，该退出方式不会给调用者返回值。返回地址要通过异常处理器表来确定，栈帧中一般不会保存这部分信息。 方法退出的实际过程等同于当前栈帧的出栈。</p>
<p>实际开发中，一般会把动态链接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>不等同于方法执行，该阶段唯一任务就是确定被调用方法等版本，即调用哪个方法，暂时不涉及方法内部具体执行过程。一切方法调用在class文件里存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。因此需要在类加载时期甚至运行期间才能确定目标方法的直接引用。</p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>调用目标在程序代码写好、编译器编译时就必须确定下来，这类方法的调用称为解析。java中符合“编译期确定，运行期不可变”：</p>
<p>1、静态方法，直接与类型直接关联；</p>
<p>2、私有方法，在外部不可访问。</p>
<p><strong>非虚方法：</strong>只要能被invokestatic、invkoespecial指令调用的方法，都可在解析阶段确定唯一调用版本，如<code>静态方法</code>、<code>私有方法</code>、<code>实例构造器</code>和<code>父类方法</code>4大类，在类加载时期就会把符号引用解析为该方法等直接引用。还包括final方法，其使用invokevirtual指令调用。</p>
<p><strong>虚方法：</strong>使用invokevirtual指令调用的方法(此描述可能不准确)。</p>
<p><strong>解析调用：</strong>静态过程，编译期间就可完全确定，在类装载的解析阶段就会把设计的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成。</p>
<h5 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h5><p>分派调用过程将会揭示多态性特征的一些最基本的体现。分派Dispatch调用：可能静态也可能是动态。在开始讲述之前，我们先介绍五个定义。</p>
<p>宗量：方法的接收者即调用者 与 方法的参数统称为方法的宗量。</p>
<p>单分派：根据一个宗量对目标方法进行选择。</p>
<p>多分派：根据多余一个宗量对目标方法进行选择。</p>
<p>静态类型：父类引用指向子类实例中的父类，该类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，且最终的静态类型是在编译期可知的。</p>
<p>实际类型：父类引用指向子类实例中的子类，该类型的变化结果在运行期才可确定，编译器在编译的时候并不知道一个对象的实际类型是什么。</p>
<p><strong>注意：</strong>编译器在重载时是通过参数的静态类型而不是实际类型作为判断依据的。重载使用哪个版本在编译期已确定。</p>
<p><strong>静态分派：</strong>所有依赖静态类型来定位方法执行版本的分派动作。典型应用是方法重载，发生在编译阶段。但有时重载版本并不惟一，往往只能确定一个更加合适的版本：字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型只能通过语言规则去理解和推测。属于多分派类型。如下代码示例了静态分派：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm.dispatch;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 方法静态分派演示</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-24</div><div class="line"> */</div><div class="line">@SuppressWarnings(<span class="string">"unused"</span>)</div><div class="line">public class StaticDispatchTest &#123;</div><div class="line"></div><div class="line">    static abstract class Human &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class Man extends Human &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class Woman extends Human &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void sayHello(Human human) &#123;</div><div class="line">        System.out.println(<span class="string">"hello, human!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sayHello(Man man) &#123;</div><div class="line">        System.out.println(<span class="string">"hello, man!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sayHello(Woman woman) &#123;</div><div class="line">        System.out.println(<span class="string">"hello, woman!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Human man = new Man();</div><div class="line">        Human woman = new Woman();</div><div class="line">        StaticDispatchTest item = new StaticDispatchTest();</div><div class="line">        item.sayHello(man);</div><div class="line">        item.sayHello(woman);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出结果：</div><div class="line">hello, human!</div><div class="line">hello, human!</div></pre></td></tr></table></figure>
<p>以下代码示例了方法重载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm.dispatch;</div><div class="line"></div><div class="line">import java.io.Serializable;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 演示编译器如何确定一个更加合适的重载版本</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-24</div><div class="line"> */</div><div class="line">@SuppressWarnings(<span class="string">"unused"</span>)</div><div class="line">public class OverLoadTest &#123;</div><div class="line"></div><div class="line">    private static void sayHello(Object arg) &#123;</div><div class="line">        System.out.println(<span class="string">"hello. Object!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void sayHello(int arg) &#123;</div><div class="line">        System.out.println(<span class="string">"hello. Int!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void sayHello(long arg) &#123;</div><div class="line">        System.out.println(<span class="string">"hello. Long!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void sayHello(char arg) &#123;</div><div class="line">        System.out.println(<span class="string">"hello. Char!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void sayHello(Character arg) &#123;</div><div class="line">        System.out.println(<span class="string">"hello. Character!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void sayHello(Serializable arg) &#123;</div><div class="line">        System.out.println(<span class="string">"hello. Serializable!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 可变长参数的重载优先级最低</div><div class="line">     */</div><div class="line">    private static void sayHello(char... arg) &#123;</div><div class="line">        System.out.println(<span class="string">"hello. Char..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void sayHello(int... arg) &#123;</div><div class="line">        System.out.println(<span class="string">"hello. Int..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void sayHello(Character... arg) &#123;</div><div class="line">        System.out.println(<span class="string">"hello. Character..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void sayHello(Object... arg) &#123;</div><div class="line">        System.out.println(<span class="string">"hello. Object..."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 查看输出，层层注释掉本次调用的方法，再查看输出。即可观察到重载的本质</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        sayHello(<span class="string">'a'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">按注释步骤输出结果：</div><div class="line">hello. Char!</div><div class="line">hello. Int!</div><div class="line">hello. Long!</div><div class="line">…………</div></pre></td></tr></table></figure>
<p>通过观察如上代码的输出过程，可得出结论：</p>
<p><strong>java实现方法重载的本质：</strong>编译期间选择静态分派目标的过程，方法参数层层转型，寻找最合适的重载版本。</p>
<p><strong>动态分派：</strong>与重写有着密切的关联，在运行期根据实际类型确定方法执行版本的分派过程。属于单分派类型。</p>
<p>我们先了解下java虚拟机指令集中一个重要指令invokevirtual的运行时解析过程，因为该指令的解析过程揭示这方法重写的本质：</p>
<p>1、找到操作数栈顶的第一个元素所指的对象的实际类型，记作C；</p>
<p>2、如果在C中找到与常量中的描述符和简单名称都相符的方法，则进行权限访问校验，如果通过则返回这个方法的直接引用，查找过程结束，如果不通过则返回IllegalAccessError；</p>
<p>3、否则，按照继承关系从上往下依次对C的各个父类进行第2步的搜索和验证过程；</p>
<p>4、如果始终没有找到合适的方法，则抛出AbstractMethodError。</p>
<p>如下代码示例了方法单分派与多分派：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm.dispatch;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 单分派、多分派演示</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-24</div><div class="line"> */</div><div class="line">public class DispatchTest &#123;</div><div class="line"></div><div class="line">    private static class QQ &#123;</div><div class="line">    &#125;</div><div class="line">    private static class _360 &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class Father &#123;</div><div class="line">        public void HardChoice(QQ arg) &#123;</div><div class="line">            System.out.println(<span class="string">"Father choose qq."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void HardChoice(_360 arg) &#123;</div><div class="line">            System.out.println(<span class="string">"Father choose _360."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class Son extends Father &#123;</div><div class="line">        @Override</div><div class="line">        public void HardChoice(QQ arg) &#123;</div><div class="line">            System.out.println(<span class="string">"Son choose qq."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void HardChoice(_360 arg) &#123;</div><div class="line">            System.out.println(<span class="string">"Son choose _360."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Father father = new Father();</div><div class="line">        Father son = new Son();</div><div class="line">        father.HardChoice(new _360());</div><div class="line">        son.HardChoice(new QQ());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出结果：</div><div class="line">Father choose _360.</div><div class="line">Son choose qq.</div></pre></td></tr></table></figure>
<p>此时DispatchTest类中的方法表结构可大致如下所示：</p>
<p><img src="/虚拟机字节码执行引擎/方法表结构.png" alt=""></p>
<p>通过观察如上代码的输出过程和方法表结构图示，可得出结论：</p>
<p><strong>java重写方法本质：</strong>invokevirtual指令把常量池中类方法符号引用解析到了不同的直接引用上。</p>
<h5 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h5><p>动态分派是非常频繁的动作，虚拟机实际实现中基于性能考虑，大部分实现中都不会进行真正的搜索。则常用的优化手段就是为类在方法区中建立一个虚方法表Virtual Method Table，与此对应的，在执行invokeinterface时也会用到接口方法表Interface Method Table，使用虚方法表索引来代替元数据查找以提高性能。</p>
<p>虚方法表中存放着各个方法的实际入口地址，方法没被重写，则与父类相同方法的入口地址一致，都指向父类的实现入口。为了程序实现的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型转换时，只需变更查找方法表，就可从不同的虚方法表中按照索引转换出所需的入口地址。且方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p>
<h5 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h5><p>JDK1.7中新增invokedynamic指令及java.lang.invoke包，该包以前的主要目的是单纯依靠符号引用来确定调用的目标方法，但现在提供了一种新的动态确定目标方法的机制，称MethodHandle。为JDK1.8中顺利实现Lambda表达式做技术准备。</p>
<p>动态类型语言：关键特征是它的类型检查的主体过程是在运行期而不是编译期，如ruby、python、JS、PHP等。</p>
<p>静态类型语言：相对的在编译期就进行类型检查过程的语言，如java、C++。</p>
<p>通俗讲：运行时异常就是只要代码不运行到这一行就不会有问题，与之对应的是连接是异常，如NoClassDefinedError，即使导致连接时异常的代码放在一条无法执行到的分支路径上，在类加载阶段也会抛出异常。</p>
<p>如下代码演示了Method Handle 基础用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm.dynamic;</div><div class="line"></div><div class="line">import static java.lang.invoke.MethodHandles.lookup;</div><div class="line"></div><div class="line">import java.lang.invoke.MethodHandle;</div><div class="line">import java.lang.invoke.MethodType;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Method Handle 基础用法演示</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-27</div><div class="line"> */</div><div class="line">public class MethodHandleTest &#123;</div><div class="line"></div><div class="line">    private static class ClassA&#123;</div><div class="line">        public void println(String string) &#123;</div><div class="line">            System.out.println(string);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Throwable &#123;</div><div class="line">        Object object = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA();</div><div class="line">        getPrintHM(object).invokeExact(<span class="string">"my god."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static MethodHandle getPrintHM(Object object) throws Exception &#123;</div><div class="line">        /*代表方法类型，包含了方法的返回值和具体参数，分别对应第一个及后续参数*/</div><div class="line">        MethodType <span class="built_in">type</span> = MethodType.methodType(void.class, String.class);</div><div class="line">        </div><div class="line">        /*lookup方法作用是在指定类中查找符合给定的方法名称、方法类型、并且符合调用权限的方法句柄*/</div><div class="line">        /*因为这里调用的是一个虚方法，按照java语言惯例，方法的第一个参数是隐式的，代表该方法的接收者，</div><div class="line">         *即this指向的对象，该参数以前放在参数列表中进行传递，现在有<span class="built_in">bind</span>To完成</div><div class="line">         */</div><div class="line">        <span class="built_in">return</span> lookup().findVirtual(object.getClass(), <span class="string">"println"</span>, <span class="built_in">type</span>).bindTo(object);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出结果：</div><div class="line">my god.</div></pre></td></tr></table></figure>
<p><strong>MethodHandle与Reflection区别：</strong></p>
<p>1、Reflection是在模拟java代码层次的方法调用，MethodHandle是在模拟字节码层面的方法调用；</p>
<p>2、 Reflection中Method对象远比MethodHandle机制中MethodHandle对象所包含的信息多，通俗讲<br>Reflection重量级，MethodHandle轻量级；</p>
<p>3、MethodHandle设计成可服务于所有java虚拟机上的语言，而Reflection API的设计目标只为java语言服务。</p>
<p><strong>invokedynamic指令：</strong>某种程度上，与MethodHandle机制的作用是一样的。它们设计思路也可类比，可想象成为达成一个目的，一个采用上层java代码和API来实现，另一个用字节码和class中其他属性、常量来完成。该指令第一个参数CONSTANT_InvokeDynamic_info常量，包含引导方法、方法类型、名称。引导方法 -&gt; 有固定参数，返回值CallSite对象，代表着真正要执行的目标方法调用。如下代码示例了invokedynamic指令的基础演示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm.dynamic;</div><div class="line"></div><div class="line">import static java.lang.invoke.MethodHandles.lookup;</div><div class="line"></div><div class="line">import java.lang.invoke.*;</div><div class="line"></div><div class="line">/**</div><div class="line"> * invokeDynamic指令基础演示：该实例中的方法名称不能随意动，更不能把几个方法合并到一起，因为它们被INDY工具读取的。</div><div class="line"> * 详解见P286</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-27</div><div class="line"> */</div><div class="line">@SuppressWarnings(<span class="string">"all"</span>)</div><div class="line">public class InvokeDynamicTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Throwable &#123;</div><div class="line">        INDY_BootstrapMethod().invokeExact(<span class="string">"my god."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void <span class="built_in">test</span>Method(String string) &#123;</div><div class="line">        System.out.println(<span class="string">"Hello String:"</span> + string);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static CallSite BootstrapMethod(MethodHandles.Lookup lookup, String name, MethodType <span class="built_in">type</span>) throws Exception &#123;</div><div class="line">        <span class="built_in">return</span> new ConstantCallSite(lookup.findStatic(InvokeDynamicTest.class, name, <span class="built_in">type</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static MethodType <span class="function"><span class="title">MT_BootstrapMethod</span></span>() &#123;</div><div class="line">        <span class="built_in">return</span> MethodType.fromMethodDescriptorString(<span class="string">"(Ljava/lang/invoke/MethodHandles<span class="variable">$Lookup</span>;Ljava/lang/String;Ljava/lang/invoke/MethodType;)"</span> +</div><div class="line">                <span class="string">"Ljava/lang/invoke/CallSite;"</span>, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static MethodHandle MH_BootstrapMethod() throws Exception &#123;</div><div class="line">        <span class="built_in">return</span> lookup().findStatic(InvokeDynamicTest.class, <span class="string">"BootstrapMethod"</span>, MT_BootstrapMethod());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static MethodHandle INDY_BootstrapMethod() throws Throwable &#123;</div><div class="line">        CallSite cs = (CallSite)MH_BootstrapMethod().invokeWithArguments(lookup(), <span class="string">"testMethod"</span>, MethodType</div><div class="line">        .fromMethodDescriptorString(<span class="string">"(Ljava/lang/String;"</span> + <span class="string">")V"</span>, null));</div><div class="line">        <span class="built_in">return</span> cs.dynamicInvoker();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出结果：</div><div class="line">Hello String:my god.</div></pre></td></tr></table></figure>
<p>掌握方法分派规则：invokedynamic指令与其他invoke<em>*</em>指令最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定的。super调用父类方法，如果访问祖类方法可使用MethodHandle。如下代码示例MethodHandle访问祖类方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm.dynamic;</div><div class="line"></div><div class="line">import static java.lang.invoke.MethodHandles.lookup;</div><div class="line"></div><div class="line">import java.lang.invoke.MethodHandle;</div><div class="line">import java.lang.invoke.MethodType;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 子类调用祖类方法演示</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-27</div><div class="line"> */</div><div class="line">@SuppressWarnings(<span class="string">"unused"</span>)</div><div class="line">public class GrandFatherTest &#123;</div><div class="line"></div><div class="line">    private class GrandFather &#123;</div><div class="line">        void <span class="function"><span class="title">thinking</span></span>() &#123;</div><div class="line">            System.out.println(<span class="string">"I am grandFather."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class Father extends GrandFather &#123;</div><div class="line">        @Override</div><div class="line">        void <span class="function"><span class="title">thinking</span></span>() &#123;</div><div class="line">            System.out.println(<span class="string">"I am father."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private class Son extends Father &#123;</div><div class="line">        /**</div><div class="line">         * 实现调用祖父类的thinking方法,JDk1.7之前很难代码实现，但可直接生成字节码解决。现在可利用如下代码解决.....悲剧了。结果对不上</div><div class="line">         */</div><div class="line">        @Override</div><div class="line">        void <span class="function"><span class="title">thinking</span></span>() &#123;</div><div class="line">            try &#123;</div><div class="line">                MethodType <span class="built_in">type</span> = MethodType.methodType(void.class);</div><div class="line">                MethodHandle handle = lookup().findSpecial(GrandFather.class, <span class="string">"thinking"</span>, <span class="built_in">type</span>, getClass());</div><div class="line">                handle.invoke(this);</div><div class="line">            &#125; catch (Throwable throwable) &#123;</div><div class="line">                System.out.println(<span class="string">"UNKNOWN ERROR!"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        (new GrandFatherTest().new Son()).thinking();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h4><p>许多java虚拟机的执行引擎在执行java代码的时候都有解释执行 和 编译执行两种选择。如下图所示：</p>
<p><img src="/虚拟机字节码执行引擎/编译过程.png" alt=""></p>
<p>javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。这部分动作都是java虚拟机之外进行的，而解释器在虚拟机内部，所以java程序的编译是半独立的实现。</p>
<p>java编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流中的指令大部分都是零地址指令。</p>
<p>优点：可移植，用户程序不会直接使用这些寄存器，可由虚拟机自行决定，代码相对更加紧凑(字节码中每个字节就对应一个指令)，编译器实现更加简单(无需考虑空间分配问题，所有空间都在栈上操作)。它们依赖操作数栈进行工作。</p>
<p>而另一套常用的是基于寄存器的指令集。</p>
<p>优点：速度快，完成同样功能所需指令数量少，更重要，栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对处理器而言，内存速度始终是执行速度的瓶颈，尽管虚拟机可以采取栈顶缓存的手段，如把最常用的操作映射到寄存器中避免直接访问内存，但只属于优化措施，没解决本质，所以指令数量和内存访问的原因导致了栈架构指令集的执行速度会相对较慢。</p>
<p>注：由于篇幅有限，在此就不再做关于基于栈的解释器的执行过程，如有需要请见例子详解P293。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[java类加载]]></title>
      <url>https://glenen.github.io/java%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>文中所涉及内容均为java虚拟机相关，但由于java虚拟机团队也一直在改进和优化java虚拟机，其中有的内容可能会与后续版本有差异，所以文中内容仅提供参考，不可作为任何定义为任何标准的准则，敬请谅解。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分讲述了虚拟机的类加载机制，虚拟机什么时候进行类加载，即类加载时机。对类加载的各个过程进行了详细的讲解。次外还对类加载器进行了描述，包括类加载器的双亲委派类型。</p>
<a id="more"></a>
<h4 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h4><p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的java类型。</p>
<p>与那些在编译时需要进行连接工作的语言不同，在java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成，该策略虽然会令类加载时稍微增加一些性能的开销，但是为java应用程序提供了高度的灵活性，java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。</p>
<h4 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h4><p><img src="/java类加载/类的生命周期.png" alt=""></p>
<p>加载、验证、准备、初始化和卸载这5个阶段顺序是确定的，但并不是按这个顺序进行或完成，因为这些阶段通常都是相互交叉地混合式进行的，通常会在一个阶段执行中调用、激活另一个阶段。而解析阶段不一定：在某些情况下可以在初始化之前开始，这是为了支持java语言的运行时绑定。</p>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>即加载、验证、准备、解析和初始化这5个阶段所执行的具体操作。</p>
<p><strong>加载：</strong>该阶段，虚拟机需完成3件事：</p>
<p>1、通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p>3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。注意：数组类本身不通过类加载器创建，它由java虚拟机直接创建，但数组类的元素类型最终还是要靠类加载器取创建。</p>
<p>加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个Class类对象(并没有明确规定在java堆中，对于HotSpot而言，class对象比较特殊，存放在方法区中)，这个对象将作为程序访问方法区中的这些数据类型的外部接口。</p>
<p>加载阶段和连接阶段的部分内容如一部分字节码文件格式验证动作是交叉进行的，加载阶段尚未开始，连接阶段可能已经开始。但这些夹在加载阶段中的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<p><strong>验证：</strong>该阶段目的为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危险虚拟机自身的安全。原因：class文件并不一定从java源码编译而来，可用别的任何途径产生，因此java代码无法做到的事情都是可以实现的，如访问数组边界以外的数据、跳转到不存在的代码行。</p>
<p>文件格式验证：是否以魔数开头、主次版本号是否在当前虚拟机的处理范围内等等。该验证目的是保证输入的字节流能正确地解析并存储于方法区中。后3个验证全部基于方法区的存储结构进行，不会再直接操作字节流。</p>
<p>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。如这个类是否有父类、该类不是抽象类，是否实现了其父类或者接口中要求实现的所有方法等等。</p>
<p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对方法体进行校验分析，保证被校验的类在运行时不会做出危险虚拟机安全的事件。如保证跳转指令不会跳转到方法体以外的字节码指令上。该验证不通过，肯定有问题，通过该验证并不一定就是安全的。</p>
<p>符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候，即在解析阶段中发生。可看作是对类自身以外的信息进行匹配性校验。如符号引用中通过字符串描述的全限定名是否能找到对应的类、符号引用中的类 字段 方法的访问性是否可被当前内访问。通不过该验证，将抛出IllegalAccesserror、NoSuchFieldError、NoSuchMethodError等。</p>
<p><strong>准备：</strong>正式为类变量分配内存并设置类变量初始值的阶段，均在方法区中进行分配。该处所说的初始值通常情况下是数据类型的零值，而不是程序中赋予的值，因为这时候尚未开始执行任何java方法。而把赋值的putstatic指令是在程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以赋值操作将在初始化阶段才会执行。各种基本数据类型的零值如下图所示：</p>
<p><img src="/java类加载/基本数据类型零值.png" alt=""></p>
<p>特殊情况：如果类字段的字段属性表中存在ConstantValue属性(final修饰的static变量)，那么在准备阶段变量就会被初始化为ConstantValue属性所指定的值。</p>
<p><strong>解析：</strong>虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>符号引用Symbolic Reference：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，且和虚拟机内存布局无关。</p>
<p>直接引用Direct Reference：直接引用可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄，且和虚拟机实现的内存布局相关。</p>
<p>类或接口的解析：假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，需以下3步：</p>
<p>1、如果C不是一个数组类型，虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。</p>
<p>2、如果C是一个数组类型，并且数组元素类型为对象，也就是N的描述符会是类似<code>Ljava/lang/Integer</code>的形式，那将会按照第一点的规则去加载数组元素类型。如果N的描述符如前面假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。 </p>
<p>3、如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或者接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出“java.lang.IllegalAccessError”异常。</p>
<p>字段解析：要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSRTANT_Class_info符号引用进行解析，也就是字段所属类或者接口的符号引用。如果在解析这个类或者接口符号引用过程中出现了异常，都会导致字段符号引用解析的失败。如果解析成功，将这个字段所属的类或者接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：</p>
<p>1、如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>2、否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标类型相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>3、否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其各个父类，如果在父类中包含了简单名称和字段描述符都与目标类型相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>4、否则，查找失败，抛出java.lang.NoSuchFieldError 。</p>
<p>注：类方法解析和接口方法解析与字段解析类似。</p>
<p><strong>初始化：</strong>到了该阶段才真正开始执行类中定义的java程序代码，是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<h5 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h5><p>在虚拟机规范中严格规定了有且只有5种情况下必须对立即对类进行初始化：</p>
<p>1、遇到new、getstatic、putstatic或invokestatic这4条指令时，如果类没有进行过初始化，则需要先触发其初始化。</p>
<p>2、使用java.lang.reflect包的方法对类进行反射调用的时候。</p>
<p>3、当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>4、当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类。</p>
<p>5、当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果<code>REF_getStatic</code>   <code>REF_putStatic</code>  <code>REF_invokeStatic</code>的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则先触发其初始化。  </p>
<p>这5种场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发其初始化，称为被动引用。且接口与类初始化不同：初始化一个接口时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候如引用接口中定义的常量才会初始化。</p>
<h5 id="执行-lt-clinit-gt-方法"><a href="#执行-lt-clinit-gt-方法" class="headerlink" title="执行&lt;clinit&gt;()方法"></a>执行<code>&lt;clinit&gt;()</code>方法</h5><p>1、<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。顺序是由语句在原文件中出现的顺序决定的。静态语句块中只能访问定义在其之前的变量，定义在其后的变量，只能赋值，不能访问。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 静态语句块中只能访问定义在其之前的变量，定义在其后的变量，只能赋值，不能访问</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-16</div><div class="line"> */</div><div class="line">public class IllegalForwardTest &#123;</div><div class="line">    static &#123;</div><div class="line">        index = 1;</div><div class="line">        //System.out.println(index);</div><div class="line">    &#125;</div><div class="line">    static int index;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2、<code>&lt;clinit&gt;()</code>方法与实例构造器<code>&lt;init&gt;()</code>方法不同，它不需要显式地调用父类构造器，虚拟机会保证子类的<code>&lt;clinit&gt;()</code>方法执行前父类的<code>&lt;clinit&gt;()</code>方法以及执行完毕。所以<code>Object的&lt;clinit&gt;()</code>方法第一个被执行。</p>
<p>3、因为父类的<code>&lt;clinit&gt;()</code>方法先执行，也意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p>
<p>4、<code>&lt;clinit&gt;()</code>方法对于类或接口并不是必须的，如果一个类中没有静态语句块，也就没有对变量的赋值操作，那么编译器可以不为这个类生成的<code>&lt;clinit&gt;()</code>方法。</p>
<p>5、虚拟机会保证一个类的的<code>&lt;clinit&gt;()</code>方法在多线程环境下能被正确地同步执行，被唤醒的线程也不会在执行的<code>&lt;clinit&gt;()</code>方法，只会被执行一次。</p>
<p>下面我们就用代码示例来验证被动引用引发类的初始化(示例类都在一个包中)：</p>
<p>SuperMan类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm.passive;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-23</div><div class="line"> */</div><div class="line">class SuperMain &#123;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        System.out.println(<span class="string">"SuperMain init."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static int value = 123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SubMain类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm.passive;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-23</div><div class="line"> */</div><div class="line">class SubMain extends SuperMain &#123;</div><div class="line">    static &#123;</div><div class="line">        System.out.println(<span class="string">"SubMain init."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConstMain类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm.passive;</div><div class="line"></div><div class="line">/**</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-23</div><div class="line"> */</div><div class="line">class ConstMain &#123;</div><div class="line">    static &#123;</div><div class="line">        System.out.println(<span class="string">"ConstMain init."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static final String HELLO_WORLD = <span class="string">"hello world."</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NotInitializationTest测试类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm.passive;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 1、通过子类引用父类的静态字段，不会导致子类初始化</div><div class="line"> * 结论：对于静态字段，只有直接定义这个字段的类才会初始化因此通过其子类引用父类中定义的静态字段，</div><div class="line"> * 只会触发父类的初始化而不会触发子类的初始化。</div><div class="line"> *</div><div class="line"> * 2、通过数组定义引用类，不会触发此类的初始化</div><div class="line"> *</div><div class="line"> * 3、常量在编译阶段会存入调用类的常量池，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</div><div class="line"> * 其实在编译阶段通过常量传播优化</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-23</div><div class="line"> */</div><div class="line">@SuppressWarnings(<span class="string">"unused"</span>)</div><div class="line">public class NotInitializationTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        /*1*/</div><div class="line">        System.out.println(subMain.value);</div><div class="line"></div><div class="line">        /*2*/</div><div class="line">        SuperMain[] main = new SuperMain[10];</div><div class="line"></div><div class="line">        /*3*/</div><div class="line">        System.out.println(ConstMain.HELLO_WORLD);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">输出结果：</div><div class="line">SuperMain init.</div><div class="line">123</div><div class="line">hello world.</div></pre></td></tr></table></figure>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>虚拟机设计团队把类加载阶段中的通过一个类的全限定名来获取描述此类的二进制节流这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码模块叫做类加载器。</p>
<p>对于任意一个类，都需要由它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类命名空间，即比较两个类是否相等，只有在它们在同一个类加载器的前提下才有意义。该处所指相等代表类的class对象的equal方法、isAssignableForm方法、isInstance方法返回的结果，也包括使用instanceof关键字做对象所属关系判断等情况。</p>
<h5 id="双亲委派类型"><a href="#双亲委派类型" class="headerlink" title="双亲委派类型"></a>双亲委派类型</h5><p>java虚拟机角度而言，只存在两种不同的类加载器：1、启动类加载器Bootstrap ClassLoader，C++实现，属于虚拟机自身一部分；2、所有其他的类加载器，都由java实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader.</p>
<p>java开发人员而言：绝大部分java程序都会使用到以下3种体统提供的类加载器：</p>
<p>1、启动类加载器，负责将存放在java_home下<code>／lib</code>目录中的，或者被-Xbootstrappath参数所指定的路径中的，并且是被虚拟机识别的(仅按文件名识别，如rt.jar，名字不符合的类库放在其中也不会被加载)类库加载到虚拟机中。无法被java程序直接引用，用户在编写自定义的类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</p>
<p>2、扩展类加载器Extension ClassLoader：由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载java_home下<code>／lib／ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
<p>3、应用程序类加载器Application ClassLoader：由<code>sun.misc.Launcher$EAppClassLoader</code>实现，因为该类加载器是ClassLoader中的getSystemClassLoader()方法等返回值，所以一般称为系统类加载器。负责加载用户路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义，这个就是程序中默认的类加载器。</p>
<p><img src="/java类加载/类加载器.png" alt=""></p>
<p>注：这里的类加载器父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器的代码。</p>
<p><strong>工作过程：</strong>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把请求委派给父加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试去自己加载。如下代码示例了如何自定义一个类加载器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 类加载器与instanceof关键字演示</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-19</div><div class="line"> */</div><div class="line">public class ClassLoaderTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        /*构建一个类加载器*/</div><div class="line">        ClassLoader myLoader = new <span class="function"><span class="title">ClassLoader</span></span>() &#123;</div><div class="line">            @Override</div><div class="line">            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</div><div class="line">                try &#123;</div><div class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + 1) + <span class="string">".class"</span>;</div><div class="line">                    InputStream inputStream = getClass().getResourceAsStream(fileName);</div><div class="line">                    <span class="keyword">if</span> (inputStream == null) &#123;</div><div class="line">                        <span class="built_in">return</span> super.loadClass(name);</div><div class="line">                    &#125;</div><div class="line">                    byte[] b = new byte[inputStream.available()];</div><div class="line">                    inputStream.read(b);</div><div class="line">                    <span class="built_in">return</span> defineClass(name, b, 0, b.length);</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    throw new ClassNotFoundException(name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Object ob = myLoader.loadClass(<span class="string">"com.beebank.riskmanage.jvm.ClassLoaderTest"</span>).newInstance();</div><div class="line">        System.out.println(ob.getClass());</div><div class="line">        System.out.println(ob instanceof ClassLoaderTest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>好处：</strong>java类随着它的类加载器一起具备了一种带有优先级的层次关系。破坏双亲委派类型的例子见P255页面。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[class类文件与字节码指令]]></title>
      <url>https://glenen.github.io/class%E7%B1%BB%E6%96%87%E4%BB%B6%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>文中所涉及内容均为java虚拟机相关，但由于java虚拟机团队也一直在改进和优化java虚拟机，其中有的内容可能会与后续版本有差异，所以文中内容仅提供参考，不可作为任何定义为任何标准的准则，敬请谅解。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分讲述了class类文件的结构，组成类文件的各个部分的详细描述。让读者对class类文件有一个更好的认识，也能对java语言本身有一个更深入的思考。还对java的字节码指令做了简介，各种指令的详细内容并未讨论，如有需要的可自行查阅相关资料。</p>
<a id="more"></a>
<h4 id="class类文件"><a href="#class类文件" class="headerlink" title="class类文件"></a>class类文件</h4><h5 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h5><p>代码编译的结果从本地机器码转变为字节码。越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式——字节码——构成平台无关性的基石。</p>
<h5 id="java虚拟机的语言无关性"><a href="#java虚拟机的语言无关性" class="headerlink" title="java虚拟机的语言无关性"></a>java虚拟机的语言无关性</h5><p>指其他语言编写的程序也能运行在java虚拟机上。</p>
<p><strong>基础1：</strong>仍是虚拟机和字节码存储格式，java虚拟机不与包括java在内的任何语言绑定，它只与Class文件这种特定的二进制文件格式关联，Class文件中包含了虚拟机指令集和符号表以及若干其他辅助信息。各种语言通过对应编译器编码成 .class 文件由java虚拟机执行。</p>
<p><strong>基础2：</strong>java语言中的各种变关键字和运算符号等语义最终都有多条字节码命令组合而成，因此字节码命令所能提供的语义描述能力肯定比语言本身更加强大。所以字节码本身能支持一些java语言本身无法有效支持的一些的特性。</p>
<h5 id="java平台无关性"><a href="#java平台无关性" class="headerlink" title="java平台无关性"></a>java平台无关性</h5><p>通过java虚拟机，java能实现一次编写各种平台运行，虚拟机就相当于与各种操作系统平台对接的适配器。</p>
<h5 id="class类文件的结构"><a href="#class类文件的结构" class="headerlink" title="class类文件的结构"></a>class类文件的结构</h5><p>任何一个class文件都对应着唯一一个类或者接口的定义信息，但反之类或者接口并不一定都得定义在文件里，比如类或接口也可以直接通过类加载器直接生成。class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中，中间没有添加任何分隔符，这使得整个class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。</p>
<p>如遇到需占用8位字节以上的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。采用无符号数和表两种数据类型的伪结构来存储数据。其所有细节都被严格限定，不允许改变。class类文件格式如下图所示：</p>
<p><img src="/class类文件与字节码指令/class文件.png" alt=""></p>
<p><strong>无符号数：</strong>基本数据类型，u1  u2  u4  u8来分别代表1  2  4  8个字节的无符号数，可用来描述数字、索引引用、数量值、或者按照UTF—8编码构成的字符串值。</p>
<p><strong>表：</strong>由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合数据结构，整个class文件本质上就是一张表。</p>
<p><strong>魔数：</strong>每个class文件的头4个字节，唯一作用是确定这个文件是否是一个能被虚拟机接受的class文件。使用魔数而不是扩展名来进行识别，因为文件扩展名可随意改动。class文件的魔数值：0xCAFEEBABE—咖啡宝贝。</p>
<p><strong>版本号：</strong>紧接着魔数的4个字节，5  6个字节是次版本号，7  8个字节是主版本号。高版本JDK能向下兼容以前版本class文件，但不能运行超过其版本号的class文件，即使文件格式没发生任何变化。</p>
<p><strong>常量池：</strong>紧接着主次版本号之后的是常量池入口，可理解为class文件之中的资源仓库，class文件结构中与其他项目关联最多的数据类型，也是占用class文件空间最大的数据类型项目之一，同时它还是class文件中第一个出现的表类型数据项目。</p>
<p>常量池容量计数器从 1 开始，为了满足后面某些指向常量池的索引值的数据在特定情况下需表达不引用任何一个常量池项目的含义，可把索引值置为0来表示，除此之外其他任何容量计数器都是0开始。</p>
<p>常量池存放字面量literal 和 符号引用symbolic reference。字面量比较接近于java语言层面的常量概念、文本字符串、声明为final的常量值等。而符号引用属于编译原理方面的概念：类和接口的全限定名fully qualified name、字段的名称和描述符descriptor、方法等名称和描述符。</p>
<p>java代码在进行javac编译时候，虚拟机加载class文件的时候进行动态链接，即class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法被虚拟机使用，当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>
<p>常量池的每一项常量都是一个表，JDK1.7后共有14种结构各不相同的表结构数据。14种表都有一个共同特点，表开始的第一位是一个u1类型的标识位，代表当前这个常量属于哪种常量类型。如下图所示：</p>
<p><img src="/class类文件与字节码指令/常量池项目类型.png" alt=""></p>
<p>每种常量类型都有属于自己的结构，如<code>CONSTANT_Utf8_info</code>常量的结构如下图所示：</p>
<p><img src="/class类文件与字节码指令/CONSTANT_Utf8_info常量的结构.png" alt=""></p>
<p>注意：由于class文件中方法、字段等都需要引用<code>CONSTANT_Utf8_info</code>型常量来描述名称，所以该型常量的最大长度就是java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，即u2类型能表达的最大值65536，所以java程序中如果定义了超过64KB英文字符的变量或方法名将会无法编译。</p>
<p><strong>访问标志：</strong>紧接着常量池，用于识别一些类或者接口层次的访问信息：是类还是接口、是否为public类型、是否为abstract类型、是否被声明为final等。</p>
<p><strong>类索引、父类索引、接口索引集合：</strong>this_class、super_class都是一个u2类型的数据，而接口索引是一组u2类型的数据等集合，class文件中由这三项数据来确定这个类等继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p>
<p>除Object外，所有java类的父类索引都不为0. 接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句后的接口顺序从左到右排列在接口索引集合中。</p>
<p><strong>字段表集合：</strong>用于描述接口或者类中声明的变量。包括类级变量及实例变量，不包括方法内部声明的局部变量。字段的修饰符都是布尔值，要么有要么没有，很适合用标识位来表示，而字段叫什么名字、数据类型都是无法固定的，只能引用常量池中的常量来描述。</p>
<p><strong>方法表集合：</strong>与class文件对字段的描述方式几乎采用了完全一致的方式。注意：方法里的java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为code的属性里面。</p>
<p><strong>属性表集合：</strong>在class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。以下举例2个，共有11个之多。</p>
<p>code属性：java程序方法体中的代码经过javac编译器处理后，最终变为字节码指令存储在code属性内。code属性出现在方法表的属性集合中，但并非所有的方法表都必须存在这个属性，如接口或抽象类中的方法。</p>
<p>exceptions属性：与code属性平级，用于列举出方法中可能抛出的受检异常，也就是方法描述时throws关键字后面列举的异常。</p>
<h4 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h4><p>java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(操作码Opcode)以及跟随其后的0到多个代表此操作所需参数(操作数Operands)构成。</p>
<p>java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。不考虑异常，java虚拟机的解释器可以使用以下执行模型来理解：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    自动计算PC寄存器的值加1;</div><div class="line">    根据PC寄存器的指示位置，从字节码流中取出操作码;</div><div class="line">    <span class="keyword">if</span>(字节码存在操作数) 从字节码流中取出操作数;</div><div class="line">    执行操作码所定义的操作;</div><div class="line">&#125; <span class="keyword">while</span>(字节码流长度 &gt; 0);</div></pre></td></tr></table></figure>
<p><strong>字节码与数据类型：</strong>java虚拟机中，大多数的指令都包含了其操作多对应的数据类型信息，如iload指令用于从局部变量表中加载int型数据到操作数栈中。对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊来代表专门为哪种数据类型服务，i-int,  l-long,  a-reference.其他基本类型均取首字母。</p>
<p><strong>加载和存储指令：</strong>用于将数据在帧栈中的局部变量表和操作数栈之间来回传输。将一个局部变量加载到操作数栈：类型+load 如iload。 将一个数值从操作数栈存储到局部变量表：类型+store。将一个常量加载到操作数栈：类型+const或其他。</p>
<p><strong>运算指令：</strong>将两个操作数栈上的值进行某种特定运算，并把结果重新存入操作数栈顶。</p>
<p><strong>类型转换指令：</strong>将两种不同的数值类型进行相互转换，一般用于实现用户代码中的显式类型的转换操作。</p>
<p><strong>对象创建与访问指令：</strong>虽然实例和数组都是对象，但是创建和操作使用了不同的字节码指令。</p>
<p><strong>操作数栈管理指令：</strong>pop , pop2 , swap。</p>
<p><strong>控制转移指令：</strong>让java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。</p>
<p><strong>方法调用和返回指令：</strong>invoke+具体。方法调用指令与数据类型无关，方法返回指令是根据返回值的类型区分的，如ireturn。</p>
<p><strong>异常处理指令：</strong>ava程序中显式的抛出异常操作throw语句 及 运行时异常自动抛出，都有athrow指令来实现。</p>
<p><strong>同步指令：</strong>支持方法级的同步和方法内部一段指令序列的同步，都使用管程Monitor来支持。方法级的同步是隐式的，无需通过字节码指令来控制，它实现在方法调用和返回操作之中。</p>
<p>方法级的同步是隐式的，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。</p>
<p>当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成，包括正常完成和非正常完成，释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。</p>
<p>同步一段指令集序列通常都是由java语言中的synchronized语句块来表示的，java虚拟机的指令集中有monitorenter 和 monitorexit两条指令来支持synchronized关键字语义，正确实现synchronized关键字需要javac编译器和java虚拟机两者共同协作支持，如下代码所示：</p>
<p><img src="/class类文件与字节码指令/synchronized.png" alt=""></p>
<p>为了保证方法在异常完成时每条monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，其声明可处理所有异常，目的用来执行monitorexit指令。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[线程安全与锁优化]]></title>
      <url>https://glenen.github.io/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>文中所涉及内容均为java虚拟机相关，但由于java虚拟机团队也一直在改进和优化java虚拟机，其中有的内容可能会与后续版本有差异，所以文中内容仅提供参考，不可作为任何定义为任何标准的准则，敬请谅解。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分讲述了什么是线程安全，线程安全的4个级别，如何实现线程的安全：使用互斥同步和非阻塞同步。以及java虚拟机为了提高程序的运行效率，进行的各种锁优化。</p>
<a id="more"></a>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度与交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</p>
<h5 id="java中操作共享数据分类"><a href="#java中操作共享数据分类" class="headerlink" title="java中操作共享数据分类"></a>java中操作共享数据分类</h5><p>不可变：可不变immutable的对象一定是线程安全的；java中，基本数据类型使用final修饰则是不可变的，如果共享一个对象，则需要保证对象的行为不会对其状态产生任何影响：把对象中带有状态的变量都声明为final。</p>
<p>不可变要求类型：String类、Number部分子类、Long和Double值类包装类、BigInteger和BigDecimal大数据类型。</p>
<h5 id="线程安全级别"><a href="#线程安全级别" class="headerlink" title="线程安全级别"></a>线程安全级别</h5><p>绝对线程安全：即完全满足线程安全定义。如Vector是个线程安全的容器，每个方法都用synchronized修饰，但是并不意味着调用它的时候永远都不在需要同步手段。</p>
<p>相对线程安全：即我们通常意义上所讲的线程安全，大体线程安全，但对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用准确性。如Vector、HashTable等。</p>
<p>线程兼容：对象本身并不是线程安全，但可以通过在调用端正确的使用同步手段来保证对象在并发情况下安全的使用。如ArrayList、HashMap等。</p>
<p>线程对立：无论调用端是否采用了同步措施，都无法在多线程环境中并发地使用代码。</p>
<h4 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h4><h5 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h5><p>同步指多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥现实方式。互斥是因，同步是果；互斥是方法，同步是目的。</p>
<h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>我们先通过双检测模式生成单例的代码入手：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.ton;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 双检测模式创建单例</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-28</div><div class="line"> */</div><div class="line">public class Singleton<span class="variable">$1</span> &#123;</div><div class="line">    private volatile static Singleton<span class="variable">$1</span> instance = null;</div><div class="line">    private Singleton<span class="variable">$1</span>() &#123;&#125;</div><div class="line">    public static Singleton<span class="variable">$1</span> <span class="function"><span class="title">getInstance</span></span>() &#123;</div><div class="line">        <span class="keyword">if</span> (instance == null) &#123;</div><div class="line">            synchronized (Singleton<span class="variable">$1</span>.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == null) &#123;</div><div class="line">                    instance = new Singleton<span class="variable">$1</span>();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(getInstance());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经编译后，生成字节码序列如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public class com.woodpecker.ton.Singleton<span class="variable">$1</span> &#123;</div><div class="line">  public static com.woodpecker.ton.Singleton<span class="variable">$1</span> getInstance();</div><div class="line">    Code:</div><div class="line">       0: getstatic     <span class="comment">#2                  // Field instance:Lcom/woodpecker/ton/Singleton$1;</span></div><div class="line">       3: ifnonnull     37</div><div class="line">       6: ldc           <span class="comment">#3                  // class com/woodpecker/ton/Singleton$1</span></div><div class="line">       8: dup</div><div class="line">       9: astore_0</div><div class="line">      10: monitorenter</div><div class="line">      11: getstatic     <span class="comment">#2                  // Field instance:Lcom/woodpecker/ton/Singleton$1;</span></div><div class="line">      14: ifnonnull     27</div><div class="line">      17: new           <span class="comment">#3                  // class com/woodpecker/ton/Singleton$1</span></div><div class="line">      20: dup</div><div class="line">      21: invokespecial <span class="comment">#4                  // Method "&lt;init&gt;":()V</span></div><div class="line">      24: putstatic     <span class="comment">#2                  // Field instance:Lcom/woodpecker/ton/Singleton$1;</span></div><div class="line">      27: aload_0</div><div class="line">      28: monitorexit</div><div class="line">      29: goto          37</div><div class="line">      32: astore_1</div><div class="line">      33: aload_0</div><div class="line">      34: monitorexit</div><div class="line">      35: aload_1</div><div class="line">      36: athrow</div><div class="line">      37: getstatic     <span class="comment">#2                  // Field instance:Lcom/woodpecker/ton/Singleton$1;</span></div><div class="line">      40: areturn</div><div class="line">    Exception table:</div><div class="line">       from    to  target <span class="built_in">type</span></div><div class="line">          11    29    32   any</div><div class="line">          32    35    32   any</div><div class="line"></div><div class="line">  public static void main(java.lang.String[]);</div><div class="line">    Code:</div><div class="line">       0: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></div><div class="line">       3: invokestatic  <span class="comment">#6                  // Method getInstance:()Lcom/woodpecker/ton/Singleton$1;</span></div><div class="line">       6: invokevirtual <span class="comment">#7                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span></div><div class="line">       9: <span class="built_in">return</span></div><div class="line"></div><div class="line">  static &#123;&#125;;</div><div class="line">    Code:</div><div class="line">       0: aconst_null</div><div class="line">       1: putstatic     <span class="comment">#2                  // Field instance:Lcom/woodpecker/ton/Singleton$1;</span></div><div class="line">       4: <span class="built_in">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果java程序中synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。</p>
<p>在执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没有被锁定，或当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的在执行monitorexit时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那么当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p>
<p><strong>注意</strong></p>
<p>1、synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题；</p>
<p>2、同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。java的线程是映射到操作系统的原生线程之上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态上，因此状态转换需要耗费很多的处理器时间，对于代码简单的同步块，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<h5 id="reentrantLock"><a href="#reentrantLock" class="headerlink" title="reentrantLock"></a>reentrantLock</h5><p>与synchronized相似，都具备一样的线程重入特性。</p>
<p><strong>区别</strong></p>
<p>1、表现为互斥层面的互斥锁，lock()和unlock()方法配合try／catch语句块来完成；</p>
<p>2、表现为原生语法层面的互斥锁。</p>
<p><strong>高级特性</strong></p>
<p>1、等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，该特性对处理执行时间非常长的同步块很有帮助；</p>
<p>2、实现公平锁：多个线程在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待的线程都有机会获得锁。synchronized是非公平的，reentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</p>
<p>3、锁绑定多个条件：一个reentrantLock对象可以同时绑定多个Condition对象。</p>
<p><strong>对比：</strong>需要使用reentrantLock高级特性的，reentrantLock是个很好选择。基于性能考虑，synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。</p>
<h5 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h5><p>互斥同步最主要问题就是进行线程阻塞和唤醒所带来的性能问题，该同步也称为阻塞同步，属于一种悲观的并发策略。</p>
<p>随着硬件指令集的发展，基于冲突检测的乐观并发策略：就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常用不断重试直到成功），这种乐观的并发策略的许多实现都不需要把线程挂起，因此该同步操作称为非阻塞同步。</p>
<p>使用乐观并发策略我们需要操作和冲突检测这两个步骤具备原子性，需要且只能依靠硬件来完成，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。CAS就是一条处理器指令，CAS过程是一个原子操作。</p>
<p>CAS的ABA问题：如果一个V初次读取的时候是A值，并且在准备赋值的时候检测到它仍然为A值，那我们就能说它没有被其他线程改变过吗？如果这段时间它的值曾经被改成了B，后来又被改成回A，那CAS操作就会误认为它从来没有被改变过。</p>
<p>J.U.C为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它通过控制变量值的版本来保证CAS的准确性。</p>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p>各种锁技术都是为了在线程之间更高效的共享数据，以及解决竞争问题，从而提高程序执行效率。</p>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>如果物理机上有一个以上的处理器，能让两个或两个以上的线程同时执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，为了让线程等待，我们只需要让线程执行一个忙循环(自旋)。</p>
<p><strong>特点：</strong>不能代替阻塞，虽避免线程切换开销，但占用处理器时间，锁被占用时间很短，效果非常好，自旋次数默认值10。如果锁被占用时间很长，则自旋的线程会白白浪费处理器资源，不做任何工作而带来性能上的浪费。超过该次数没有成功获得锁则应当使用传统的方式去挂起线程。-XX:PreBlockSpin设置自旋次数。</p>
<h5 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h5><p>意味自旋的时间不再固定，而由前一次在同一个锁上的自旋时间及锁的拥有者状态来决定。</p>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>虚拟机即时编译器在运行时，对一些代码上要求同步但是被检查到不可能存在共享数据竞争的锁进行消除。</p>
<p>判定标准：逃逸分析的数据支持，如果判定在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是私有的，同步加锁就无需进行。</p>
<p>如String类的字符串“+”操作，javac编译器会自动优化，转化为Stringbuilder的连续append操作。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">String result = s1 + s2 + s3;</div><div class="line"><span class="built_in">return</span> result;</div><div class="line"></div><div class="line">javac编译器会自动优化</div><div class="line"></div><div class="line">StringBuilder appender = new StringBuilder();</div><div class="line">appender.append(s1);</div><div class="line">appender.append(s2);</div><div class="line">appender.append(s3);</div><div class="line"><span class="built_in">return</span> appender.toString();</div></pre></td></tr></table></figure>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>原则：我们在编写代码的时候，总是推荐将同步块的作用范围限制得最小 — 只在共享数据的实际作用域中才进行同步，目的使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>例外情况：一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中，即使没有线程竞争，也会导致不必要的线程损耗，这时虚拟机就会把加锁同步的范围扩展(粗化)到整个操作序列的外部，如StringBuffer的append操作。</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>使用操作系统互斥量的传统锁机制称为“重量级”锁。需强调，轻量级锁并不是用来代替重量级锁，本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。对象头第一部分存储对象自身的运行时数据是实现轻量级锁和偏向锁的关键。HotSpot虚拟机对象头Mark Word如下所示:</p>
<p><img src="/线程安全与锁优化/MarkWord.png" alt=""></p>
<p><strong>加锁过程：</strong>代码进入同步块的时候，如果此同步对象没有被锁定(锁标志位为“01”状态)，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录Lock Record的空间，用于存储锁对象目前的Mark Word的拷贝，即Displaced Mark Word，此时线程堆栈与对象头的状态如图所示：</p>
<p><img src="/线程安全与锁优化/CAS前.png" alt=""></p>
<p>然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功，那么这么线程就拥有了该对象的锁，且对象Mark Word的锁标志位将变为“00”，即表示该对象处于轻量级锁状态，如下图所示：</p>
<p><img src="/线程安全与锁优化/CAS后.png" alt=""></p>
<p>如果更新操作失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，则可直接进入同步块继续执行。否则说明这个对象的锁已经被其他线程抢占了。</p>
<p>如果两条以上的线程争用同一个锁，那么轻量级锁将不再有效，膨胀为重量级锁，锁标志位状态变为“10”。Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程将进入阻塞状态。</p>
<p><strong>解锁过程：</strong>通过CAS进行，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，替换成功，整个同步过程完成。替换失败，说明有其他线程尝试过获取该锁，就需要在释放锁的同时唤醒被挂起的线程。</p>
<p><strong>轻量级锁提升程序同步性能依据：</strong>对于绝大部分的锁，整个同步周期内都是不存在竞争的。没有竞争，CAS操作避免了使用互斥量的开销，存在锁竞争，除了互斥量的开销，还额外发生CAS操作，此时比传统的重量级锁更慢。</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>目的是消除清除数据在无竞争的情况下同步原语，进一步提高程序性能。偏向锁在无竞争情况下把整个同步都消除，连CAS操作都不做。</p>
<p><strong>“偏”：</strong>该锁会偏向于第一个获得它的线程，如果接下来执行过程中该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p><strong>过程：</strong>锁对象第一次被线程获取时候，虚拟机会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。当有另外一个线程去尝试获取这个锁时，偏向模式宣告结束。</p>
<p>根据锁对象目前是否处于被锁定状态，撤销偏向后恢复到未锁定或轻量级锁定状态，后序同步操作就如同上面介绍的轻量级锁那样进行。偏向锁、轻量级锁的状态转换及对象Mark Word的关系如图所示：</p>
<p><img src="/线程安全与锁优化/偏向锁.png" alt=""></p>
<p>偏向锁可提高带有同步但无竞争的程序性能，但它并不是一定总是对程序有利，如果程序中大多数的锁总是被多个不同的线程访问，则偏向锁就是多余的。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap原理]]></title>
      <url>https://glenen.github.io/HashMap%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>因本文是本人自己通过阅读HashMap源码总结而来，涉及内容可能会不全或者存在错误，敬请谅解。HashMap是基于JDK1.8版本，涉及内容主要包括了底层数据结构、散列冲突的解决、存储结构转换时为什么选择红黑树、从Object规范讨论HashMap关键码Key的选择、扩容机制。</p>
<p>因为1.8版本后，优化了散列函数和链表长度达到一定程度后的存储结构转换，这都是一些非常好的转换和优化思想，由于其涉及的内容也较多，认真研究和体会下来，比仅仅看看源码，所能学到的思想更加可贵。同时还能有效复习其涉及到的各种数据结构，可谓一举多得。</p>
<p>注：所引用代码均为JDK源码中部分，如需完整代码请移步JDK源码。</p>
<a id="more"></a>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>HashMap基于哈希表的 Map 接口的实现，是一种以 <k, v=""> 为存储结构的集合。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。由于其良好的存取性能，在我们平时的开发中被大量应用，但由于其非线程安全的缺点，如果在多线程的情况下还需要使用，我们可以自行控制同步，或者转用其线程安全版本：CurrentHashMap。</k,></p>
<h4 id="HashMap结构"><a href="#HashMap结构" class="headerlink" title="HashMap结构"></a>HashMap结构</h4><h5 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 默认初始化容量：容量必需为2的n次方</div><div class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</div><div class="line"></div><div class="line">// Map最大容量：2^30</div><div class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</div><div class="line"></div><div class="line">// 默认加载因子：容量使用达到总容量的75%后，Map扩容一倍</div><div class="line">static final <span class="built_in">float</span> DEFAULT_LOAD_FACTOR = 0.75f;</div><div class="line"></div><div class="line">// 链表存储结构准换为红黑树存储结构阀值</div><div class="line">static final int TREEIFY_THRESHOLD = 8;</div><div class="line"></div><div class="line">// 红黑树存储结构转换成链表存储结构的阈值</div><div class="line">static final int UNTREEIFY_THRESHOLD = 6;</div><div class="line"></div><div class="line">/** 当链表中节点被树化时，最小的<span class="built_in">hash</span>表容量：</div><div class="line"> *最少4 * TREEIFY_THRESHOLD，避免扩容树化冲突</div><div class="line"> */</div><div class="line">static final int MIN_TREEIFY_CAPACITY = 64;</div></pre></td></tr></table></figure>
<h5 id="成员变量定义"><a href="#成员变量定义" class="headerlink" title="成员变量定义"></a>成员变量定义</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 节点数组，第一次使用时被初始化</div><div class="line">transient Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line">// Map中所有Entry元素集合</div><div class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</div><div class="line"></div><div class="line">//  Map中&lt;K, V&gt;的数量 </div><div class="line">transient int size;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Map被结构性修改的次数</div><div class="line"> * 结构性修改：改变了HashMap中&lt;K, V&gt;的数量 或者 </div><div class="line"> * 改变其内部数据结构</div><div class="line"> */</div><div class="line">transient int modCount;</div><div class="line"></div><div class="line">// 扩容后，当再次需要扩容时的阀值：capacity * load factor</div><div class="line">int threshold;</div><div class="line"></div><div class="line">// 加载因子</div><div class="line">final <span class="built_in">float</span> loadFactor;</div></pre></td></tr></table></figure>
<h5 id="静态内部类Node"><a href="#静态内部类Node" class="headerlink" title="静态内部类Node"></a>静态内部类Node</h5><p>该节点类封装了每一个<k, v="">键值对</k,></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">        final int <span class="built_in">hash</span>;</div><div class="line">        final K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next;</div><div class="line"></div><div class="line">        Node(int <span class="built_in">hash</span>, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">            this.hash = <span class="built_in">hash</span>;</div><div class="line">            this.key = key;</div><div class="line">            this.value = value;</div><div class="line">            this.next = next;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="静态内部类TreeNode"><a href="#静态内部类TreeNode" class="headerlink" title="静态内部类TreeNode"></a>静态内部类TreeNode</h5><p>当链表进行存储结构转换时，每个节点都会被封装成TreeNode，即红黑树节点。该类继承自Node节点类。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</div><div class="line">        TreeNode&lt;K,V&gt; parent;  // red-black tree links</div><div class="line">        TreeNode&lt;K,V&gt; left;</div><div class="line">        TreeNode&lt;K,V&gt; right;</div><div class="line">        TreeNode&lt;K,V&gt;prev;  // needed to unlink next upon deletion</div><div class="line">        boolean red;</div><div class="line">        </div><div class="line">        TreeNode(int <span class="built_in">hash</span>, K key, V val, Node&lt;K,V&gt; next) &#123;</div><div class="line">            super(<span class="built_in">hash</span>, key, val, next);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 构造指定初始容量和加载因子Map</div><div class="line">public HashMap(int initialCapacity, <span class="built_in">float</span> loadFactor);</div><div class="line"></div><div class="line">// 构造指定初始容量Map，加载因子默认</div><div class="line">public HashMap(int initialCapacity);</div><div class="line"></div><div class="line">// 构造默认容量和加载因子Map</div><div class="line">public HashMap();</div><div class="line"></div><div class="line">// 构造给定Map映射关系的新Map，默认加载因子</div><div class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m);</div></pre></td></tr></table></figure>
<p>注：常用API此处不再给出，后面会讨论get 和 put方法，常用API很多也是建立在这两个方法基础之上的。</p>
<h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><h5 id="散列表-Has表"><a href="#散列表-Has表" class="headerlink" title="散列表(Has表)"></a>散列表(Has表)</h5><p>HashMap是基于哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>简单理解，就是一条存储记录的关键码Key通过散列函数计算得到一个值，我们可以通过该值极为快速的定位到该关键码Key所对应的值Value。由于其本身的快速定位特性，所以其存取get put操作都能在时间复杂度O(1)内完成。这应该是最美妙的。</p>
<p>但由于世界规律的存在：世界上没有一样东西是完美的。所以散列表也存在一些我们需解决的缺陷：散列冲突。我们在根据散列函数计算Key的Hash码时，并不能保证：</p>
<p>hash(key1) != hash(key2)</p>
<p>散列表的关键时散列函数，散列函数也有一个评判标准：越随机、越没规律，就越适合做散列函数。就我们平时常用的一些散列函数，如除余法、MAD法、折叠法、伪随机数法等，它们也并不能确保每个Key对应的Hash码唯一性。当存储数据时候，遇到两个或两个以上不同的Key拥有相同的Hash码的时候，此时我们就必须解决存储冲突的问题。常用的解决方案有如下三种(大学时所积累，有错请指正)：</p>
<p><strong>采用多槽位：</strong>将存放记录的数组的每个存储单元细分成若干个槽位，每个槽位存放一个冲突的记录。实际就是每个存储单元存放一个数组，如下图所示：</p>
<p><img src="/HashMap原理/多槽位方法.png" alt=""></p>
<p>缺点：由于数组在初始化时，我们必须指定其容量大小，但我们并不能预估每个存储单元会有多少个有可能冲突的词条记录。因此我们无法准确的预留槽位，即存放冲突记录的数组大小。</p>
<p><strong>采用独立链：</strong>存放记录的数组的每个存储单元存储记录的同时，也存储一个指针，该指针指向由该桶中冲突词条记录组织成的链表，如下图所示：</p>
<p><img src="/HashMap原理/独立链地址法.png" alt=""></p>
<p>缺点：指针本身也需要除数据记录本身以外的内存空间存储，且节点也需要动态申请，虽然所申请空间不用连续分配，但也导致其系统缓存几乎失效。</p>
<p><strong>采用开放地址：</strong> 此处列举出处理冲突的方法最简单的线性再散列法。插入元素时，如果发生冲突，算法会简单的从该槽位置向后循环遍历hash表，直到找到表中的下一个空槽，并将该元素放入该槽中（会导致相同hash值的元素挨在一起和其他hash值对应的槽被占用）。</p>
<p>查找元素时，首先散列值所指向的槽，如果没有找到匹配，则继续从该槽遍历hash表，直到：（1）找到相应的元素；（2）找到一个空槽，指示查找的元素不存在，（所以不能随便删除元素）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的），如下图所示：</p>
<p><img src="/HashMap原理/开放定址方法.png" alt=""></p>
<p>缺点：1、需处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。</p>
<p>2、按上述算法建立起来的哈希表，删除工作非常困难。如果将此元素删除，查找的时会发现空槽，则会认为要找的元素不存在。只能标上已被删除的标记，否则，将会影响以后的查找。</p>
<p>3、线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</p>
<p><strong>综上所述:</strong> 经过3种方案的比较，还是采用独立链地址方案解决冲突的三列表更适合用来作为实现HashMap的底层结构。事实上，HashMap编写者也是采用此种方案。</p>
<h5 id="HashMap散列函数"><a href="#HashMap散列函数" class="headerlink" title="HashMap散列函数"></a>HashMap散列函数</h5><p>根据上述散列表讲解可知，要存取一对键值映射对，第一步就是要算出其Hash码，用于其在散列数组中位置。由HashMap所采取的解决冲突方案可知，如果出现了冲突的数据，将会被存储到其对应的链表中。当我们在查询时候，就会被迫遍历整个链表来查询我们所需的数据，假设所有链表的平均长度为N，这每次查询的时间复杂度为O(N)。 </p>
<p>但是如果我们的散列函数设计得足够好：足够随机和极少冲突。则所有存储数据在散列数组中都会均匀分布，且每个数组存储单元也都只会存储一个数据，这样我们在取数据的时间复杂度还是O(1)。下面我们看看HashMap设计者是如何设计散列函数的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static final int <span class="built_in">hash</span>(Object key) &#123;</div><div class="line">        int h;</div><div class="line">        <span class="built_in">return</span> (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">// 获取对象<span class="built_in">hash</span>码(Object类中方法)</div><div class="line">public native int <span class="built_in">hash</span>Code();</div></pre></td></tr></table></figure>
<p>如源码中所示，首先根据Key获取其hashCode，再将hashCode无符号右移16，最后将两个值按位异或运算。就可得到其Key对应Hash码。对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用hash方法所计算得到的Hash码总是相同的。</p>
<p>得到Hash码后，我们就可继续进行下一步映射处理，在JDK源码中，它是这样处理的：<code>tab[(n - 1) &amp; hash]</code>n-1:散列数组长度减1，hash:Key对应Hash码。当我们存取数据的时候，都是通过该运算来确定散列数组下标。它通过<code>(n - 1) &amp; hash</code>来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，<code>(n - 1) &amp; hash</code>运算等价于对length取模，也就是hash% n，但是&amp;比%具有更高的效率。如下示例：</p>
<p><img src="/HashMap原理/hash算法.png" alt=""></p>
<h5 id="数组—链表"><a href="#数组—链表" class="headerlink" title="数组—链表"></a>数组—链表</h5><p>以上已提到，HashMap在实现中采用了独立链地址法来解决散列冲突。冲突数据都会被放入散列数组存储单元所对应的链表中，如下图所示：</p>
<p><img src="/HashMap原理/HashMap-链表.png" alt=""></p>
<p>上图中，似乎看起来一切都可以正常工作，不管我们存储还是读取一个键值对映射，首先定位到散列数组对应位置，再依次遍历对应链表，如果存储，则把对应节点添加到链表尾部，如果读取，则依次比较链表中每个节点Key和传入Key，匹配上则返回，否则则返回null。</p>
<p>但我们在上述讨论过，即使Hash算法设计的再合理，也避免不了多个不同的键值对定位到同一个散列数组位置。必然会出现链表过长的情况，一旦出现链表过长，每次存取时间复杂度都会是O(N),则会严重影响HashMap的性能。在Hash算法不能继续优化的情况下，我们只能从我们的存储结构去改变和优化。因此在JDK1.8版本中，当链表中键值对数量到达8以后，则会把链表转换成红黑树存储结构。</p>
<h5 id="数组—红黑树"><a href="#数组—红黑树" class="headerlink" title="数组—红黑树"></a>数组—红黑树</h5><p>链表长度到达阀值后，会进行存储结构的转换：链表转换成红黑树。如下图所示：</p>
<p><img src="/HashMap原理/HashMap-红黑树.png" alt=""></p>
<p>由于红黑树本身的特性，我们在读取键值对value的时候，时间复杂度也会由链表的O(N)降至O(logN)，但在添加键值对时候，我们为了保证红黑树的平衡和节点准则，我们就需要对红黑树进行zig-zig、zig-zag等旋转操作来保持红黑树平衡，同时还需要重着色节点。因此可能会比链表存储键值对有更多的消耗。</p>
<h5 id="WHY红黑树"><a href="#WHY红黑树" class="headerlink" title="WHY红黑树"></a>WHY红黑树</h5><p>至于为什么选用红黑树来作为转换后的存储结构，看起来如AVL树也符合，我想作者一定是有其原因的，下面我们就对AVL树、B树、红黑树进行比较来寻找答案(此处写这么多，其实也是本人想借机复习下，记性也是越来越不好)。</p>
<p><strong>AVL树：</strong>一种自平衡二叉查找树，因为其为查找树，因此其中序得到的序列是单调递增的。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O（log n）。增加和删除可能需要通过一次或多次树旋转来重新保持平衡。如下图所示(圈中为其平衡因子)：</p>
<p><img src="/HashMap原理/AVL.png" alt=""></p>
<p>查找：与BST(Binary Search Tree)一样，时间复杂度O(logN)</p>
<p>插入：先查找，在查找断点处插入，时间复杂度O(logN)。假设我们在此AVL树中插入值为4的节点，如图所示：</p>
<p><img src="/HashMap原理/AVL插入.png" alt=""></p>
<p>图中可以明显看出，该AVL树已失去平衡，有几个节点的平衡因子的绝对值已大于2.此时我们就需要对其进行选择操作来重新保持平衡。如下图所示：</p>
<p><img src="/HashMap原理/AVL插入平衡.png" alt=""></p>
<p>删除：先查找，找到对应节点后进行删除，时间复杂度O(logN)。假设上图中AVL树删除节点3，则需要再次进行平衡转换得到新的AVL树，如下图所示：</p>
<p><img src="/HashMap原理/AVL删除.png" alt=""></p>
<p>AVL缺点：删除一个节点的时候，最多一个节点失衡，即父亲节点；插入一个节点，最多logN个节点失衡，即所有祖先节点。所以在其插入中：1、引入了平衡因子，需改造元素结构；2、单次动态操作后，全树拓扑结构的变化量可能高达O(logN)。</p>
<p><strong>3+4重构：</strong>在上述AVL树旋转重保持平衡过程中，我忽略了旋转细节，其实本人也觉得挺麻烦的，此处推荐一种较为方便的重平衡方法：3+4重构。</p>
<p>3 :指的parent节点、grandParent节点、当前操作节点，重命名为a, b, c。且它们节点值大小顺序为：a &lt; b &lt; c .</p>
<p>4 :指的是3个节点所涉及到的4个子树，命名为T0， T1， T2， T3.且它们的大小顺序关系为：T0 &lt; T1 &lt; T2 &lt; T3 .</p>
<p>重构流程图如下：</p>
<p><img src="/HashMap原理/3加4重构.png" alt=""></p>
<p>以上述AVL树插入值为4的节点为例，具体流程可如下图所示：</p>
<p><img src="/HashMap原理/3加4重构示例.png" alt=""></p>
<p><strong>B-Tree：</strong>也属于一种搜索树，但是其每个树节点都是一个超级节点，每个超级节点有N个关键码，因此每个超级节点可向下延伸N + 1 个分支，分支的数量即为阶数。</p>
<p>特征：1、每个节点可有多个子树，拥有指向每个子树的指针。</p>
<p>2、所有叶子节点深度一样，叶子节点拥有指向null的指针。</p>
<p>3、形状更宽、更矮，俗话就是肥胖矮小。</p>
<p>M阶B树：又称【M／2, M】阶树，即每个节点的分支树为[M／2, M]，根节点可少于M／2。如下图所示(图片来自网络)：</p>
<p><img src="/HashMap原理/B-Tree.png" alt=""></p>
<p>查找：根超级节点 —&gt; 顺序查找 —&gt; 不命中 —&gt; 根据引用深入下一层，再重复查找即可：失败必止于外部节点，即null节点</p>
<p>插入：查找到对应位置 —&gt; 插入，出现上溢：插入节点后，阶数超过了B树的阶 —&gt; 分裂处理 —&gt; 若父超级节点也上溢 —&gt; 再分裂 ，有可能会一直分裂到根超级节点：导致B树增高的唯一情况，时间复杂度O(h)</p>
<p>删除：查找到对应节点 —&gt; 删除节点 —&gt; 若产生下溢(左顾右盼) —&gt; 旋转 —&gt; 左右兄弟不能满足旋转时，合并：导致B树降低的唯一情况，时间复杂度O(h)</p>
<p>特点：由于B树的每个节点都是一个由很多小节点组成的超级节点，相对于查找而言，相比于AVL树其实性能差不多。但由于其本身超级节点的特点，B树非常适合用做在磁盘中的存储结构，根节点常驻内存。当数据从磁盘载入内存时，能有效的减少I／O次数。I／O属于机械操作，其消耗是很巨大的。Mysql的MyISAM 和 Innodb 存储引擎的索引就应用了B加树作为其存储结构。</p>
<p><strong>红黑树：</strong>与AVL树相似，也是一种自平衡二叉查找树。但其有自己的特征：可做提升变换，即将红节点提升至与黑父节点平行，则成了一颗(2, 4)阶B树。</p>
<p>1、每个节点黑色，或者是红色，红节点不可相邻，黑节点可成父子关系。</p>
<p>2、根节点是黑色。</p>
<p>3、每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p>
<p>4、如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>5、从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>注意：</p>
<p>1、特性(3)中的叶子节点，是只为空(NIL或null)的节点。</p>
<p>2、特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<p><img src="/HashMap原理/红黑树.png" alt=""></p>
<p>查找：与普通BBST查找完全一样。</p>
<p>插入(只能插入红色节点)：我们在此处做了一个划繁为简的过程：将红黑树做提升变换成B树，再进行插入操作：1、若uncle为black，则做局部“3 + 4 重构” ， 再 b染黑，a或c染红；2、若uncle为red，则按照B树中修复上溢。最后变换为红黑树即可，时间复杂度O(logN)。</p>
<p>删除：提升变换 —&gt; 删除对应节点 —&gt;  再处理下溢 和 染色。最后变换为红黑树即可，时间复杂度O(logN)。</p>
<p>特性：任何一次动态操作(插入 和 删除), 可引发的结构变化量不致超过O(1)。</p>
<p><strong>总结：</strong>通过上述3种树的比较(因时间有限，B树和红黑树的插入与删除没有配图解读)，我们可以得出B树适合的场景是作为I／O操作的存储结构，AVL树是一种不错的搜索结构，但其相对于红黑树，删除操作可能导致全树拓扑结构的变化量可能高达O(logN)，缺少持久性。但HashMap的删除操作又是其一个重要特性，所以我们就选用了红黑树作为HashMap转换的存储结构。</p>
<h5 id="get-put操作流程"><a href="#get-put操作流程" class="headerlink" title="get put操作流程"></a>get put操作流程</h5><p>由于HashMap的许多API都是建立在get put操作基础上，所有我们此处就重点对get put操作进行讲解。</p>
<p><strong>get操作：</strong>操作流程图如下图所示：</p>
<p><img src="/HashMap原理/HashMap取数据.png" alt=""></p>
<p>JDK源码中实现如下所示：注释已写在代码中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * get操作实现</div><div class="line"> *</div><div class="line"> * @param <span class="built_in">hash</span> KeyHash码</div><div class="line"> * @param key 键值对Key</div><div class="line"> * @<span class="built_in">return</span> Node 查找数据节点</div><div class="line"> */</div><div class="line"> final Node&lt;K,V&gt; getNode(int <span class="built_in">hash</span>, Object key) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">            (first = tab[(n - 1) &amp; <span class="built_in">hash</span>]) != null) &#123;</div><div class="line">        // 最先比较散列数组位置节点</div><div class="line">        <span class="keyword">if</span> (first.hash == <span class="built_in">hash</span> &amp;&amp; // always check first node</div><div class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            <span class="built_in">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != null) &#123;</div><div class="line">            // 如果下一个节点是红黑树节点，则按红黑树查找</div><div class="line">            <span class="keyword">if</span> (first instanceof TreeNode)</div><div class="line">                <span class="built_in">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(<span class="built_in">hash</span>, key);</div><div class="line">            // 如果是链表，则遍历查找链表中所有节点</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == <span class="built_in">hash</span> &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="built_in">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>put操作：</strong>操作流程图如下图所示：</p>
<p><img src="/HashMap原理/HashMap存放数据.png" alt=""></p>
<p>JDK源码中实现如下所示：注释已写在代码中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * put操作实现</div><div class="line"> *</div><div class="line"> * @param <span class="built_in">hash</span> Key的Hash码</div><div class="line"> * @param key 键值对Key</div><div class="line"> * @param value 键值对value</div><div class="line"> * @param onlyIfAbsent 如果为<span class="literal">true</span>，则不改变已存在的键值对value </div><div class="line"> * @param evict 如果为<span class="literal">false</span>, 节点数组在创建状态  </div><div class="line"> * @<span class="built_in">return</span> 先前value, 如果不存在null</div><div class="line"> */</div><div class="line">final V putVal(int <span class="built_in">hash</span>, K key, V value, boolean onlyIfAbsent,</div><div class="line">                   boolean evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">    // 判断散列数组是否存在，不存在则创建resize</div><div class="line">    <span class="keyword">if</span> ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    // 散列数组对应位置是否存在节点，不存在则存放    </div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - 1) &amp; <span class="built_in">hash</span>]) == null)</div><div class="line">        tab[i] = newNode(<span class="built_in">hash</span>, key, value, null);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        // 比较第一个节点与传入键值对</div><div class="line">        <span class="keyword">if</span> (p.hash == <span class="built_in">hash</span> &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        // 判断第一个节点是否为红黑树节点    </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p instanceof TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, <span class="built_in">hash</span>, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            // 链表节点计数器，自旋循环</div><div class="line">            <span class="keyword">for</span> (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == null) &#123;</div><div class="line">                    // 添加到链表结尾</div><div class="line">                    p.next = newNode(<span class="built_in">hash</span>, key, value, null);</div><div class="line">                    // 如果链表长度大于等于7，则存储结构转换为红黑树</div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 <span class="keyword">for</span> 1st</div><div class="line">                        // 存储结构转红黑树</div><div class="line">                        treeifyB<span class="keyword">in</span>(tab, <span class="built_in">hash</span>);</div><div class="line">                    <span class="built_in">break</span>;</div><div class="line">                &#125;</div><div class="line">                // 如果Key已存在，则退出自旋循环</div><div class="line">                <span class="keyword">if</span> (e.hash == <span class="built_in">hash</span> &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="built_in">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 映射关系已存在，则替换旧值，返回旧值</div><div class="line">        <span class="keyword">if</span> (e != null) &#123; // existing mapping <span class="keyword">for</span> key</div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == null)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="built_in">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    // 查看是否达到扩阀值，如果达到则Map进行扩容</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="built_in">return</span> null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Key的选择"><a href="#Key的选择" class="headerlink" title="Key的选择"></a>Key的选择</h5><p>在get 与 put操作中，我们都必须用到了Key，说明Key在我们的存储体系中占据着很重要的地位。现在我们就如何最优的选择Key讨论。</p>
<p>注：以下内容总结来自《effective java》第9条：覆盖equals时总要覆盖hashCode。</p>
<p>我们在上述节点HashMap的散列算法的时候，通过关键码Key得到Hash码的时候，最主要的就是调用了对象Key的hashCode()。另外在get 和 put操作的时候，Key也发挥了关键作用：<code>if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</code> 。由此可见，就如何规范有效的选择Key严重HashMap性能和正确性。我们首先从Object规范说起。</p>
<p>1、在应用程序运行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</p>
<p>2、如果两个对象根据equals方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode都必须产生同样的整数结果。</p>
<p>3、如果两个对象根据equals方法比较起来是不想相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生不同的整数结果。</p>
<p>由规范2中可知，我们在每个覆盖了equals方法的类中，我们必须也要覆盖其hashCode。如果不这样，从而就会导致该类如法结合所有基于散列的集合一起正常运作，如HashMap、HashSet 和 HashTable。如下示例代码所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 重写equals不重写<span class="built_in">hash</span>Code方法测试</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-21</div><div class="line"> */</div><div class="line">publc final class PhoneNum &#123;</div><div class="line">    private final int areaCode;</div><div class="line">    private final int prefix;</div><div class="line">    private final int lineNum;</div><div class="line"></div><div class="line">    public PhoneNum(int areaCode, int prefix, int lineNum) &#123;</div><div class="line">    this. areaCode = areaCode;</div><div class="line">    this. prefix = prefix;</div><div class="line">    this. lineNum = lineNum;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public boolean equals(Object o) &#123;</div><div class="line">        <span class="keyword">if</span> (o == this) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!(o instance of PhoneNum)) &#123;</div><div class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        PhoneNum num = (PhoneNum)o;</div><div class="line">        <span class="built_in">return</span> num. areaCode == areaCode </div><div class="line">        &amp;&amp; num. prefix == prefix </div><div class="line">        &amp;&amp; num. lineNum == lineNum;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // Broken - no <span class="built_in">hash</span>Code method!</div><div class="line">    ... // Remainder omitted </div><div class="line">    </div><div class="line">    // main  方法中为测试</div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">    Map&lt;PhoneNum, String&gt; map = new HashMap();</div><div class="line">    map.put(new PhoneNum(300, 201, 450), <span class="string">"Glenn"</span>);</div><div class="line">    map.get(new PhoneNum(300, 201, 450));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码测试中，当我们期望获取的值“Glenn”，实际上返回的是null。我们在用这个这个关键码“==” “equals”时，可以正常应用，但由于这两个实例没有相等的散列码，违反了hashCode约定，所以这两个PhoneNum实例被映射到了不同的桶中。但即使这两个实例正好被映射到了同一个桶中，get方法也必定会返回null，因为HashMap有一项优化，可以将每个项相关的散列码缓存起来，如果散列码不匹配，也不必检查对象的等同性。如何重写hashCode请参考《effective java》第9条：覆盖equals时总要覆盖hashCode。</p>
<p>除了第2条，我们还需要注意第一条中的描述：只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</p>
<p>言外之意是什么：就是hashCode依赖于其对象内的成员变量字段信息，在应用程序应用过程中，对于同一个对象，我们可以不断的改变其对象的状态(成员变量字段重赋值)，多次在不同的阶段调用hashCode可能会返回不同Hash码，这对于HashMap而言，假设相同的Key每次得到不同的Hash码，简直就是灾难性的：每次都被映射到了不同的桶中。所以对于可变对象(我们可以在同一个对象中修改其状态)，我们是绝不能用于HashMap的关键码Key。</p>
<p><strong>总结：</strong>对于重写了equals方法的类，我们必须得重写其hashCode方法，对于可变类对象，我们不能将其作为HashMap的关键码Key，因为程序运行过程中其对象状态可改变，将会得到不同的Hash码，会造成读取数据错误(读取不到正确的信息)。所以在选择HashMap的关键码的时候，我们应该优先选择不可变类对象(运行期间对象状态不可改变，改变状态只能新开辟内存创建对象)，如String、Integer类对象都是很好的选择。</p>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>上面第2部分太多了，我都要写吐血了，终于来到第3部分：扩容机制。我终于要见到黎明的太阳了。泪奔了。</p>
<h5 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap扩容</h5><p>我们上面也提到了，当HashMap的容量使用率达到总容量 * 加载因子时，HashMap将会把容量扩容至现在的两倍。我们现在就讨论HashMap的扩容实现细节，源码如下所示(注释都在代码中)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 散列数组扩容至当前容量两倍，如果为null，则分配指定容量</div><div class="line"> * 内存新建数组，此外，因为我们使用了两倍扩容，对于HashMap中</div><div class="line"> * 的每一个元素它要么拥有相同的下标 或者 在新表中原位置移动了两倍的偏移量</div><div class="line"> * </div><div class="line"> * @<span class="built_in">return</span> the table</div><div class="line"> */</div><div class="line">final Node&lt;K,V&gt;[] <span class="function"><span class="title">resize</span></span>() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    // 旧散列表容量</div><div class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    // 旧表扩容阀值</div><div class="line">    int oldThr = threshold;</div><div class="line">    int newCap, newThr = 0;</div><div class="line">    // 旧散列表容量 &gt; 0</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; 0) &#123;</div><div class="line">        // 超过最大值就不再扩容</div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="built_in">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        // 扩容为原来的2倍还没超过最大值 且 旧表容量大于等于16就扩容两倍</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            // double threshold</div><div class="line">            newThr = oldThr &lt;&lt; 1; </div><div class="line">    &#125;</div><div class="line">    // initial capacity was placed <span class="keyword">in</span> threshold</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; 0) </div><div class="line">        newCap = oldThr;</div><div class="line">    // zero initial threshold signifies using defaults</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    // 新散列表长度为0</div><div class="line">    <span class="keyword">if</span> (newThr == 0) &#123;</div><div class="line">        // 计算新散列表扩容阀值</div><div class="line">        <span class="built_in">float</span> ft = (<span class="built_in">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="built_in">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                      (int)ft : Integer.MAX_VALUE);</div><div class="line">        &#125;</div><div class="line">    // 将新扩容阀值赋值threshold变量</div><div class="line">    threshold = newThr;</div><div class="line">    @SuppressWarnings(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        // 新建扩容后的散列数组</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">    // 将新建散列数组赋值table</div><div class="line">    table = newTab;</div><div class="line">    // 旧散列数组不为null，即存有键值对</div><div class="line">    <span class="keyword">if</span> (oldTab != null) &#123;</div><div class="line">        // 遍历旧散列数组</div><div class="line">        <span class="keyword">for</span> (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            // 如果散列数组对应元素不为null</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != null) &#123;</div><div class="line">                // 消除对原有链表或者红黑树的引用</div><div class="line">                oldTab[j] = null;</div><div class="line">                // 如果对应散列数组元素没有散列冲突</div><div class="line">                <span class="keyword">if</span> (e.next == null)</div><div class="line">                    // 对应元素重定位到新的散列数组中</div><div class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                // 对应元素是红黑树节点，则按红黑树方法处理</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</div><div class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div class="line">                // 该对应散列数组元素存在散列冲突</div><div class="line">                <span class="keyword">else</span> &#123; // preserve order</div><div class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    // 遍历链表处理节点，重构原链表</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        // 原散列数组中下标索引为0，则代表新散列数组中该元素的下标也为0</div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == null)</div><div class="line">                                // 链表头元素赋给loHead</div><div class="line">                                loHead = e;</div><div class="line">                            // 新散列数组中重构原链表</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            // 链表头元素处理完，loHead 和 loTail都指向了头元素</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == null)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != null);</div><div class="line">                    // 重构链表末尾元素不为null</div><div class="line">                    <span class="keyword">if</span> (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        // 新散列数组中索引不变指向链表</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        // 新散列数组中 原索引 + 原散列数组长度 指向链表</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">    <span class="built_in">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码就是JDK中扩容的实现细节，其中在文档中我们注意：the  elements from each bin must either stay at same index, or move with a power of two offset in the new table.该注释指对于HashMap中的每一个元素它要么拥有相同的下标 或者 在新表中原位置移动了两倍的偏移量。这句话我们有必要探究探究，扩容原理内容摘自<a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">美团点评技术团队</a>。</p>
<p>如下图所示：n为table的长度16，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="/HashMap原理/扩容1.png" alt=""></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="/HashMap原理/扩容3.png" alt=""></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="/HashMap原理/扩容4.png" alt=""></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket。这一块就是JDK1.8新增的优化点。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JDK1.8中对HashMap的优化主要包括了扩容后Hash码重定位 和 链表过长时存储结构转红黑树。从升级的角度来分析存取性能，如果在散列算法极为随机的情况下，会很少有链表过长引起存储结构转换，我猜测这时性能改变不大；但是如果散列算法设计得很不好，散列元素分布很不均匀，这时就很容易出现链表过长而进行存储结构的转换，在查询的时候性能应该会提升较多。</p>
<p>同时扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免Map进行频繁的扩容。</p>
]]></content>
      
        <categories>
            
            <category> JDK </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[反射机制原理]]></title>
      <url>https://glenen.github.io/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文会主要分为两个部分来详解：</p>
<p>1:反射的一些常用API，如何应用这些API获取我们在运行时所需的数据信息，即反射应用部分。</p>
<p>2:结合Class文件格式和其文件中的内容，及其类的加载过程，阐述反射机制的原理，即反射原理部分。</p>
<p>本文由本人结合所学总结，由于本人也才疏学浅，因此有可能会有些地方存在纰漏或者错误，敬请谅解，仅供参考。</p>
<a id="more"></a>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Java 反射机制是可以让我们在运行时获取类的方法、属性、父类、接口等 Class 内部信息的机制。通过反射还可以让我们在运行期实例化对象，调用方法，通过调用 get/set 方法获取变量的值，即使方法或属性是私有的的也可以通过反射的形式调用，这种“看透 Class”的能力被称为内省，这种能力在框架开发中尤为重要。就现在所有的java领域的框架，注解、动态代理、反射是其最根本。注解基于动态代理，动态代理底层还是通过反射机制“生长”其代理类的“血肉”。</p>
<h4 id="反射应用"><a href="#反射应用" class="headerlink" title="反射应用"></a>反射应用</h4><p>注：以下示例代码，均不完整。如有需要请移步JDK源码。</p>
<h5 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h5><p>Class对象是我们应用反射机制的入口，只要一个类被类加载器加载到虚拟机中的时候，在堆内存中都会相应的生成该类对应的Class对象。然后通过该对象，我们就可以获取我们运行时所需的数据。那么如何获取该对象？以下三种方式。</p>
<p>1:如果在编译期就能知道一个类的名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; instance = InstanceMain.class;</div></pre></td></tr></table></figure>
<p>2:已经得到该类的某个对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InstanceMain instanceMain = new InstanceMain(<span class="string">"Glenn"</span>);</div><div class="line">Class&lt;?&gt; instance = instanceMain.getClass();</div></pre></td></tr></table></figure>
<p>3：编译期获取不到目标类型，但知道其类全限定名，即类的完整路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; instance = Class.forName(<span class="string">"com.woodpecker.InstanceMain"</span>);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 编译路径下(classpath)找到对应的类，将会抛出ClassNotFoundException</div><div class="line"> *  </div><div class="line"> * @param className 类全限定名 </div><div class="line"> * @<span class="built_in">return</span> 带有指定名的该类对象</div><div class="line"> */ </div><div class="line"> public static Class&lt;?&gt; <span class="keyword">for</span>Name (String className);</div><div class="line"> </div><div class="line">/**</div><div class="line"> * 编译路径下(classpath)找到对应的类，将会抛出ClassNotFoundException</div><div class="line"> *  </div><div class="line"> * @param className 类全限定名</div><div class="line"> * @param shouldInitialize 是否初始化该Class对象</div><div class="line"> * @param classLoader 指定加载该类的ClassLoader</div><div class="line"> * @<span class="built_in">return</span> 带有指定名的该类对象</div><div class="line"> */ </div><div class="line">public static Class&lt;?&gt; <span class="keyword">for</span>Name (String className, boolean shouldInitialize, ClassLoader classLoader);</div></pre></td></tr></table></figure>
<h5 id="构造目标类型对象"><a href="#构造目标类型对象" class="headerlink" title="构造目标类型对象"></a>构造目标类型对象</h5><p>获取到该类的Class对象后，我们可以通过该对象获取对应类所有的内部信息，我们都将一步步讲解。首先我们来通过该Class对象构造目标类型对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 获取构造器Constructor对象</div><div class="line">Constructor&lt;?&gt; constructor = instance.getConstructor(String.class);</div><div class="line"></div><div class="line">constructor.setAccessible(<span class="literal">true</span>);</div><div class="line"></div><div class="line">// 构造目标类型对象：new关键字构造对象本质</div><div class="line">Object glenn = constructor.newInstance(<span class="string">"Glenn"</span>);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 获取一个公有的构造函数</div><div class="line"> *  </div><div class="line"> * @param parameterTypes 构造器参数对应类型</div><div class="line"> * @<span class="built_in">return</span> 对应构造器对象</div><div class="line"> */ </div><div class="line">public Constructor&lt;T&gt; getConstructor (Class...&lt;?&gt; parameterTypes);</div><div class="line"></div><div class="line">// 获取目标类所有的公有构造函数</div><div class="line">public Constructor[]&lt;?&gt; getConstructors ();</div></pre></td></tr></table></figure>
<p>注：当通过反射获取到 Constructor、Method、Field 后，在反射调用之前将此对象的 accessible 标志设置为 true，以此来提升反射速度。值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。</p>
<h5 id="获取类中方法"><a href="#获取类中方法" class="headerlink" title="获取类中方法"></a>获取类中方法</h5><p>通过Class对象，我们可以获取目标类型内部中所有的方法，包括当前类中的所有方法，及当前类和父类中定义的公有方法。具体API细节可查阅JDK源码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 获取当前类中所有方法</div><div class="line">Method[] methods = instance.getDeclaredMethods();</div><div class="line"></div><div class="line">// 获取当前类和父类中定义的公有方法</div><div class="line">Method[] methods = instance.getMethods();</div><div class="line"></div><div class="line">// 获取当前类中指定方法</div><div class="line">Method showMethod = instance.getDeclaredMethod(<span class="string">"show"</span>, String.class);</div><div class="line"></div><div class="line">// 通过 getMethod 只能获取公有方法，如果获取私有方法则会抛出异常</div><div class="line">Method hideMethod = instance.getMethod(<span class="string">"hide"</span>, String.class);</div><div class="line"></div><div class="line">// 获取方法的参数类型列表</div><div class="line">Class&lt;?&gt;[] argClasses = showMethod.getParameterTypes() ;</div><div class="line"></div><div class="line">// 获取指定方法的权限修饰符</div><div class="line">boolean <span class="built_in">type</span> = Modifier.isPrivate(showMethod.getModifiers());</div><div class="line"></div><div class="line">// 执行指定方法</div><div class="line">showMethod.invoke(instanceMain, <span class="string">"Glenn"</span>);</div></pre></td></tr></table></figure>
<h5 id="获取类中属性"><a href="#获取类中属性" class="headerlink" title="获取类中属性"></a>获取类中属性</h5><p>通过Class对象，我们可以获取目标类型内部中所有的属性，包括当前类中的所有属性，及当前类和父类中定义的公有属性。具体API细节可查阅JDK源码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/ 获取当前类中所有属性</div><div class="line">Field[] fields = instance.getDeclaredFields();</div><div class="line"></div><div class="line">// 获取当前类和父类中定义的公有属性</div><div class="line">Field[] fields = instance.getFields();</div><div class="line"></div><div class="line">// 获取当前类某个指定属性</div><div class="line">Field idField = instance.getDeclaredField(<span class="string">"id"</span>);</div><div class="line"></div><div class="line">// 获取当前类和父类的某个公有属性</div><div class="line">Field nameField = instance.getField(<span class="string">"name"</span>);</div><div class="line"></div><div class="line">// 获取属性值</div><div class="line">int id = idField.getInt(instanceMain);</div><div class="line"></div><div class="line">// 设置属性值</div><div class="line">idField.set(instanceMain, 10);</div></pre></td></tr></table></figure>
<h5 id="获取父类及接口"><a href="#获取父类及接口" class="headerlink" title="获取父类及接口"></a>获取父类及接口</h5><p>通过Class对象，我们可以获取目标类型的父类，及当前类所有所实现的接口。具体API细节可查阅JDK源码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 获取当前类父类</div><div class="line">Class&lt;?&gt; superClass = instance.getSuperclass();</div><div class="line"></div><div class="line">// 再获取父类的上一层父类，直到最后的 Object 类，Object 的父类为 null</div><div class="line"><span class="keyword">while</span> (superClass != null) &#123;</div><div class="line">    superClass = superClass.getSuperclass();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取当前类实现的接口列表</div><div class="line">Class&lt;?&gt;[] interfaceses = instance.getInterfaces();</div></pre></td></tr></table></figure>
<h5 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h5><p>通过Class对象，我们可以获取目标类型的使用注解，获取到<br>Constructor、Method、Field 后，我们可以获取其对应的使用注解。具体API细节可查阅JDK源码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 获取指定类型注解</div><div class="line">Builder builderAnno = instance.getAnnotation(Builder.class);</div><div class="line"></div><div class="line">// 获取属性上的指定注解(方法等也类似)</div><div class="line">Getter getter = idField.getAnnotation(Getter.class);</div><div class="line"></div><div class="line">// 获取当前类上所有注解</div><div class="line">Annotation[] annos = instance.getAnnotations();</div></pre></td></tr></table></figure>
<h4 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h4><p>我们可能会好奇，为什么我们通过以上JDK提供的API就能在运行时获取到我们想要的数据信息。其实这都和class类文件及class类文件加载到虚拟机中过程有关。接下来我们就从class类文件 和 类文件的加载过程分析。</p>
<p>注：以下只是大致的讲解，如需了解更详细内容，请关注JVM原理分类中的博文(以后有时间就会贴上去)。</p>
<h5 id="class类文件"><a href="#class类文件" class="headerlink" title="class类文件"></a>class类文件</h5><p>任何一个class文件都对应着唯一一个类或者接口的定义信息，但反之类或者接口并不一定都得定义在文件里，比如类或接口也可以直接通过类加载器直接生成。</p>
<p>class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中，中间没有添加任何分隔符，这使的整个class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。如遇到需占用8位字节以上的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。采用无符号数和表两种数据类型的伪结构来存储数据。其所有细节都被严格限定，不允许改变。大致如下图所示：</p>
<p><img src="/反射机制原理/class文件.png" alt=""></p>
<p>如图所示，就是一个class文件大致格式，此处我们不关注详细信息。只关注 类索引、父类索引、接口索引集合 和 字段表集合 方法表集合。因为我们今天的主题是讲解与反射相关的内容。</p>
<p>class文件中由 类索引、父类索引、接口索引集合 来确定这个类等继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。除Object外，所有java类的父类索引都不为0。接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句后的接口顺序从左到右排列在接口索引集合中。</p>
<p>字段表集合用于描述接口或者类中声明的变量。包括类级变量及实例变量，不包括方法内部声明的局部变量。字段的修饰符都是布尔值，要么有要么没有，很适合用标识位来表示，而字段叫什么名字、数据类型都是无法固定的，只能引用常量池中的常量来描述。方法表集合与class文件对字段的描述方式几乎采用了完全一致的方式。</p>
<p>class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法被虚拟机使用。</p>
<p>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。所以就是为什么我们只能在运行期获取到当前各种类型的数据信息了。</p>
<h5 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h5><p>何为类加载：虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的java类型。</p>
<p>类的加载过程分为加载、验证、准备、解析、初始化、使用、卸载阶段，此处我们只关注加载和初始化阶段，因为它们和我们的反射最息息相关。</p>
<p>加载阶段有个很重要重点必须提出：在加载阶段虚拟机必须完成的事包括在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。所以我们对当前类的各种操作都是基于该Class对象，比如用new关键字创建一个对象等等。每一个被加载到虚拟机中的类，都对应了一个Class对象。</p>
<p>初始化：真正开始执行类中定义的java程序代码，是执行类构造器<clinit>()方法的过程。</clinit></p>
<p>在虚拟机规范中，规定了有且只有五种情况下立即进行类初始化，其中就包括使用java.lang.reflect包的方法对类进行反射调用的时候 和 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>因此就是当我们应用反射的时候，该类和其父类必然已经初始化完毕可以供我们使用，通过每个类对应的Class对象访问入口，结合前面讲解的class文件结构，在运行时获取当前类的所有属性、方法等等就是很容易的事情了。获取其父类的属性方法当然也可行了。因为父类的Class对象访问入口必然已先与当前类存在。虚拟机如何实现这些访问细节就不得而知了。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JDK </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[一致性Hash算法]]></title>
      <url>https://glenen.github.io/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>本文所整理的一致性Hash算法，其原型和背景都离不开现代大型网站设计服务端的一个重要特性：伸缩性。</p>
<p>所谓网站的伸缩性，就是指在不需要改变网站的软硬件设计的前提下，仅仅通过改变部署的集群中的服务器数量就可以缩小或扩大网站的服务处理能力。一般而言，网站的伸缩性设计可分两类：1、根据功能进行物理分离实现伸缩；2、单一功能通过集群实现伸缩。前者是不同的服务器部署不同的服务，提供不同功能，后者是集群中的多台服务器部署相同的服务，提供相同的功能。通过对这两个方面的研究和处理，我们就可对网站整体实现富有弹性的伸缩性设计。</p>
<a id="more"></a>
<p>其实不管哪种伸缩类型，其都是一个网站在从建立到后面越来越庞大的过程中催生出的产物，如下图所示：</p>
<p><img src="/一致性Hash算法/物理分离实现服务器伸缩.png" alt=""></p>
<p>就揭示了网站在发展过程，我们为了应对服务器本身的处理能力瓶颈所采取的手段：将各种可单独分离的功能模块一步一步分离出来单独部署。但是随着网站的访问流量越来越大，单独部署功能模块的服务器有可能会出现负载过大而宕机的情况，其实也是必然会发生的，这时我们可能会采取的措施换一台处理能力更强的服务器，或者多添加一台服务器协同原服务器处理。我们都会选择后者处理方法，因为前者不能从根本解决问题：世界上不存在一台拥有无限处理能力的计算机。</p>
<p>集群的伸缩性设计，也可分为多种：1、应用服务器集群的伸缩设计；2、分布式缓存集群的伸缩设计；3、数据存储服务器的伸缩设计。每种伸缩设计采用的方式也不同，都需要根据其特点制定相应的可伸缩设计。本文所讲解的一致性Hash算法就是为了解决分布式缓存集群的伸缩设计。可能会有漏点，仅供参考。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="一般路由算法隐患"><a href="#一般路由算法隐患" class="headerlink" title="一般路由算法隐患"></a>一般路由算法隐患</h5><p>何为路由：简单理解就是我们通过缓存数据的Key，通过某种路由算法，计算得到存储数据服务器列表的下标，从而完成缓存数据Key到存储数据服务器的映射(自己理解，如有错误请谅解)。</p>
<p>其实就路由算法而言，以前大学时代数据结构课程就提及过较多：其通过路由算法得到的值越随机，越具有不可预测性，其就越适合作为Hash算法。一般简单的路由算法可以使用余数Hash：缓存数据Key除以服务器数量取余，该余数就是存放缓存数据的服务器编号。实际上，如果不考虑缓存服务器集群的伸缩性，余数Hash可以满足绝大多数的缓存路由需求。但是当缓存服务器集群需要扩容的时候，其弊端就会完全暴露出来。</p>
<p>如下列子：</p>
<p>现在我们需要将3台缓存服务器扩容至4台，扩容的服务器列表已改变，但是我们的路由算法仍然使用余数Hash，我们原来已存在的缓存数据<key, data="">，其key的Hash值为490806430，除以4余数为2，对应的服务器编号为2，我们去该服务器读取缓存数据，其结果也可想而知：必然失败。因为在集群为3台时，该缓存数据存储的服务器编号为1。</key,></p>
<p>很容易可看出，集群服务器数从3增至4时，大约会有75%(3/4)被缓存了的数据不能正确命中。且随着集群服务器规模的不断扩大，其不命中率会成线性上升：(N/(N + 1))。</p>
<p>当缓存数据绝大部份不能正确命中时候，就会从数据库获取数据，此时数据访问的压力就会落到数据库上，这导致超过数据库的负载能力，严重时可能会导致数据库宕机。这显然不是我们所能接受的：我们使用缓存的初衷是降低数据库的负载压力。</p>
<p>一种办法可以在网站访问量最少的时候扩容缓存服务器集群(哈哈，没错就是半夜)，然后通过模拟请求的方法逐渐预热缓存，使缓存服务器中的数据重新分配。但我们可以有更好的办法：那就是改进路由算法，使新加入的服务器不影响大部分缓存数据的命中。其就是今天的重点：一致性Hash算法。</p>
<h5 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h5><p>一致性Hash算法通过一个叫做一致性Hash环的数据结构实现Key到缓存服务器的映射。如下图所示：</p>
<p><img src="/一致性Hash算法/一致性Hash算法.png" alt=""></p>
<p>其具体算法过程：先构造一个长度为2^32的一致性Hash环，然后根据缓存服务器的放置在这个Hash环上。当需要根据缓存数据的Key值计算得到其Hash值，然后在Hash环上顺时针查找距离这个Key的Hash值最近的缓存服务器节点，其缓存数据就存在该服务器上，从而完成Key到服务器的Hash映射查找。</p>
<h4 id="添加服务器"><a href="#添加服务器" class="headerlink" title="添加服务器"></a>添加服务器</h4><h5 id="添加服务器处理"><a href="#添加服务器处理" class="headerlink" title="添加服务器处理"></a>添加服务器处理</h5><p>当缓存服务器集群需要扩容时候，只需要新加入的节点(Node4)的Hash值放入一致性Hash环中。因为Key是顺时针查找距离其最近的节点，所以新加入的服务器只会影响整个环中的一小段。如下图所示：key3 和 key5受影响。</p>
<p><img src="/一致性Hash算法/一致性Hash算法2.png" alt=""></p>
<p>图中key3 和 key5从原来的Node1重新计算到了Node4，但是原来的大部分缓存数据还是能正确命中。假设还是将集群服务器从3扩容至4台，原有缓存数据的命中概率大约有75%，远远高于余数Hash的25%，且随着集群规模的增大，原有缓存数据的命中率还会继续增加。虽然还是会有小部分数据不能正确命中，但因为这个比例足够小，所以当从数据库读取这些数据的时候也不会对数据库造成难以承受的负载压力。</p>
<h5 id="Hash环实现"><a href="#Hash环实现" class="headerlink" title="Hash环实现"></a>Hash环实现</h5><p>在我们的实际应用中，这个长度为2^32的一致性Hash环通常使用二叉查找树实现，Hash查找的实际过程是在二叉树中查找不小于查找数的最小值：服务器编号。当然这个二叉树最右边的叶子节点(最大值) 和 最左边的叶子节点(最小值)相连接，就构成了环。</p>
<h4 id="解决负载不均衡"><a href="#解决负载不均衡" class="headerlink" title="解决负载不均衡"></a>解决负载不均衡</h4><h5 id="一致性Hash算法隐患"><a href="#一致性Hash算法隐患" class="headerlink" title="一致性Hash算法隐患"></a>一致性Hash算法隐患</h5><p>如上增加服务器节点图所示：新加入的Node4只影响了原来的节点Node1，也就是说原来需要访问Node1的缓存数据现在被转移到了Node4(大约50%)。原来命中到Node2 和 Node3的缓存数据不受影响，此时就意味着Node2 和 Node3的缓存数据和访问压力是Node1 和 Node4的两倍。如果这4台机器的性能是一样的，那此种结果显然也不是我们所需要的。</p>
<h5 id="增加虚拟层"><a href="#增加虚拟层" class="headerlink" title="增加虚拟层"></a>增加虚拟层</h5><p>为了解决一致性Hash算法所带来的负载不均衡问题，我们通过使用虚拟层的手段：将每台缓存服务器虚拟为一组虚拟的缓存服务器，将虚拟服务器的Hash值放到Hash环上，Key先在环上找到虚拟服务器节点，再得到物理服务器信息。</p>
<p>其实添加虚拟层的方式在计算机领域中被广泛采用：1、计算机网络七层协议；2、计算机操作系统可看作计算机硬件的虚拟层；3、java虚拟机可看作操作系统的虚拟层等等。</p>
<p>这样新加入物理服务器节点时，将会把一组虚拟机节点加入环中。如果虚拟节点的数目足够多，这组虚拟节点将会影响同样多数目的已经在环上的虚拟节点，由于这些已存在的虚拟节点又对应不同的物理服务器。最终结果：新加入一台缓存服务器，将会较为均匀地影响原来集群中已经存在的所有服务器，换而言之就是分摊原有缓存服务器集群中所有服务器的一小部分负载。把新加入节点所造成的影响分摊给所有原有的服务器。如下图所示：</p>
<p><img src="/一致性Hash算法/虚拟节点的一致性Hash环.png" alt=""></p>
<p>图中新加入的Node4节点对应虚拟节点 n30  n31  n32，加入到一致性Hash环上后，影响 n01 、n12 、n22 三个虚拟节点，而这3个虚拟节点分别对应物理节点 Node1 、 Node2 、 Node3 。最终集群中加入一个节点，同时影响到了集群中已存在的三个物理节点。理想情况下，每个节点中不能被命中的数据为其缓存数据量的1/4 (N/(N + X)，N为原有物理节点数，X为新加入物理节点数)。即集群中已经被缓存数据有75%可被继续命中，和未使用虚拟节点的一致性Hash算法结果相同。</p>
<p>显然每个物理节点对应的虚拟节点越多，各个物理节点之间的负载越均衡，新加入的服务器对集群中已存在的服务器的影响越保持一致(也是一致性Hash这个名字的由来)。实践中，一台物理服务器对应多少个虚拟节点合适，太多会影响性能，太少会影响负载均衡。一般来说，根据大师们的经验值：150。 当然这个值还应该根据具体情况具体对待。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[java线程与内存模型]]></title>
      <url>https://glenen.github.io/java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>文中所涉及内容均为java虚拟机相关，但由于java虚拟机团队也一直在改进和优化java虚拟机，其中有的内容可能会与后续版本有差异，所以文中内容仅提供参考，不可作为任何定义为任何标准的准则，敬请谅解。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分主要讲述java线程的底层实现，与系统级的线程的关系；还阐述了java线程的调度机制，以及java线程的五种状态的意义和相互转换。还特别对volatile关键字进行了详细的分析，以及java程序在执行过程中一些默认的先行发生原则来保障java程序执行的有序性。</p>
<a id="more"></a>
<h4 id="java与线程"><a href="#java与线程" class="headerlink" title="java与线程"></a>java与线程</h4><h5 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h5><p>使用内核线程(Kernel-Level Thread klt)实现—程序一般不直接使用内核线程，而是去使用内核线程的一种高级接口：轻量级进程(Light Weight Process  LWP)。轻量级进程和内核线程之间是1:1的关系。如下图所示：</p>
<p><img src="/java线程与内存模型/轻量级进程.png" alt=""></p>
<h5 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h5><p>狭义-完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。所有线程操作都需要用户程序自己处理。进程和用户线程之间是1:N的关系，如下图所示：</p>
<p><img src="/java线程与内存模型/用户线程.png" alt=""></p>
<h5 id="用户线程加轻量级进程混合实现"><a href="#用户线程加轻量级进程混合实现" class="headerlink" title="用户线程加轻量级进程混合实现"></a>用户线程加轻量级进程混合实现</h5><p>使用了用户线程加轻量级进程的混合实现，且用户线程和轻量级进程之间是N:M的关系，如下图所示：</p>
<p><img src="/java线程与内存模型/混合线程.png" alt=""></p>
<h4 id="java线程调度及状态"><a href="#java线程调度及状态" class="headerlink" title="java线程调度及状态"></a>java线程调度及状态</h4><h5 id="java线程调度"><a href="#java线程调度" class="headerlink" title="java线程调度"></a>java线程调度</h5><p>系统调度指系统为线程分配处理器使用权的过程。</p>
<p>协同式线程调度：线程的执行时间由线程本身控制，线程把自己工作做完后主动通知系统切换到另一个线程，简单而容易阻塞死。</p>
<p>抢占式线程调度：每个线程由系统分配时间，线程的切换不由线程本身决定，时间系统可控，不会阻塞，java  使用的调度方式。</p>
<h5 id="java线程状态"><a href="#java线程状态" class="headerlink" title="java线程状态"></a>java线程状态</h5><p>线程状态：新建：创建后尚未启动；</p>
<p>运行：可能正执行，或等待CPU分配时间；</p>
<p>无限期等待：不会被CPU分配执行时间，需等待被其他线程显式唤醒；</p>
<p>限期等待：不会被CPU分配执行时间，在一段时间后由系统自动唤醒；</p>
<p>阻塞：等待着获取到一个拍他锁，该事件将由另一个线程放弃这个锁时发生；</p>
<p>结束：已终止线程状态，线程已执行结束。</p>
<p>java线程之间的状态转换大致可如下图所示：</p>
<p><img src="/java线程与内存模型/线程状态转换关系.png" alt=""></p>
<h4 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h4><p>JMM，屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各个平台下都能达到一致的内存访问效果。</p>
<p>目标：定义程序中各个变量(与java编程中所说不同，包括实例字段、静态字段和构成数组对象的元素，不包括局部变量和方法参数，因为其为线程私有)的访问规则，即在虚拟机中将变量存储到内存和从内存取出变量这样的底层细节。</p>
<p>java内存模型规定所有的变量都存储在主内存中，每个线程还有自己的工作内存，其中保存了被该线程使用到变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。线程间变量值的传递均需要通过主内存来完成。如下图所示：</p>
<p><img src="/java线程与内存模型/线程-主内存-工作内存的交互关系.png" alt=""></p>
<p>但此外还需注意：1、如果局部变量是一个reference类型，它的引用在java堆中可被各个线程共享。但reference本身在java栈中的局部变量表中，且是线程私有的。</p>
<p>2、对拷贝副本：假设线程中访问一个10MB的对象，并不会把整个对象都拷贝一份，这个对象的引用、对象中某个线程访问到的字段是有可能存在拷贝的，相当于只拷贝自己没有的。但不会有虚拟机实现成把整个对象都拷贝一次。</p>
<p>3、volatile变量依然有工作内存的拷贝，但由于它特殊的操作顺序规定，所以如同直接在主内存中读写访问一般，所以上面的描述对volatile并不例外。</p>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><h5 id="volatile的两个重要特性"><a href="#volatile的两个重要特性" class="headerlink" title="volatile的两个重要特性"></a>volatile的两个重要特性</h5><p>1、保证此变量对所有线程的可见性，即一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</p>
<p>2、禁止指令重排序优化，普通的变量仅仅会保证在该方法等执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值的操作顺序与程序代码中的执行顺序一致。重排序优化是机器级的优化操作，提前执行指对应的汇编代码被提前执行。</p>
<h5 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h5><p><strong><em>指令重排序</em></strong>：硬件架构而言，指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理，但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。</p>
<p>所以在本CPU中，重排序依然看起来是有序的，一个<code>lock addl…..</code>将修改同步到内存时，意味着所有之前的操作都已执行完成，这样便形成了指令重排序无法越过内存屏障的效果。</p>
<p><strong><em>volatile如何禁止指令重排序优化</em></strong>：通过双检测获取单例模式例子的汇编代码可知，变量赋值后多执行了一个<code>lock addl…..</code>操作，该操作相当于一个内存屏障，即重排序时不能把后面的指令重排序到内存屏障之前的位置，只有一个CPU时，并不需要内存屏障，但如果有两个或者更多CPU访问统一内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性。</p>
<p><code>lock addl.....</code>是一个空操作，关键是lock前缀，它的作用是使的本CPU的Cache写入了内存，该写入操作也会引起别的CPU或者别的内核无效化其Cache，这种操作相当于对Cache中的变量做了一次前面介绍java内存模型中所说的store和write操作。因此通过该空操作，可让前面volatile变量的修改对其他CPU立即可见。</p>
<p>volatile自己与自己比较，确定一个原则：volatile变量读操作的性能消耗与普通变量变量几乎没有什么差别，但是写操作则可能会慢一些，因为在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，但大多数情况下volatile的总开销仍然要比锁低。</p>
<p>但以下代码是本人自己使用volatile关键字的测试码，编译后并没有看到<code>lock addl.....</code>操作呢，我懵逼了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package com.woodpecker.jvm;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Thread 测试</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2017-03-14</div><div class="line"> */</div><div class="line">public class SyncThreadTest &#123;</div><div class="line"></div><div class="line">    private static volatile boolean isStop;</div><div class="line">    private static int count = 0;</div><div class="line"></div><div class="line">    public static void main(String args[]) throws InterruptedException &#123;</div><div class="line">        Thread holdThread = new Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">while</span> (!isStop) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        holdThread.start();</div><div class="line">        Thread.sleep(300);</div><div class="line">        //TimeUnit.SECONDS.sleep(3);</div><div class="line">        isStop = <span class="literal">true</span>;</div><div class="line">        System.out.println(count);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出结果(每次输出结果不同)：</div><div class="line">164299397</div></pre></td></tr></table></figure>
<p>编译后，生成的字节码序列如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class com.woodpecker.jvm.SyncThreadTest &#123;</div><div class="line">  public com.woodpecker.jvm.SyncThreadTest();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial <span class="comment">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></div><div class="line">       4: <span class="built_in">return</span></div><div class="line"></div><div class="line">  public static void main(java.lang.String[]) throws java.lang.InterruptedException;</div><div class="line">    Code:</div><div class="line">       0: new           <span class="comment">#2                  // class java/lang/Thread</span></div><div class="line">       3: dup</div><div class="line">       4: invokedynamic <span class="comment">#3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></div><div class="line">       9: invokespecial <span class="comment">#4                  // Method java/lang/Thread."&lt;init&gt;":(Ljava/lang/Runnable;)V</span></div><div class="line">      12: astore_1</div><div class="line">      13: aload_1</div><div class="line">      14: invokevirtual <span class="comment">#5                  // Method java/lang/Thread.start:()V</span></div><div class="line">      17: ldc2_w        <span class="comment">#6                  // long 300l</span></div><div class="line">      20: invokestatic  <span class="comment">#8                  // Method java/lang/Thread.sleep:(J)V</span></div><div class="line">      23: iconst_1</div><div class="line">      24: putstatic     <span class="comment">#9                  // Field isStop:Z</span></div><div class="line">      27: getstatic     <span class="comment">#10                 // Field java/lang/System.out:Ljava/io/PrintStream;</span></div><div class="line">      30: getstatic     <span class="comment">#11                 // Field count:I</span></div><div class="line">      33: invokevirtual <span class="comment">#12                 // Method java/io/PrintStream.println:(I)V</span></div><div class="line">      36: <span class="built_in">return</span></div><div class="line"></div><div class="line">  static &#123;&#125;;</div><div class="line">    Code:</div><div class="line">       0: iconst_0</div><div class="line">       1: putstatic     <span class="comment">#11                 // Field count:I</span></div><div class="line">       4: <span class="built_in">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="long和double变量特殊规则"><a href="#long和double变量特殊规则" class="headerlink" title="long和double变量特殊规则"></a>long和double变量特殊规则</h4><p>java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据类型long和double，在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现可以不保证64位数据类型的read、load、store、和write这4个操作具有原子性。</p>
<p>但在实际操作中，目前各种平台下的商用java虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此编写代码时不需要将其专门声明为volatile。</p>
<p><strong><em>注意</em></strong>：synchronized块之间的操作也具有原子性。volatile、synchronized、final也具有可见性。</p>
<p>有序性总结：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。volatile、synchronized两个关键字保证线程之间操作的有序性。</p>
<h4 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h4><p>只是根据一些关键字，java并不能保证程序在执行过程中的有序性，程序执行的有序性还需要一些java虚拟机规范的一些原则来协同。</p>
<p>java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生与操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>java内存模型中有一些天然的先行发生关系：<br>程序次序规则：一个线程内，按照程序代码顺序。</p>
<p>管程锁定规则：一个unlock操作先发生于后面对同一个锁的lock操作。</p>
<p>volatile变量规则：写操作先行发生于后面对这个变量的读操作。</p>
<p>线程启动规则：start方法先行发生于此线程的每一个动作。</p>
<p>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检。</p>
<p>对象终结规则：一个对象初始化完成先行发生于它的finalize方法。</p>
<p>传递性：如果A操作先行发生于操作B，操作B先行发生于操作C，则操作A先行发生于操作C。</p>
<p>结论：一个操作时间上的先发生不代表这个操作会是先行发生，如果一个操作先行发生，也不能代表这个操作必定是时间上先发生。例子是指令重排序。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql索引及算法原理]]></title>
      <url>https://glenen.github.io/Mysql%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p>
<p>文章主要内容分为两个部分。</p>
<a id="more"></a>
<p>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</p>
<p>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</p>
<h4 id="数据结构及算法原理"><a href="#数据结构及算法原理" class="headerlink" title="数据结构及算法原理"></a>数据结构及算法原理</h4><h5 id="索引本质"><a href="#索引本质" class="headerlink" title="索引本质"></a>索引本质</h5><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。</p>
<p>如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。如下图所示：</p>
<p><img src="/Mysql索引及算法原理/timg-0.png" alt=""></p>
<p>该图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)O(log2n)的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p>
<h4 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h4><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<p>d为大于1的一个正整数，称为B-Tree的度。</p>
<p>h为一个正整数，称为B-Tree的高度。</p>
<p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p>
<p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p>
<p>所有叶节点具有相同的深度，等于树高h。</p>
<p>key和指针互相间隔，节点两端是指针。</p>
<p>一个节点中的key从左到右非递减排列。</p>
<p>所有节点组成树结构。</p>
<p>每个指针要么为null，要么指向另外一个节点。</p>
<p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)v(key1)，其中v(key1)v(key1)为node的第一个key的值。</p>
<p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</p>
<p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。下图是一个d=2的B-Tree示意图：</p>
<p><img src="/Mysql索引及算法原理/timg-1.png" alt=""></p>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">BTree_Search(node, key) &#123;</div><div class="line">if(node == null) return null;</div><div class="line">foreach(node.key)</div><div class="line">&#123;</div><div class="line">if(node.key[i] == key) return node.data[i];</div><div class="line">if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node);</div><div class="line">&#125;</div><div class="line">return BTree_Search(point[i+1]-&gt;node);</div><div class="line">&#125;</div><div class="line">data = BTree_Search(root, my_key);</div></pre></td></tr></table></figure>
<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。</p>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<p>每个节点的指针上限为2d而不是2d+1。</p>
<p>内节点不存储data，只存储key；叶子节点不存储指针。</p>
<p>下图是一个简单的B+Tree示意：</p>
<p><img src="/Mysql索引及算法原理/timg-2.png" alt=""></p>
<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p>
<p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p>
<h5 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h5><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。如图所示：</p>
<p><img src="/Mysql索引及算法原理/timg-3.png" alt=""></p>
<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<h4 id="为什么使用B-Tree-和-B-Tree"><a href="#为什么使用B-Tree-和-B-Tree" class="headerlink" title="为什么使用B-Tree 和 B+Tree"></a>为什么使用B-Tree 和 B+Tree</h4><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<h5 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h5><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。如图所示：</p>
<p><img src="/Mysql索引及算法原理/timg-4.png" alt=""></p>
<p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p>
<p>主存的存取过程如下：</p>
<p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p>
<p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h5 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h5><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。下图展示了磁盘的整体结构：</p>
<p><img src="/Mysql索引及算法原理/timg-5.png" alt=""></p>
<p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。下图展示了一个磁盘的结构：</p>
<p><img src="/Mysql索引及算法原理/timg-6.png" alt=""></p>
<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<h5 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h5><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p>程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h5 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h5><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<p>Dmax=floor(pagesize/(keysize + datasize + pointsize))</p>
<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p>
<h4 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h4><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p>
<h5 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h5><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p>
<p><img src="/Mysql索引及算法原理/timg-7.png" alt=""></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="/Mysql索引及算法原理/timg-8.png" alt=""></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h5 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h5><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="/Mysql索引及算法原理/timg-9.png" alt=""></p>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><img src="/Mysql索引及算法原理/timg-10.png" alt=""></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h5 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h5><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p>
<p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p>
<p><img src="/Mysql索引及算法原理/timg-11.png" alt=""></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p>
<p><img src="/Mysql索引及算法原理/timg-12.png" alt=""></p>
<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p>注：本文摘取自<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a> 如需阅读更详细内容请移步原博。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper集群搭建]]></title>
      <url>https://glenen.github.io/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本文只会涉及zookeeper的单机安装和集群搭建，都是自己亲身经历搭建过程，不会涉及任何有关zookeeper原理、分布式算法及分布式锁如何实现等，因为我自己都没搞懂……前不久看了《从paxos到zookeeper》，看到paxos算法，也没仔细弄懂，就头晕转移到其他书籍了。以后如果有时间，会再回头去看看那本书，再把有关原理的东西贴上来。</p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>本次搭建集群的是两台机器，自己在公司内部申请的两个docker容器，系统环境是centos6.5。centos7不建议使用，并且好像默认开启了防火墙。因为公司内部申请的，所以申请时候就预装了部署项目所必需的一些环境，详情如下图所示：</p>
<a id="more"></a>
<p><img src="/zookeeper集群搭建/timg-0.png" alt=""></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。ZooKeeper 是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。ZooKeeper官网：<a href="http://zookeeper.apache.org/" target="_blank" rel="external">http://zookeeper.apache.org/</a></p>
<h4 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>ssh命令登陆到自己的申请的虚拟机，在根目录下新建了一个zookeeper文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[...]$ mkdir zookeeper</div><div class="line">[...]$ cd zookeeper</div><div class="line">[...]$ wget http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.9/</div><div class="line">[...]$ unzip zookeeper-3.4.9.tar.gz</div></pre></td></tr></table></figure>
<p>wget命令下载默认是占用全部网络带宽，所以我下载的时候还是很快的，关于该命令在使用时的一些设置，可自行查阅。至此，zookeeper已经下载并安装好了，以下就是进行一些集群所需的配置。</p>
<p>注：也可在自己本机上下载zookeeper压缩包，然后通过scp命令或者Filezilla工具传输到虚拟机，但解压后，进入../bin/目录后，会出现启动脚本是白色的，这是因为该文件没有执行权限，可通过<code>chmod *** ***.sh</code>命令修改文件权限即可。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>1、在zookeeper目录下，新建data文件数据目录和日志目录：<code>[...]$ mkdir data 和 [...]$ mkdir logs</code></p>
<p>2、进入conf目录，conf目录下修改文件名 zoo_sample.cfg 改为 zoo.cfg，编辑配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[...]$ cd zookeeper-3.4.9/conf</div><div class="line">[...]$ mv zoo_sample.cfg zoo.cfg</div><div class="line">[...]$ sudo vim zoo.cfg</div></pre></td></tr></table></figure>
<p>打开后如下图所示(该图是我配置好后的)：</p>
<p><img src="/zookeeper集群搭建/timg-1.png" alt=""></p>
<p><strong><em>tickTime</em></strong> = # Zookeeper服务器心跳时间，单位毫秒!</p>
<p><strong><em>initLimit</em></strong> = # 投票选举新leader的初始化时间!</p>
<p><strong><em>syncLimit</em></strong> = # Leader与Follower之间的最大响应时间单位，响应超过syncLimit*tickTime，Leader认为Follwer挂掉，从服务器列表中删除Follwer!</p>
<p><strong><em>dataDir</em></strong> = # 数据持久化路径!</p>
<p><strong><em>dataLogDir</em></strong> = # 日志保存路径  这个要自己新建，具体目录根据自己的实际情况为准!</p>
<p><strong><em>clientPort</em></strong> = # 连接端口！</p>
<p><strong><em>server.num</em></strong> = <em>*</em>:2888:3888，该处配置的是集群服务器的IP列表，有多少台就配置多少，别写错！</p>
<h5 id="新增myid文件"><a href="#新增myid文件" class="headerlink" title="新增myid文件"></a>新增myid文件</h5><p>进入我们刚才在zookeeper目录下新建的data文件夹，创建名为myid的文件：<code>[...]$ sudo vi myid</code>。切换至插入模式，匹配着zoo.cfg配置文件中的<strong><em>server.num</em></strong>中的num来填写。本服务器的IP对应的num值是多少，就把该num值写入myid文件中保存并退出即可。每台服务器都必需对应配置好。</p>
<h5 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h5><p>进入bin目录，该目录下有一系列启动脚本，每台都登陆启动即可。如下图所示：</p>
<p><img src="/zookeeper集群搭建/timg-2.png" alt=""></p>
<p>启动zookeeper服务器：<code>sudo ./zkServer.sh start</code></p>
<p>关闭zookeeper服务器：<code>sudo ./zkServer.sh stop</code></p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> zookeeper </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[内存分配策略]]></title>
      <url>https://glenen.github.io/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>文中所涉及内容均为java虚拟机相关，但由于java虚拟机团队也一直在改进和优化java虚拟机，其中有的内容可能会与后续版本有差异，所以文中内容仅提供参考，不可作为任何定义为任何标准的准则，敬请谅解。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>对象主要在堆上分配，但也有可能经过JIT编译后被拆散为标量类型并间接地栈上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。</p>
<a id="more"></a>
<h4 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h4><p>大多数情况下，对象在Eden区分配，当Eden没有足够空间进行分配时，虚拟机将发起一次Minor GC。Minor GC：指发生在新生代的垃圾回收动作，因为java对象大多都具有朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>Full GC：发生在老年代的GC，出现了Full GC，经常会伴随至少一次Minor GC，但并非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Full GC的策略选择过程。Full GC的速度一般会比Minor GC慢10倍以上。</p>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象指需要大量连续内存空间的java对象，最典型的就是那种很长的字符串以及数组。java虚拟机说：“比遇到一个大对象更加坏的消息就是遇到一群‘朝生夕死’的‘短命大对象’。所以写程序时应到避免”。</p>
<p>虚拟机提供了一个-XX:PretenureSizeThreshold参数(只对Serial和Par New有效)，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个对象年龄Age计数器，如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移到Survivor空间中，并且对象年龄设为1.对象在Survivor区每经历一次Minor GC年龄就增加一岁，当它年龄增加到一定程度(默认15岁，可通过-XX:MaxTenuringThreshold设置)，将会被晋升到老年代中。</p>
<h5 id="对象年龄判定"><a href="#对象年龄判定" class="headerlink" title="对象年龄判定"></a>对象年龄判定</h5><p>为了更好适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可直接进入老年代。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么可以确保Minor GC是安全的。</p>
<p>如果不成立，虚拟机会检查HandlePromotionfailure设置值是否允许担保失败，如果允许，那么会继续检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将会尝试着进行一次Minor GC，尽管这次Minor GC是冒险的。如果小于，或者HandlePromotionfailure设置不允许冒险，那这时也要改为进行一次了Full GC。</p>
<p>JDK 6后规则为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[垃圾收集器]]></title>
      <url>https://glenen.github.io/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>文中所涉及内容均为java虚拟机相关，但由于java虚拟机团队也一直在改进和优化java虚拟机，其中有的内容可能会与后续版本有差异，所以文中内容仅提供参考，不可作为任何定义为任何标准的准则，敬请谅解。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>如下图所示：展示了7种作用于不同分代的收集器，如果两个收集器之间有连线，则它们可以搭配使用。收集器所处的区域，则代表它属于新生代还是老年代收集器。</p>
<a id="more"></a>
<p><img src="/垃圾收集器/hotspot垃圾收集器.png" alt=""></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>最基本、发展历史最悠久的收集器。单线程收集器，其进行垃圾收集时，必须暂停其他工作线程，直到它收集结束。虚拟机运行在client模式下的默认新生代收集器。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>Serial收集器的多线程版本。是许多运行在Server模式下的虚拟机中首选的新生代收集器。在JDK1.5中与CMS搭配使用。默认开启的收集线程数与CPU的数量相等，可以使用-XX:ParallelGCThreads参数限制垃圾收集的线程数。</p>
<p>并行Parallel：多条垃圾收集线程并行工作，此时用户线程仍然处于等待状态。</p>
<p>并发Concurrent：用户线程与垃圾收集线程同时执行，不一定并行，可能会交替执行，用户程序继续执行，而垃圾收集线程运行于另一个CPU上。</p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>采用复制算法且并行的多线程收集器。其目标是达到一个可控制的吞吐量throughput = 运行用户代码时间／(运行用户代码时间 + 垃圾收集时间)。停顿时间越短越适合与用户交互的程序，良好的反应速度能提升用户体验，而高吞吐量可以高效的利用CPU时间，尽快完成程序的运算任务，适用于在后台计算而不需要太多交互的任务。</p>
<p>-XX:MaxGCPauseMillis参数：控制最大垃圾收集停顿时间，大于0的毫秒数；-XX:GCTimeRatio参数：直接设置吞吐量大小，大于0且小于100的整数，相当于吞吐量的倒数。其具有自适应调节策略，打开开关-XX:UseAdaptiveSizePolicy参数即可。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial收集器老年代版本，单线程收集器，使用“标记—整理”算法，主要在于给Client模式下的虚拟机使用。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel老年代版本，使用多线程和“标记—整理”算法。在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Sca收集器加Parallel Old收集器组合。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>一种以获取最短回收停顿时间为目标的收集器，采用“标记—清除算法”，主要用于互联网站或者B/S系统的服务端。</p>
<p>初始标记：仅仅标记GC Roots能直接关联到的对象，需要“Stop The World” —&gt;  并发标记：进行GC Roots Tracing过程 —&gt; 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间稍比初始标记长，远比并发标记短 —&gt; 并发清除。</p>
<p>缺点：1、对CPU资源非常敏感；2、无法处理浮动垃圾；3、产生大量空间碎片。</p>
<h4 id="G1-Garbge-First-收集器"><a href="#G1-Garbge-First-收集器" class="headerlink" title="G1(Garbge-First)收集器"></a>G1(Garbge-First)收集器</h4><p>当今收集器技术发展最前沿的成果之一，面向服务端应用的垃圾收集器。特点：1、并行与并发；2、分代收集；3、空间整合；4、可预测的停顿。此时堆内存布局：java堆划分为多个大小相等的独立区域Region，虽然还保留新生代和老年代概念，但新生代和老年代不再是物理隔离的，它们都是一部分Region(不需要连续)的集合。</p>
<h5 id="可预测的停顿时间模型"><a href="#可预测的停顿时间模型" class="headerlink" title="可预测的停顿时间模型"></a>可预测的停顿时间模型</h5><p>因为它可以有计划地避免在整个java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<h5 id="Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法"><a href="#Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法" class="headerlink" title="Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法"></a>Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法</h5><p>G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行垃圾回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<p>步骤：初始标记—并发标记—最终标记—筛选回收。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[垃圾回收策略]]></title>
      <url>https://glenen.github.io/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>文中所涉及内容均为java虚拟机相关，但由于java虚拟机团队也一直在改进和优化java虚拟机，其中有的内容可能会与后续版本有差异，所以文中内容仅提供参考，不可作为任何定义为任何标准的准则，敬请谅解。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分的主要内容是了解虚拟机如何判定对象的存活状态，采用什么样的垃圾回收算法和hotspot虚拟机垃圾回收的机制。</p>
<h4 id="判断对象是否存活算法"><a href="#判断对象是否存活算法" class="headerlink" title="判断对象是否存活算法"></a>判断对象是否存活算法</h4><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1，当引用失效时，计数器值减1，任何时刻计数器为0的对象就是不可能再被使用的。实现简单，判定效率高，很多应用案例。但java虚拟机并未使用该算法(很难解决对象之间相互循环引用的问题)。如下代码所示：</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 演示JVM没有通过计算计数算法来判断对象的存活：解决相互引用问题</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2016-12-27</div><div class="line"> */</div><div class="line">@SuppressWarnings(<span class="string">"all"</span>)</div><div class="line">public class ReferenceCountGCTest &#123;</div><div class="line"></div><div class="line">    private ReferenceCountGCTest instance = null;</div><div class="line">    private static final int _1MB = 1024 * 1024;</div><div class="line">    /**</div><div class="line">     * 该属性存在的意义是占用内存，以便能在GC日志中看清楚是否被回收过</div><div class="line">     */</div><div class="line">    private byte[] bigSize = new byte[2 * _1MB];</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">testGC</span></span>() &#123;</div><div class="line">        ReferenceCountGCTest A = new ReferenceCountGCTest();</div><div class="line">        ReferenceCountGCTest B = new ReferenceCountGCTest();</div><div class="line"></div><div class="line">        A.instance = B;</div><div class="line">        B.instance = A;</div><div class="line"></div><div class="line">        A = null;</div><div class="line">        B = null;</div><div class="line"></div><div class="line">        // 该处触发垃圾回收：观察GC日志变化</div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>java、C#使用，基本思路是通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。如下图所示：</p>
<p><img src="/垃圾回收策略/可达性分析算法.png" alt=""></p>
<p>图中7、8、9对象虽然之间相互引用，但是他们没有与“GC Roots”对象相关联，垃圾回收的时候会被回收，其他与引用链的对象则不会。</p>
<h5 id="java中可作为GC-Roots对象包括"><a href="#java中可作为GC-Roots对象包括" class="headerlink" title="java中可作为GC Roots对象包括"></a>java中可作为GC Roots对象包括</h5><p>1.虚拟机栈(栈帧中的本地变量表)中引用的对象；2.方法区中类静态属性引用的对象；3.方法区中常量引用的对象；4.本地方法栈中JNI(一般说Native方法)引用的对象。</p>
<h4 id="宣告对象死亡"><a href="#宣告对象死亡" class="headerlink" title="宣告对象死亡"></a>宣告对象死亡</h4><p>当根据可达性分析算法分析到该对象没有链接到“GC Roots”的引用链时，并不会真正的宣告该对象死亡。真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后，没有发现与GC Roots相连接的引用链，那它将会被第一次标记且进行一次筛选，筛选的条件是是此对象是否有必要执行finalize()方法。没有必要执行：1、对象没有覆盖该方法；2、该方法已被虚拟机调用过。如果有必要执行该方法，则对象会被放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它(触发但不承诺等待它运行结束)。</p>
<p>finalize()方法是对象逃脱死亡的最后一次机会(重新与引用链上的任何一个对象建立关联即可，如把自己(this关键字)赋值给某个类变量或者对象的成员变量)。稍后GC将对叫做F-Queue队列中的对象进行第二次小规模的标记(成功自救的移除“即将回收”的集合)。如下代码演示了对象逃逸：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * finalize()演示垃圾回收逃逸和回收</div><div class="line"> *</div><div class="line"> * &lt;p&gt;1.一个对象当要被回收的时候可以逃逸.&lt;br&gt;</div><div class="line"> * 2.一个对象只能有一次机会逃逸，因为finalize最多只能被系统调用一次.</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2016-12-29</div><div class="line"> */</div><div class="line">public class FinalizeEscapeGCTest &#123;</div><div class="line"></div><div class="line">    private static FinalizeEscapeGCTest SAVE_HOOK = null;</div><div class="line"></div><div class="line">    private void isAlive() &#123;</div><div class="line">        System.out.println(&quot;yes, i am still alive :)&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void finalize() throws Throwable &#123;</div><div class="line">        super.finalize();</div><div class="line">        System.out.println(&quot;method finalize executed...&quot;);</div><div class="line">        FinalizeEscapeGCTest.SAVE_HOOK = this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        SAVE_HOOK = new FinalizeEscapeGCTest();</div><div class="line">        /*the object escape at first*/</div><div class="line">        SAVE_HOOK = null;</div><div class="line">        System.gc();</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(500);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        if (SAVE_HOOK == null) &#123;</div><div class="line">            System.out.println(&quot;no, i am dead :(&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            SAVE_HOOK.isAlive();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /*the object escape for twice failed*/</div><div class="line">        SAVE_HOOK = null;</div><div class="line">        System.gc();</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(500);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        if (SAVE_HOOK == null) &#123;</div><div class="line">            System.out.println(&quot;no, i am dead :(&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            SAVE_HOOK.isAlive();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h5><p>运行代价昂贵、不确定性大、无法保证各个对象的调用顺序，其所能做的工作try-finally或其他方法能做更好更及时。</p>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>回收主要部分：废弃常量和无用的类。回收废弃常量与堆中对象的回收非常类似。判定无用的类：1、该类的所有的实例都已经被回收；2、加载该类的ClassLoader已经被回收；3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。无用类可以被回收，但不是必然被回收，HotSpot虚拟机提供-Xnoclassgc参数进行控制。</p>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h5><p>分为“标记”“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。问题：1、效率低，标记和清除两个过程都效率低；2、空间，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。如图所示：</p>
<p><img src="/垃圾回收策略/标记—清理算法.png" alt=""></p>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块地内存用完了，将还存活着地对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。优点：分配时不用考虑内存碎片，按顺序分配，实现简单，运行高效。代价：将内存缩小为了原来的一半，未免太高了点。</p>
<p>现代商业虚拟机都采用此种收集算法来回收新生代，IBM研究：新生代中的对象98%是“朝生夕死”的。HotSpot中，Eden与Survivor的大小比例为8:1，即新生代中可用的内存空间为新生代容量的90%。如图所示：</p>
<p><img src="/垃圾回收策略/复制算法.png" alt=""></p>
<h5 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h5><p>根据老年代的特点，提出了该算法，标记过程仍然与“标记—清除”算法一样，但后续步骤不是对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。如图所示：</p>
<p><img src="/垃圾回收策略/标记—整理算法.png" alt=""></p>
<h4 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h4><h5 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h5><p>可达性分析必须在一个能确保一致性的快照中进行，一致性：整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现出现分析过程中对象引用关系还在不断的变化，否则无法保证分析结果的准确性。该点是导致GC进行时必须停顿所有java执行线程的一个重要原因。</p>
<h5 id="HotSpot实现枚举"><a href="#HotSpot实现枚举" class="headerlink" title="HotSpot实现枚举"></a>HotSpot实现枚举</h5><p>使用一组称为OopMap的数据结构，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
<h5 id="安全点safepoint"><a href="#安全点safepoint" class="headerlink" title="安全点safepoint"></a>安全点safepoint</h5><p>HotSpot没有为每条指令都生成OopMap，只是在“特定位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都停顿下来开始GC，只有在到达安全点时才停止。safepoint选定标准：是否具有让程序长时间执行的特征。所以只有指令复用如方法调用、循环跳转、异常跳转等具有这些功能等指令才会产生safepoint。如何在GC发生时让所有线程都“跑”到最近的安全点上再停顿下来。</p>
<h5 id="主动式中断"><a href="#主动式中断" class="headerlink" title="主动式中断"></a>主动式中断</h5><p>当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时去轮询这个标志，发现中断标志为真时就自己挂起中断。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
<h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的safepoint。但是当线程处于Sleep或者Blocked状态，就无法响应JVM的中断请求，“走”到安全点地方去挂起中断，JVM也不可能等待线程重新被分配CPU时间。安全区域safe region：在一段代码片段中，引用关系不会发生变化。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树的Morris遍历]]></title>
      <url>https://glenen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84Morris%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本博文所设计内容均为本人亲自所著，为工作闲暇之余及大学时代所积累，涉及思路不会描述太仔细，仅供参考，如有错误，敬请谅解。</p>
<p>二叉树的递归遍历、借助栈数据结构遍历较简单，不做赘述，此处给出二叉树的最优遍历方法：Morris遍历，时间复杂度O(n)，空间复杂度O(1)。</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先给出一棵二叉树：</p>
<p><img src="/二叉树的Morris遍历/二叉树—Morris.png" alt="通"></p>
<p>如图所示，这树比较奇特，没啥别的，就是叶子节点多了些箭头指向自己上层的节点。平时叶子节点都是干干净净的，今天突然冒出来必然不是冒然的。今天我们就要运用这些箭头完成节点控制权的转移。</p>
<p>如我们所知，二叉树由上层节点向下层节点转移很容易，因为它有从父节点指向孩子节点的指针，但是孩子节点向父节点转移就没那么容易了—没有直接的指向指针。我们借助栈结构遍历时候，其实做的工作就是完成节点控制权的转移。但现在我们可以利用叶子节点那些大量指向Null的空闲指针来帮助我们完成其节点控制权的转移，从而完成二叉树的遍历。</p>
<p>此处给出大体方向，详细点的代码中注释，后序我选择放弃—因为难啊！</p>
<p>1.第一个目标！就是让整颗二叉树中的节点都过一把当头节点的隐，当然，前提是它得有孩子。</p>
<p>2.第二个目标！每个节点当头节点时，都让以它为头节点的左子树的最右边的叶子节点的right Null指针指向该头节点。</p>
<p>3.第三个目标！按照我们的意愿控制节点的控制权的转移。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 定义二叉树</div><div class="line"> */</div><div class="line">@Data</div><div class="line">public class Node &#123;</div><div class="line">   /**</div><div class="line">    * 节点值</div><div class="line">    */</div><div class="line">    private int dataValue;</div><div class="line">   /**</div><div class="line">    * 左孩子节点</div><div class="line">    */</div><div class="line">    private Node left;</div><div class="line">   /**</div><div class="line">    * 右孩子节点</div><div class="line">    */</div><div class="line">    private Node right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Morris 中序遍历</div><div class="line"> *</div><div class="line"> * @param 头节点</div><div class="line"> */</div><div class="line">public static void midTraversal(Node head) &#123;</div><div class="line">        <span class="keyword">if</span> (head == null) &#123;</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.print(<span class="string">"midTraversal:"</span>);</div><div class="line">            Node cur1 = head;</div><div class="line">            Node cur2 = null;</div><div class="line">            <span class="keyword">while</span> (cur1 != null) &#123;</div><div class="line">                cur2 = cur1.left;</div><div class="line">                <span class="keyword">if</span> (cur2 != null) &#123;</div><div class="line">                    // 找到每棵二叉树的左子树的最右叶子节点</div><div class="line">                    <span class="keyword">while</span> (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;</div><div class="line">                        cur2 = cur2.right;</div><div class="line">                    &#125;</div><div class="line">                    // 让该叶子节点的right Null指针指向其头节点</div><div class="line">                    <span class="keyword">if</span> (cur2.right == null) &#123;</div><div class="line">                        // 把以cur1为头节点的左子树最右节点的right空指针指向cur1</div><div class="line">                        cur2.right = cur1;</div><div class="line">                        // 控制权转移给它左孩子，继续寻找最右               </div><div class="line">                        // 叶子节点的right Null指针指向头节点的操作</div><div class="line">                        cur1 = cur1.left;</div><div class="line">                        <span class="built_in">continue</span>;</div><div class="line">                    // 还原以前的二叉树结构</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        cur2.right = null;</div><div class="line">                    &#125;</div><div class="line">                    System.out.print(cur1.dataValue + <span class="string">" "</span>);</div><div class="line">                    // 根据我们建立的right指针控制节点的转移</div><div class="line">                    cur1 = cur1.right;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Morris 先序遍历</div><div class="line"> *</div><div class="line"> * @param 头节点</div><div class="line"> */</div><div class="line">public static void preTraversal(Node head) &#123;</div><div class="line">        <span class="keyword">if</span> (head == null) &#123;</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.print(<span class="string">"preTraversal:"</span>);</div><div class="line">            Node cur1 = head;</div><div class="line">            Node cur2 = null;</div><div class="line">            <span class="keyword">while</span> (cur1 != null) &#123;</div><div class="line">                cur2 = cur1.left;</div><div class="line">                <span class="keyword">if</span> (cur2 != null) &#123;</div><div class="line">                    // 找到每棵二叉树的左子树的最右叶子节点</div><div class="line">                    <span class="keyword">while</span> (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;</div><div class="line">                        cur2 = cur2.right;</div><div class="line">                    &#125;</div><div class="line">                    // 让该叶子节点的right Null指针指向其头节点</div><div class="line">                    <span class="keyword">if</span> (cur2.right == null) &#123;</div><div class="line">                        // 把以cur1为头节点的左子树最右节点的right空指针指向cur1</div><div class="line">                        cur2.right = cur1;</div><div class="line">                        System.out.print(cur1.dataValue + <span class="string">" "</span>);</div><div class="line">                        <span class="built_in">continue</span>;</div><div class="line">                    // 还原以前的二叉树结构</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        cur2.right = null;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    // 根据我们建立的right指针控制节点的转移</div><div class="line">                    cur1 = cur1.right;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[可持久化数据结构]]></title>
      <url>https://glenen.github.io/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>When you hear the word persistence in programming, most often, you think of an application saving its data to some type of storage, such as a database, so that the data can be retrieved later when the application is run again. There is, however, another meaning for the word persistence when it is used to describe data structures, particularly those used in functional programming languages. In that context, a persistent data structure is a data structure capable of preserving the current version of itself when modified. In essence, a persistent data structure is immutable.</p>
<p>当你在编程过程中听到持久化这个单词的时候，大多数情况下，你会认为是应用程序将其数据为存储为某种类型的文件中，例如数据库，以便于以后当应用程序再次运行时能够从介质中重新获取数据。然而这里的持久化讲的是另外一个意思，用其来描述一种数据结构，通常会用在一些函数式的编程语言中。从这个意义上来讲，一个具有持久化能力的数据结构在其被修改后可以保存当前的状态，从本质上来说，这样的数据结构是不可改变类型（immutable）。</p>
<a id="more"></a>
<p>An example of a class that uses this type of persistence in the .NET Framework is the string class. Once a string object is created, it cannot be changed. Any operation that appears to change a string generates a new string instead. Thus, each version of a string object can be preserved. An advantage for a persistent class like the string class is that it basically gives you undo functionality built-in. As newer versions of a persistent object are created, older versions can be pushed onto a stack and popped off when you want to undo an operation. Another advantage is that because persistent data structures cannot change state, they are easier to reason about and are thread safe.</p>
<p>.NET Framework中的String类正好是使用了持久化能力的一个例子。一旦创建了一个String类型实例，它便不能被改变了，对于欲改变其值的任何操作都将被产生一个新的String对象，通过这样，每一个版本的String实例都将被驻留下来。这样的具有持久化特点的类型像String类型都内置了撤销（Undo）功能，当该对象的新一个版本产生的时候，旧版本将被压入栈中，如果需要执行撤销动作的时候，只需将旧版本从堆栈中取出。另外一个优点是由于可持久化数据类型不能更改其内部状态，很容易得知它是线程安全的。</p>
<p>There is an overhead that comes with persistent data structures, however. Each operation that changes a persistent data structure creates a new version of that data structure. This can involve a good deal of copying to create the new version. This cost can be mitigated to a large degree by reusing as much of the internal structure of the old version in creating a new one. I will explore this idea in making two common data structures persistent: the singly linked list and the binary tree, and describe a third data structure that combines the two. I will also describe several classes I have created that are persistent versions of some of the classes in the System.Collections namespace.</p>
<p>然而持久化的数据结构会带来一些开销，任何改变持久化数据结构的操作都将创建一个新的版本，这可能会涉及到大量的拷贝操作，通常我们可以通过重用旧版本对象的内部数据结构来创建一个新的对象，这种办法可以极大地降低拷贝操作所带来的消耗。我将会通过两个常用的数据结构来阐述这个思想：单向列表以及二叉树，然后通过这两个数据结构来组合第三个数据结构。同时我也会讲述System.Collection命名空间下面的那些持久化的类型。</p>
<h4 id="Persistent-Singly-Linked-Lists"><a href="#Persistent-Singly-Linked-Lists" class="headerlink" title="Persistent Singly Linked Lists"></a>Persistent Singly Linked Lists</h4><h4 id="持久化的单向链表"><a href="#持久化的单向链表" class="headerlink" title="持久化的单向链表"></a>持久化的单向链表</h4><p>The singly linked list is one of the most widely used data structures in programming. It consists of a series of nodes linked together one right after the other. Each node has a reference to the node that comes after it, and the last node in the list terminates with a null reference. To traverse a singly linked list, you begin at the head of the list and move from one node to the next until you have reached the node you are looking for or have reached the last node:</p>
<p>单向链表是一个在编程中使用非常广泛的基础数据结构，它是由一系列相互链接的节点组成。每一个节点都拥有一个指向下一个节点的引用，链表中的最后一个节点将拥有一个空引用。如果你想遍历一个单向链表，可以从第一个节点开始，逐个向后移动，直到到达最后的节点。如下图所示：</p>
<p><img src="/可持久化数据结构/LinkedList-0.png" alt=""></p>
<p>Let’s insert a new item into the list. This list is not persistent, meaning that it can be changed in-place without generating a new version. After taking a look at the insertion operation on a non-persistent list, we’ll look at the same operation on a persistent list.</p>
<p>让我们插入一个新的节点到这个链表中去，并且该链表是非持久化的，也就是说这个链表可以被改变而无需产生一个新的版本。在查看了非持久化链表的插入操作之后，我们将会查看同样的操作在持久化链表中。</p>
<p>Inserting a new item into a singly linked list involves creating a new node:</p>
<p>插入一个新的节点到单向列表中会涉及到创建一个新的节点：</p>
<p><img src="/可持久化数据结构/LinkedList-1.png" alt=""></p>
<p>We will insert the new node at the fourth position in the list. First, we traverse the list until we’ve reached that position. Then the node that will precede the new node is unlinked from the next node…</p>
<p>我们将会在第四个位置插入新的节点，第一我们遍历链表到达指定位置，也就是插入节点前面的那个节点，将其与后面节点断开。</p>
<p><img src="/可持久化数据结构/LinkedList-2.png" alt=""></p>
<p>…and relinked to the new node. The new node is, in turn, linked to the remaining nodes in the list:</p>
<p>然后链接该节点与待插入节点，在下来，链接新的节点与上一步剩余的节点。</p>
<p><img src="/可持久化数据结构/LinkedList-3.png" alt=""></p>
<p>Inserting a new item into a persistent singly linked list will not alter the existing list but create a new version with the item inserted into it. Instead of copying the entire list and then inserting the item into the copy, a better strategy is to reuse as much of the old list as possible. Since the nodes themselves are persistent, we don’t have to worry about aliasing problems.</p>
<p>如果插入一个新的节点到持久化的单向链表中，我们不应该改变当前链表的状态，而需要创建一个新的链表而后插入指定节点。相对于拷贝当前链表，而后插入指定节点，一个更好的策略是尽可能的重用旧的链表。因为节点本身是可持久化的，所以我们不必担心对象混淆的问题。</p>
<p>To insert a new node at the fourth position, we traverse the list as before only copying each node along the way. Each copied node is linked to the next copied node:</p>
<p>为了插入新节点到第四个位置，我们遍历链表到指定位置，拷贝每个遍历节点，同时指定拷贝的节点指向其下一个节点的拷贝。</p>
<p><img src="/可持久化数据结构/LinkedList-4.png" alt=""></p>
<p>The last copied node is linked to the new node, and the new node is linked to the remaining nodes in the old list:</p>
<p>最后一个拷贝的节点指向新的插入节点，而后，新节点指向旧链表剩下的节点。</p>
<p><img src="/可持久化数据结构/LinkedList-5.png" alt=""></p>
<p>On an average, about N/2 nodes will be copied in the persistent version for insertions and deletions, where N equals the number of nodes in the list. This isn’t terribly efficient but does give us some savings. One persistent data structure where this approach to singly linked list buys us a lot is the stack. Imagine the above data structure with insertions and deletions restricted to the head of the list. In this case, N nodes can be reused for pushing items onto a stack and N - 1 nodes can be reused for popping a stack.</p>
<p>平均来看，对于插入和删除操作，大约有N/2的节点将被拷贝，而N等于链表长度。这并不是特别的高效，仅仅只是节省了一些空间。与通过这样的方式来构建单向链表一样的一个数据结构是堆栈，我们可以想象一下在链表起始位置的插入以及删除操作，在这个场景中，对于堆栈来讲，压栈操作时全部节点都可以被重用，而出栈操作也有N-1个节点被重用。 </p>
<h4 id="Persistent-Binary-Trees"><a href="#Persistent-Binary-Trees" class="headerlink" title="Persistent Binary Trees"></a>Persistent Binary Trees</h4><h4 id="持久化二叉树"><a href="#持久化二叉树" class="headerlink" title="持久化二叉树"></a>持久化二叉树</h4><p>A binary tree is a collection of nodes in which each node contains two links, one to its left child and another to its right child. Each child is itself a node, and either or both of the child nodes can be null, meaning that a node may have zero to two children. In the binary search tree version, each node usually stores a key/value pair. The tree is searched and ordered according to its keys. The key stored at a node is always greater than the keys stored in its left descendents and always less than the keys stored in its right descendents. This makes searching for any particular key very fast.</p>
<p>一个二叉树是一系列节点的集合，每一个节点都包含有两个子节点，一个称之为左节点，而另一个称之为右节点。而子节点也是这样一个节点，也有一个左节点和一个右节点，当然也可以没有子节点，也就是说一个节点可能有零个或者两个子节点。在二叉查找树中，每一个节点通常包含了一个键值对，树结构将会依照节点的键来进行查找和组织。节点的键会永远大于其左节点的键，永远小于其右节点的键，这将使得对于特定键的查找非常迅速。</p>
<p>Here is an example of a binary search tree. The keys are listed as numbers; the values have been omitted but are assumed to exist. Notice how each key as you descend to the left is less than the key of its predecessor, and vice versa as you descend to the right:</p>
<p>下图是一个二叉查找树的例子，节点的键作为数字被列出，而节点的值则被忽略尽管是始终存在的。注意到每一个左边节点的键值一定会小于它的父节点即前驱节点，而每一个右边节点的键值一定大于其父节点键值。 </p>
<p><img src="/可持久化数据结构/PersistentTree-0.png" alt=""></p>
<p>Changing the value of a particular node in a non-persistent tree involves starting at the root of the tree and searching for a particular key associated with that value, and then changing the value once the node has been found. Changing a persistent tree, on the other hand, generates a new version of the tree. We will use the same strategy in implementing a persistent binary tree as we did for the persistent singly linked list, which is to reuse as much of the data structure as possible when making a new version.</p>
<p>如果在一个非持久化的树中更改一个特定节点的值，我们会从根节点按照特定键值开始搜索，如果找到则直接更改该节点的值。但是如果是在一个持久化的树上的话，换句话说，我们需要创建一个新版本的树，同时还需要保持同实现一个持久化的二叉树或者单向链表一样的策略，即尽可能的重用当前的数据来创建一个新的版本。</p>
<p>Let’s change the value stored in the node with the key 7. As the search for the key leads us down the tree, we copy each node along the way. If we descend to the left, we point the previously copied node’s left child to the currently copied node. The previous node’s right child continues to point to nodes in the older version. If we descend to the right, we do just the opposite.</p>
<p>下面让我们来尝试改变键为7的节点的值，按照自顶向下查找该节点的路径，我们需要拷贝该路径上的每一个节点。如果转向左边，需要将上一个拷贝的节点指向当前拷贝节点，而前一个节点的右侧节点则继续指向原来旧版本的节点。如果转向右边，则采用相反的做法。</p>
<p>This illustrates the “spine” of the search down the tree. The red nodes are the only nodes that need to be copied in making a new version of the tree:</p>
<p>下图列出了在树上自顶向下搜索特定节点的路径，在构建新版本的树的时候仅仅需要拷贝那些红色的节点。</p>
<p><img src="/可持久化数据结构/PersistentTree-1.png" alt=""></p>
<p>You can see that the majority of the nodes do not need to be copied. Assuming the binary tree is balanced, the number of nodes that need to be copied any time a write operation is performed is at most O(Log N), where Log is base 2. This is much more efficient than the persistent singly linked list.</p>
<p>你能够发现大多数节点是不要拷贝的，假定二叉树是平衡的，在每一次节点值的写操作中需要拷贝的节点数目大约是O（LogN），对数的底为2。显然比起持久化的单向链表效率很高。</p>
<p>Insertions and deletions work the same way, only steps should be taken to keep the tree in balance, such as using an AVL tree. If a binary tree becomes degenerate, we run into the same efficiency problems as we did with the singly linked list.</p>
<p>插入以及删除操作将按照同样的方式进行，但是一些额外的保持树平衡的操作还是必须的，例如使用AVL树作为底层数据结构的时候。如果二叉树变得很不平衡，我们将会碰到同样的效率问题如同在持久化单向链表是一样。</p>
<h4 id="Random-Access-Lists"><a href="#Random-Access-Lists" class="headerlink" title="Random Access Lists"></a>Random Access Lists</h4><h4 id="随机存取链表"><a href="#随机存取链表" class="headerlink" title="随机存取链表"></a>随机存取链表</h4><p>An interesting persistent data structure that combines the singly linked list with the binary tree is Chris Okasaki’s random-access list. This data structure allows for random access of its items as well as adding and removing items from the beginning of the list. It is structured as a singly linked list of completely balanced binary trees. The advantage of this data structure is that it allows access, insertion, and removal of the head of the list in O(1) time as well as provides logarithmic performance in randomly accessing its items.</p>
<p>一个比较有意思的持久化数据结构是Chris Okasaki的随机存取列表，它结合了单向链表和二叉树的特点。这个数据结构除了允许用户随机操作其节点外，还支持在列表的起始位置添加和删除节点。它被组织成为一个使用二叉树来平衡的单向链表，其优点是当在其起始位置进行节点操作时，只需要O(1)的复杂度，而在随机操作节点的时候，也只有O(Log(N)).</p>
<p>Here is a random-access list with 13 items:</p>
<p>下面是一个具有13个子节点的随机存取列表： </p>
<p><img src="/可持久化数据结构/RandomAccessList-0.png" alt=""></p>
<p>When a node is added to the list, the first two root nodes (if they exist) are checked to see if they both have the same height. If so, the new node is made the parent of the first two nodes; the current head of the list is made the left child of the new node, and the second root node is made the right child. If the first two root nodes do not have the same height, the new node is simply placed at the beginning of the list and linked to the next tree in the list.</p>
<p>当添加一个节点到列表中的时候，前两个根节点会被查看它们的高度是否相同，如果是的话，那新的节点将是这两个节点的父节点，第一个节点将会作为插入节点的左子节点，而第二个节点会作为右节点。而如果这两个节点高度不同，新的节将会直接被放在节点的起始位置，然后链接到剩余节点。</p>
<p>To remove the head of the list, the root node at the beginning of the list is removed, with its left child becoming the new head and its right child becoming the root of the second tree in the list. The new head of the list is right linked with the next root node in the list:</p>
<p>如果要删除链表的头节点，也就是要删除链表的起始根节点，然后将其左侧子节点作为新的头节点，而右侧子节点则作为链表中第个树的根节点。新的头节点会指向链表中向右的第二个根节点。</p>
<p><img src="/可持久化数据结构/RandomAccessList-1.png" alt=""></p>
<p>Keep in mind that all operations that change a random-access list do not change the existing list but rather generate a new version representing the change. As much of the old list is reused in creating a new version.</p>
<p>记住所有改变随机存取列表的操作都不会改变现有列表，而是创建一个新的版本，并且在创建新版本的时候要尽可能充用现有列表。</p>
<h4 id="Immutable-Collections"><a href="#Immutable-Collections" class="headerlink" title="Immutable Collections"></a>Immutable Collections</h4><h4 id="不可改变集合类型"><a href="#不可改变集合类型" class="headerlink" title="不可改变集合类型"></a>不可改变集合类型</h4><p>Included with this article are a number of persistent collection classes I have created. These classes are in a namespace called ImmutableCollections. I have created persistent versions of some of the collection classes in the System.Collections namespace. I will describe each one and some of the challenges in making them persistent. There are several collection classes that are currently missing; I need to add a queue, for example. Hopefully, I will get to those in time. Also, even though I’ve taken steps to make these classes efficient, they cannot compete with the System.Collections classes in terms of speed, but they really aren’t meant to. They are meant to provide the advantages of immutability while providing reasonable performance.</p>
<p>在本文中我创建了许多持久化的集合类型，放在命名空间ImmutableCollections下。对于System.Collection命名空间下的一些集合类，我也创建了一个持久化的版本。我将会逐个讲述这些类型，阐述在持久化这些类时所遇到的问题及挑战。当然有一些遗漏的，例如Queue。希望有时间我能够将它们补上。尽管我已经采取了一些措施来提高性能，在存取速度上这些类还是不能与System.Collection命名空间的类相比较，但是这些类具有不可变类型的优点，而且具有合理的可以接收的性能。</p>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>This one was easy. Simply create a persistent singly linked list and limit insertions and deletions to the head of the list. Since this class is persistent, popping a stack returns a new version of the stack with the next item in the old stack as the new top. In the System.Collections.Stack version, popping the stack returns the top of the stack. The question for the persistent version was how to make the top of the stack available since it cannot be returned when the stack is popped. I chose to create a Top property that represents the top of the stack.</p>
<p>这个类是比较容易的，可以创建一个持久化的单向链表，然后限定只能在起始位置进行插入和删除操作。因为这个类是持久化的，出栈操作将会返回一个新版本的堆栈，这个堆栈以旧堆栈的第二个节点为头节点。在System.Collection命名空间下，出栈操作仅仅只是删除栈顶元素并返回。</p>
<h5 id="SortedList"><a href="#SortedList" class="headerlink" title="SortedList"></a>SortedList</h5><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>The SortedList uses AVL tree algorithms to keep the tree in balance. I found it useful to create an IAvlNode interface. Two classes implement this interface, the AvlNode class and the NullAvlNode class. The NullAvlNode class implements the null object design pattern. This simplified many of the algorithms.</p>
<p>有序列表使用了AVL树的算法来保持树节点的平衡，我创建了一个叫IAvlNode的接口，有两个类实现了这个接口，它们分别是AvlNode以及NullAvlNode类。NullAvlNode类利用了Null对象的设计模式，这将会简化一些算法。</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><p>This is the class that proved most challenging. Like the SortedList, it uses a persistent AVL tree as its data structure. However, unlike the SortedList, items are accessed by index (or by position) rather than by key. I have to admit that the algorithms for accessing and inserting items in a binary tree by index weren’t intuitive to me, so I turned to Knuth. Specifically, I used Algorithms B and C in section 6.2.3 in volume 3 of The Art of Computer Programming.</p>
<p>这个类的实现会遇到更多的挑战。与有序列表相同的是它也使用了持久化的AVL树来作为其底层的数据结构，不同的地方是是用户只能通过顺序索引来操作列表元素而不是字符串索引。不得不说的是我的本意并不是在一个二叉树上按照顺序索引来操纵和插入列表元素，所以我查看了Knuth的书籍，准确地来讲是使用了计算机编程的艺术第三卷6.2.3中的算法B和C。</p>
<p>I made an assumption about the ArrayList in order to improve performance. I assumed that the Add method is by far the most used method. However, adding items to the ArrayList one right after the other causes a lot of tree rotations to keep the tree in balance. To solve this, I created a template tree that is already completely balanced. Since this template tree is immutable, it can exist at the class level and be shared amongst all of the instances of the class.</p>
<p>为了提高动态数组的性能，我做了一个假设。假定Add方法是动态数组使用最多的方法，然而为了保持树的平衡，添加对象操作会引起多次的树旋转。为了解决这个问题，我创建了一个完全平衡的模板树，因为这个树是不可更改的，它可以在类的级别上存在，且能够被所有类的实例所共享。</p>
<p>When an instance of the ArrayList class is created, it takes a small subtree of the template tree. As items are added, the nodes in the template tree are replaced with new nodes. Since the tree is completely balanced, no rebalancing is necessary. If the subtree gets filled up, another subtree of equal height is taken from the template tree and joined to the existing tree. Insertions and deletions are handled normally with rebalancing performed if necessary. Again, the assumption is that adding items to the ArrayList occurs much more frequently than inserting or deleting items.</p>
<p>当一个动态数组的实例被创建的时候，它会抓住模板树的一个子树。当添加子节点的时候，模板树上的节点将会被新添的节点所替换，因为模板树本身就是平衡的，所以无需平衡树的操作。如果这个子树已经被填满，则会在模板树上抓取高度相同的另外一个子树，然后加入当前存在的树。当然插入和删除操作就需要进行平衡操作了。再一次强调的是我们的假设是添加节点的操作会远多于插入以及删除操作，才可以这样做。</p>
<h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>The Array class uses the random access list structure to provide a persistent array with logarithmic performance. Unlike a random access list, it has a fixed size.</p>
<p>数组类使用随机存取列表作为基础的数据结构，而随机存取列表在进行查找的时候只有Log（N）的复杂度，与随机存取列表不同的是，数据具有固定的长度。</p>
<h5 id="RandomAccessList"><a href="#RandomAccessList" class="headerlink" title="RandomAccessList"></a>RandomAccessList</h5><h5 id="随机存取列表"><a href="#随机存取列表" class="headerlink" title="随机存取列表"></a>随机存取列表</h5><p>This class does not have a parallel in the System.Collections namespace, but it was one of the first persistent classes I wrote, and I decided to include it here. It’s a straightforward implementation of Chris Okasaki’s random-access list described above. This data structure was designed to be used in functional languages where lists have three basic operations: Cons, Head, and Tail. Cons adds an item to the head of the list, Head is the first item in the list, and Tail represents all of the items in the list except for the Head.</p>
<p>这个类型在.NET类库的System.Collection命名空间下没有对应的实现类，但是它是我写的第一个持久化类，所以我决定在这里也介绍一下。在Chris Okasaki的文章中有一个简单易懂的实现，在一些函数式语言中会经常用到这个数据结构，通常它有三个基本操作：Cons，Head和Tail，Cons会添加一个新的对象到这个列表对象的开头，而Head将会返回列表的第一个对象，通过Tail会得到列表中除了第一个对象外的所有对象。</p>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>Persistent data structures help simplify programming by eliminating a whole class of bugs associated with side-effects and synchronization issues. They are not a cure-all but are a useful tool for helping a programmer deal with complexity. I have explored ways of making data structures persistent and have provided a small .NET library of persistent data structures. I hope you have enjoyed the article, and as always, I welcome feedback.</p>
<p>持久化数据结构会有助于简化编程，将一些线程同步的问题消除掉。它并不是解救一切的灵丹妙药，而是帮助程序员减低程序复杂度的一个工具。我已经阐述了如何构建持久化数据的多种方法，并且打包成一个小的.NET类库。我希望你能够从本文中受益，并且永远欢迎您的反馈信息。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p>本帖转载自：<a href="http://www.cnblogs.com/tedzhao/archive/2008/11/12/1332112.html" target="_blank" rel="external">http://www.cnblogs.com/tedzhao/archive/2008/11/12/1332112.html</a></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HotSpot虚拟机对象]]></title>
      <url>https://glenen.github.io/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>文中所涉及内容均为java虚拟机相关，但由于java虚拟机团队也一直在改进和优化java虚拟机，其中有的内容可能会与后续版本有差异，所以文中内容仅提供参考，不可作为任何定义为任何标准的准则，敬请谅解。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分的主要内容是了解虚拟机中的数据以及它们是如何创建、如何布局、如何访问的。</p>
<h4 id="hotspot虚拟机对象"><a href="#hotspot虚拟机对象" class="headerlink" title="hotspot虚拟机对象"></a>hotspot虚拟机对象</h4><h5 id="对象的创建步骤"><a href="#对象的创建步骤" class="headerlink" title="对象的创建步骤"></a>对象的创建步骤</h5><p>虚拟机遇到一条new指令 -&gt; 检查这个指令的参数是否能在常量池中定位到一个类的符号引用 -&gt; 检查这个符号引用代表的类是否已被加载、解析和初始化过 -&gt; 检查都通过后，为新生对象分配内存 -&gt; 内存分配完成，将内存空间都初始化为零值，不包括对象头 ：该操作保证对象的字段在java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值 -&gt; 对对象进行必要设置，如对象是哪个类实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息 -&gt; 执行<init>方法将对象进行意愿初始化(字节码中是否跟随invokespecial指令决定)。</init></p>
<a id="more"></a>
<h5 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h5><p>1、指针碰撞：java堆中内存是绝对规整的，所有用过的内存都放一边，空闲的内存放一边，中间放着一个指针作为分界点的指示器；此时分配内存就仅仅把指针向空闲空间那边移动对象大小相等的距离。</p>
<p>2、空闲列表：java堆中内存并不规整，已用和空闲内存相互交错，此时虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配内存的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表记录。</p>
<h5 id="java堆是否规整"><a href="#java堆是否规整" class="headerlink" title="java堆是否规整"></a>java堆是否规整</h5><p>由所采用的垃圾收集器是否带有压缩整理功能决定，即与采用具体的垃圾回收算法有关系。使用Serial、ParNew等带Compact过程等收集器时，系统采用指针碰撞；使用CMS这种基于Mark-Sweep算法等收集器时，通常采用空闲列表。</p>
<h5 id="内存分配中的并发处理"><a href="#内存分配中的并发处理" class="headerlink" title="内存分配中的并发处理"></a>内存分配中的并发处理</h5><p>1、对分配内存空间的动作进行同步处理—采用CAS配上失败重试的方式保证更新操作的原子性。</p>
<p>2、内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机使用TLAB配置：-XX:+/-UseTLAB 参数设定。</p>
<h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>对象的内存布局：对象头Header、实例数据Instance Data、对齐填充Padding。 </p>
<p>对象头：包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志等，这部分数据等长度在32位和64位的虚拟机中分别为32bit和64bit，官方称“Mark Word”。对象需要存储的运行时数据其实超过Mark Word，考虑到空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，根据对象状态复用自己存储空间。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个类型指针来确定这个对象属于哪个类的实例，注意查找对象的元数据信息并不一定要经过对象本身。如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为从数组的元数据中无法确定数组的大小。</p>
<p>实例数据部分：是对象真正存储的有效信息，即在程序代码中所定义的各种类型的字段内容，包括继承而来和自身定义的。存储顺序受虚拟机分配策略参数和字段在java源码中定义的顺序影响，相同宽度的字段总是被分配到一起。父类中定义的变量会出现在子类之前，CompactFields参数值为true（默认true），则子类中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<p>对齐填充：并不是必然存在的，并无特别意义，仅起着占位符的作用。HotSpot VM对象的大小必须是8字节的整数倍，而对象头部分正好是1倍或者2倍8字节，所以当对象实例数据部分没有对齐时，就需要对齐填充来补充。</p>
<h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>java程序需要通过栈上的reference数据来操作堆上的具体对象。</p>
<p>句柄访问：java堆中划分出一块内存来作为句柄，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体信息。优势：reference中存储的是稳定的句柄地址，在对象移动（垃圾收集时对象移动是非常普遍的行为）时只会改变句柄中的实例数据指针。如下图所示：</p>
<p><img src="/HotSpot虚拟机对象/通过句柄访问对象.png" alt="通过句柄访问对象"></p>
<p>直接指针访问：java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的就是对象地址。优势：速度更快，节省了一次指针定位的时间开销，但reference存储的地址信息则会改变。HotSpot使用。如下图所示：</p>
<p><img src="/HotSpot虚拟机对象/通过直接指针访问对象.png" alt="通过直接指针访问对象"></p>
<h4 id="OOM异常"><a href="#OOM异常" class="headerlink" title="OOM异常"></a>OOM异常</h4><h5 id="java堆溢出"><a href="#java堆溢出" class="headerlink" title="java堆溢出"></a>java堆溢出</h5><p>解决手段是先通过映像分析工具对Dump出来的堆转储快照<br>进行分析，判断是内存泄漏还是内存溢出。如果内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，即可定位到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。如果内存溢出，应当检查虚拟机堆参数(-Xmx与-Xms)，与机器物理内存对比是否还可以调大，从代码检查是否存在生命周期是否过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h5 id="虚拟机栈溢出"><a href="#虚拟机栈溢出" class="headerlink" title="虚拟机栈溢出"></a>虚拟机栈溢出</h5><p>HotSpot栈容量只由-Xss参数设置(-Xoss设置本地方法栈，但由于不区分，所以实际无效)。开发多线程的应用时特别注意，出现StackOverFlowError异常时有错误堆栈可以阅读，找到问题相对容易，使用虚拟机默认参数，栈深度在大多数情况下达到1000—2000 完全没问题，正常方法调用包括递归该深度完全够用。</p>
<p>重点：如果建立多线程导致内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，只能通过减少最大堆和减少栈容量来换取更多的线程。</p>
<h5 id="方法区异常-包括常量池"><a href="#方法区异常-包括常量池" class="headerlink" title="方法区异常(包括常量池)"></a>方法区异常(包括常量池)</h5><p>String.intern()作用：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的string对象，否则将此String对象包含的字符串添加到常量池，并返回此String对象的引用。</p>
<h5 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h5><p>DirectMemory容量可通过-XX: MaxDirectMemorySize = 10M指定，不指定则默认与java堆最大值一样。直接内存溢出的明显特征，Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序又直接或者间接使用了NIO，则可考虑检查是否直接内存溢出。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[java运行时数据区域]]></title>
      <url>https://glenen.github.io/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>文中所涉及内容均为java虚拟机相关，但由于java虚拟机团队也一直在改进和优化java虚拟机，其中有的内容可能会与后续版本有差异，所以文中内容仅提供参考，不可作为任何定义为任何标准的准则，敬请谅解。</p>
<p>本书作者前面用了很多篇幅描述java虚拟机及JDK的发展历史，此部分并没有做笔记，如需了解，请移步阅读原著即可。</p>
<h5 id="java优点"><a href="#java优点" class="headerlink" title="java优点"></a>java优点</h5><p>摆脱硬件平台束缚，一次编写到处运行；相对安全的内存管理与访问机制，避免内存泄漏与指针越界；热点代码检测和运行时编译及优化，java应用能随着运行时间的增加而获得更高的性能；拥有一套完善的API。</p>
<a id="more"></a>
<h5 id="java技术体系"><a href="#java技术体系" class="headerlink" title="java技术体系"></a>java技术体系</h5><p>java虚拟机：编译器与解释器。发展历史中出现过各种虚拟机。通用平台上运行的商用虚拟机：HotSpot ，JRockit ，J9。 特定硬件平台专用虚拟机：Azul VM  和  BEA Liquid VM。总结如下图所示：</p>
<p><img src="/java运行时数据区域/java技术体系.png" alt="java技术体系"></p>
<h5 id="java未来"><a href="#java未来" class="headerlink" title="java未来"></a>java未来</h5><p>模块化：解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。</p>
<p>混合语言编程：每种语言解决自己擅长的问题。</p>
<p>多核并行：多线程，充分利用CPU。进一步丰富语法及64位虚拟机</p>
<h4 id="java运行时数据区域"><a href="#java运行时数据区域" class="headerlink" title="java运行时数据区域"></a>java运行时数据区域</h4><p>java虚拟机在运行java程序时会把它所管理的内存划分为不同的数据区域，有的区域会随着虚拟机进程的启动而存在，有的则依赖于用户线程的启动和结束而创建和销毁。大体划分图如下：</p>
<p><img src="/java运行时数据区域/jvm运行时内存图.png" alt="jvm运行时内存图"></p>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>线程私有的一块较小内存空间，可以看作是当前线程所执行字节码的行号指示器。虚拟机的模型概念里，字节码解释器工作时就是通过改变程序计数器的值来选取下一条需要执行的字节码指令。</p>
<p>为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器且互不影响独立存储。程序计数器是唯一一个在java虚拟机规范中没有规定任何OutOFMemoryError情况的区域，如果线程正在执行一个java方法，则其记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，则其值为空。</p>
<h5 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h5><p>线程私有，生命周期与线程相同，其描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址），其在帧中的内存空间大小在编译期已确定，运行期不会改变其大小。</p>
<p>StackOverFlowError：线程请求的栈深度大于虚拟机所允许的栈深度；OutOFMemoryError：虚拟机动态扩展时无法申请到足够的内存。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>与虚拟机栈发挥到作用非常相似，但其为虚拟机使用到的Native方法服务。甚至有的虚拟机（HotSpot）将它们合二为一，也会抛出StackOverFlowError 和 OutOFMemoryError异常。</p>
<h5 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h5><p>内存管理最大的一块，被所有线程共享，在虚拟机启动时创建。其唯一目的就是存放对象实例及数组。java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。如果在堆中没有内存来完成实例分配且无法再扩展时，抛出OutOFMemoryError异常。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>与java堆一样，各线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。此区域的内存回收目标主要是针对常量池的回收和对类型的卸载，内存回收难但却必要。当其无法满足内存分配需求时，抛出OutOFMemoryError异常。</p>
<p>注：方法区是java虚拟机的规范，JDK1.7及以前版本，永久代是方法区的一个实现，但是JDK1.8后，hotspot移除了永久代，取而代之的是元空间，符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。元空间的本质和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</p>
<p>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<p>JDK1.8后的java内存模型大概如下图所示：</p>
<p><img src="/java运行时数据区域/JDK1.8 jvm运行时内存图.png" alt=""></p>
<h5 id="运行时常量区"><a href="#运行时常量区" class="headerlink" title="运行时常量区"></a>运行时常量区</h5><p>方法区的一部分，Class文件常量池用于存放编译期生成的各种字面量和符号引用。运行时常量池相对于Class文件常量池具有动态性，且每一部分的格式都没有严格规定。动态特性利用的比较多的是String  类的intern()方法。常量池无法再申请到内存时抛出OutOFMemoryError异常。</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>不属于虚拟机运行时数据区的一部分，也并非虚拟机规范中定义的内存区域。但该部分内存被频繁使用，且也可能导致OutOFMemoryError异常。NIO(New Input/output)类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，该种方式在一些场景中显著提高性能，因为避免了在java堆和Native堆中来回复制数据。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[韶华倾付]]></title>
      <url>https://glenen.github.io/%E9%9F%B6%E5%8D%8E%E5%80%BE%E4%BB%98/</url>
      <content type="html"><![CDATA[<p>情感此物很奇怪，总是会在生活里，慢慢忘记了回忆。</p>
<p>开始忘记，有那么一张脸，他最初走进我的世界，是以怎样的表情。<br>也许是在一个阳光明媚的午后。<br>也许是在一个风景秀丽的公园。<br>也许是在一座人声鼎沸的都市。<br>也许，你就这样带着来自幸福的期许。<br>如此翩翩舞动而来。</p>
<p><img src="/韶华倾付/timg-0.png" alt=""></p>
<a id="more"></a>
<p>爱的你，如今在一座据说很恐怖的城市独自工作和生活。<br>为了梦想，或者说为了生存，你留在了那里。<br>那座城市，也许只是你的一个想象。<br>它出现于一夜之间，像海市蜃楼一样虚幻而美丽。<br>你走得越近，就越看不清它。<br>你凝视着它，为它哭，为它笑。<br>久而久之，你终于发现，原来它只是你的一个影子。<br>偶有微光，照亮你前行的方向。</p>
<p><img src="/韶华倾付/timg-1.png" alt=""></p>
<p>自从你工作之后，诸多不易，诸多辛劳，即便不说，其实我也大略的知道。<br>然而，你给了我一个承诺，我就哪里都不会去，只是站在这里等着你。<br>恩爱两不疑，如此坚定和执着。</p>
<p>牵挂的人，未来已经在前方等着你。<br>请勇敢的去拥抱它。<br>别念过去，别畏将来。<br>我会是你最温暖的港湾。</p>
<p><img src="/韶华倾付/timg-2.png" alt=""></p>
<p>爱情许是最美好的感觉。<br>时光不会伤害它。<br>而它之于你我，不是肌肤之亲，也不是一蔬一饭。<br>它是一种不死的欲望，是平凡生活中的英雄梦想。<br>所以放心的去拼搏吧，站在你身后的，是永恒不变的我，和我的心。</p>
]]></content>
      
        <categories>
            
            <category> 心灵 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
