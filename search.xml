<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[一致性Hash算法]]></title>
      <url>https://glenen.github.io/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>本文所整理的一致性Hash算法，其原型和背景都离不开现代大型网站设计服务端的一个重要特性：伸缩性。</p>
<p>所谓网站的伸缩性，就是指在不需要改变网站的软硬件设计的前提下，仅仅通过改变部署的集群中的服务器数量就可以缩小或扩大网站的服务处理能力。一般而言，网站的伸缩性设计可分两类：1、根据功能进行物理分离实现伸缩；2、单一功能通过集群实现伸缩。前者是不同的服务器部署不同的服务，提供不同功能，后者是集群中的多台服务器部署相同的服务，提供相同的功能。通过对这两个方面的研究和处理，我们就可对网站整体实现富有弹性的伸缩性设计。</p>
<a id="more"></a>
<p>其实不管哪种伸缩类型，其都是一个网站在从建立到后面越来越庞大的过程中催生出的产物，如下图所示：</p>
<p><img src="/一致性Hash算法/物理分离实现服务器伸缩.png" alt=""></p>
<p>就揭示了网站在发展过程，我们为了应对服务器本身的处理能力瓶颈所采取的手段：将各种可单独分离的功能模块一步一步分离出来单独部署。但是随着网站的访问流量越来越大，单独部署功能模块的服务器有可能会出现负载过大而宕机的情况，其实也是必然会发生的，这时我们可能会采取的措施换一台处理能力更强的服务器，或者多添加一台服务器协同原服务器处理。我们都会选择后者处理方法，因为前者不能从根本解决问题：世界上不存在一台拥有无限处理能力的计算机。</p>
<p>集群的伸缩性设计，也可分为多种：1、应用服务器集群的伸缩设计；2、分布式缓存集群的伸缩设计；3、数据存储服务器的伸缩设计。每种伸缩设计采用的方式也不同，都需要根据其特点制定相应的可伸缩设计。本文所讲解的一致性Hash算法就是为了解决分布式缓存集群的伸缩设计。可能会有漏点，仅供参考。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="一般路由算法隐患"><a href="#一般路由算法隐患" class="headerlink" title="一般路由算法隐患"></a>一般路由算法隐患</h5><p>何为路由：简单理解就是我们通过缓存数据的Key，通过某种路由算法，计算得到存储数据服务器列表的下标，从而完成缓存数据Key到存储数据服务器的映射(自己理解，如有错误请谅解)。</p>
<p>其实就路由算法而言，以前大学时代数据结构课程就提及过较多：其通过路由算法得到的值越随机，越具有不可预测性，其就越适合作为Hash算法。一般简单的路由算法可以使用余数Hash：缓存数据Key除以服务器数量取余，该余数就是存放缓存数据的服务器编号。实际上，如果不考虑缓存服务器集群的伸缩性，余数Hash可以满足绝大多数的缓存路由需求。但是当缓存服务器集群需要扩容的时候，其弊端就会完全暴露出来。</p>
<p>如下列子：</p>
<p>现在我们需要将3台缓存服务器扩容至4台，扩容的服务器列表已改变，但是我们的路由算法仍然使用余数Hash，我们原来已存在的缓存数据<key, data="">，其key的Hash值为490806430，除以4余数为2，对应的服务器编号为2，我们去该服务器读取缓存数据，其结果也可想而知：必然失败。因为在集群为3台时，该缓存数据存储的服务器编号为1。</key,></p>
<p>很容易可看出，集群服务器数从3增至4时，大约会有75%(3/4)被缓存了的数据不能正确命中。且随着集群服务器规模的不断扩大，其不命中率会成线性上升：(N/(N + 1))。</p>
<p>当缓存数据绝大部份不能正确命中时候，就会从数据库获取数据，此时数据访问的压力就会落到数据库上，这导致超过数据库的负载能力，严重时可能会导致数据库宕机。这显然不是我们所能接受的：我们使用缓存的初衷是降低数据库的负载压力。</p>
<p>一种办法可以在网站访问量最少的时候扩容缓存服务器集群(哈哈，没错就是半夜)，然后通过模拟请求的方法逐渐预热缓存，使缓存服务器中的数据重新分配。但我们可以有更好的办法：那就是改进路由算法，使新加入的服务器不影响大部分缓存数据的命中。其就是今天的重点：一致性Hash算法。</p>
<h5 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h5><p>一致性Hash算法通过一个叫做一致性Hash环的数据结构实现Key到缓存服务器的映射。如下图所示：</p>
<p><img src="/一致性Hash算法/一致性Hash算法.png" alt=""></p>
<p>其具体算法过程：先构造一个长度为2^32的一致性Hash环，然后根据缓存服务器的放置在这个Hash环上。当需要根据缓存数据的Key值计算得到其Hash值，然后在Hash环上顺时针查找距离这个Key的Hash值最近的缓存服务器节点，其缓存数据就存在该服务器上，从而完成Key到服务器的Hash映射查找。</p>
<h4 id="添加服务器"><a href="#添加服务器" class="headerlink" title="添加服务器"></a>添加服务器</h4><h5 id="添加服务器处理"><a href="#添加服务器处理" class="headerlink" title="添加服务器处理"></a>添加服务器处理</h5><p>当缓存服务器集群需要扩容时候，只需要新加入的节点(Node4)的Hash值放入一致性Hash环中。因为Key是顺时针查找距离其最近的节点，所以新加入的服务器只会影响整个环中的一小段。如下图所示：key3 和 key5受影响。</p>
<p><img src="/一致性Hash算法/一致性Hash算法2.png" alt=""></p>
<p>图中key3 和 key5从原来的Node1重新计算到了Node4，但是原来的大部分缓存数据还是能正确命中。假设还是将集群服务器从3扩容至4台，原有缓存数据的命中概率大约有75%，远远高于余数Hash的25%，且随着集群规模的增大，原有缓存数据的命中率还会继续增加。虽然还是会有小部分数据不能正确命中，但因为这个比例足够小，所以当从数据库读取这些数据的时候也不会对数据库造成难以承受的负载压力。</p>
<h5 id="Hash环实现"><a href="#Hash环实现" class="headerlink" title="Hash环实现"></a>Hash环实现</h5><p>在我们的实际应用中，这个长度为2^32的一致性Hash环通常使用二叉查找树实现，Hash查找的实际过程是在二叉树中查找不小于查找数的最小值：服务器编号。当然这个二叉树最右边的叶子节点(最大值) 和 最左边的叶子节点(最小值)相连接，就构成了环。</p>
<h4 id="解决负载不均衡"><a href="#解决负载不均衡" class="headerlink" title="解决负载不均衡"></a>解决负载不均衡</h4><h5 id="一致性Hash算法隐患"><a href="#一致性Hash算法隐患" class="headerlink" title="一致性Hash算法隐患"></a>一致性Hash算法隐患</h5><p>如上增加服务器节点图所示：新加入的Node4只影响了原来的节点Node1，也就是说原来需要访问Node1的缓存数据现在被转移到了Node4(大约50%)。原来命中到Node2 和 Node3的缓存数据不受影响，此时就意味着Node2 和 Node3的缓存数据和访问压力是Node1 和 Node4的两倍。如果这4台机器的性能是一样的，那此种结果显然也不是我们所需要的。</p>
<h5 id="增加虚拟层"><a href="#增加虚拟层" class="headerlink" title="增加虚拟层"></a>增加虚拟层</h5><p>为了解决一致性Hash算法所带来的负载不均衡问题，我们通过使用虚拟层的手段：将每台缓存服务器虚拟为一组虚拟的缓存服务器，将虚拟服务器的Hash值放到Hash环上，Key先在环上找到虚拟服务器节点，再得到物理服务器信息。</p>
<p>其实添加虚拟层的方式在计算机领域中被广泛采用：1、计算机网络七层协议；2、计算机操作系统可看作计算机硬件的虚拟层；3、java虚拟机可看作操作系统的虚拟层等等。</p>
<p>这样新加入物理服务器节点时，将会把一组虚拟机节点加入环中。如果虚拟节点的数目足够多，这组虚拟节点将会影响同样多数目的已经在环上的虚拟节点，由于这些已存在的虚拟节点又对应不同的物理服务器。最终结果：新加入一台缓存服务器，将会较为均匀地影响原来集群中已经存在的所有服务器，换而言之就是分摊原有缓存服务器集群中所有服务器的一小部分负载。把新加入节点所造成的影响分摊给所有原有的服务器。如下图所示：</p>
<p><img src="/一致性Hash算法/虚拟节点的一致性Hash环.png" alt=""></p>
<p>图中新加入的Node4节点对应虚拟节点 n30  n31  n32，加入到一致性Hash环上后，影响 n01 、n12 、n22 三个虚拟节点，而这3个虚拟节点分别对应物理节点 Node1 、 Node2 、 Node3 。最终集群中加入一个节点，同时影响到了集群中已存在的三个物理节点。理想情况下，每个节点中不能被命中的数据为其缓存数据量的1/4 (N/(N + X)，N为原有物理节点数，X为新加入物理节点数)。即集群中已经被缓存数据有75%可被继续命中，和未使用虚拟节点的一致性Hash算法结果相同。</p>
<p>显然每个物理节点对应的虚拟节点越多，各个物理节点之间的负载越均衡，新加入的服务器对集群中已存在的服务器的影响越保持一致(也是一致性Hash这个名字的由来)。实践中，一台物理服务器对应多少个虚拟节点合适，太多会影响性能，太少会影响负载均衡。一般来说，根据大师们的经验值：150。 当然这个值还应该根据具体情况具体对待。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[java与线程]]></title>
      <url>https://glenen.github.io/java%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：总结可能会有瑕疵……仅供参考……看看就行……转载请注明出处。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分主要讲述java线程的底层实现，与系统级的线程的关系；还阐述了java线程的调度机制，以及java线程的五种状态的意义和相互转换。</p>
<a id="more"></a>
<h4 id="java与线程"><a href="#java与线程" class="headerlink" title="java与线程"></a>java与线程</h4><h5 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h5><p>使用内核线程(Kernel-Level Thread klt)实现—程序一般不直接使用内核线程，而是去使用内核线程的一种高级接口：轻量级进程(Light Weight Process  LWP)。轻量级进程和内核线程之间是1:1的关系。如下图所示：</p>
<p><img src="/java与线程/轻量级进程.png" alt=""></p>
<h5 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h5><p>狭义-完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。所有线程操作都需要用户程序自己处理。进程和用户线程之间是1:N的关系，如下图所示：</p>
<p><img src="/java与线程/用户线程.png" alt=""></p>
<h5 id="用户线程加轻量级进程混合实现"><a href="#用户线程加轻量级进程混合实现" class="headerlink" title="用户线程加轻量级进程混合实现"></a>用户线程加轻量级进程混合实现</h5><p>使用了用户线程加轻量级进程的混合实现，且用户线程和轻量级进程之间是N:M的关系，如下图所示：</p>
<p><img src="/java与线程/混合线程.png" alt=""></p>
<h4 id="java线程调度及状态"><a href="#java线程调度及状态" class="headerlink" title="java线程调度及状态"></a>java线程调度及状态</h4><h5 id="java线程调度"><a href="#java线程调度" class="headerlink" title="java线程调度"></a>java线程调度</h5><p>系统调度指系统为线程分配处理器使用权的过程。</p>
<p>协同式线程调度：线程的执行时间由线程本身控制，线程把自己工作做完后主动通知系统切换到另一个线程，简单而容易阻塞死。</p>
<p>抢占式线程调度：每个线程由系统分配时间，线程的切换不由线程本身决定，时间系统可控，不会阻塞，java  使用的调度方式。</p>
<h5 id="java线程状态"><a href="#java线程状态" class="headerlink" title="java线程状态"></a>java线程状态</h5><p>线程状态：新建：创建后尚未启动；</p>
<p>运行：可能正执行，或等待CPU分配时间；</p>
<p>无限期等待：不会被CPU分配执行时间，需等待被其他线程显式唤醒；</p>
<p>限期等待：不会被CPU分配执行时间，在一段时间后由系统自动唤醒；</p>
<p>阻塞：等待着获取到一个拍他锁，该事件将由另一个线程放弃这个锁时发生；</p>
<p>结束：已终止线程状态，线程已执行结束。</p>
<p>java线程之间的状态转换大致可如下图所示：</p>
<p><img src="/java与线程/线程状态转换关系.png" alt=""></p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mysql索引及算法原理]]></title>
      <url>https://glenen.github.io/Mysql%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p>
<p>文章主要内容分为两个部分。</p>
<a id="more"></a>
<p>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</p>
<p>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</p>
<h4 id="数据结构及算法原理"><a href="#数据结构及算法原理" class="headerlink" title="数据结构及算法原理"></a>数据结构及算法原理</h4><h5 id="索引本质"><a href="#索引本质" class="headerlink" title="索引本质"></a>索引本质</h5><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。</p>
<p>如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。如下图所示：</p>
<p><img src="/Mysql索引及算法原理/timg-0.png" alt=""></p>
<p>该图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)O(log2n)的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p>
<h4 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h4><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<p>d为大于1的一个正整数，称为B-Tree的度。</p>
<p>h为一个正整数，称为B-Tree的高度。</p>
<p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p>
<p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p>
<p>所有叶节点具有相同的深度，等于树高h。</p>
<p>key和指针互相间隔，节点两端是指针。</p>
<p>一个节点中的key从左到右非递减排列。</p>
<p>所有节点组成树结构。</p>
<p>每个指针要么为null，要么指向另外一个节点。</p>
<p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)v(key1)，其中v(key1)v(key1)为node的第一个key的值。</p>
<p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</p>
<p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。下图是一个d=2的B-Tree示意图：</p>
<p><img src="/Mysql索引及算法原理/timg-1.png" alt=""></p>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">BTree_Search(node, key) &#123;</div><div class="line">if(node == null) return null;</div><div class="line">foreach(node.key)</div><div class="line">&#123;</div><div class="line">if(node.key[i] == key) return node.data[i];</div><div class="line">if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node);</div><div class="line">&#125;</div><div class="line">return BTree_Search(point[i+1]-&gt;node);</div><div class="line">&#125;</div><div class="line">data = BTree_Search(root, my_key);</div></pre></td></tr></table></figure>
<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。</p>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<p>每个节点的指针上限为2d而不是2d+1。</p>
<p>内节点不存储data，只存储key；叶子节点不存储指针。</p>
<p>下图是一个简单的B+Tree示意：</p>
<p><img src="/Mysql索引及算法原理/timg-2.png" alt=""></p>
<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p>
<p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p>
<h5 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h5><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。如图所示：</p>
<p><img src="/Mysql索引及算法原理/timg-3.png" alt=""></p>
<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<h4 id="为什么使用B-Tree-和-B-Tree"><a href="#为什么使用B-Tree-和-B-Tree" class="headerlink" title="为什么使用B-Tree 和 B+Tree"></a>为什么使用B-Tree 和 B+Tree</h4><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<h5 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h5><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。如图所示：</p>
<p><img src="/Mysql索引及算法原理/timg-4.png" alt=""></p>
<p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p>
<p>主存的存取过程如下：</p>
<p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p>
<p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h5 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h5><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。下图展示了磁盘的整体结构：</p>
<p><img src="/Mysql索引及算法原理/timg-5.png" alt=""></p>
<p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。下图展示了一个磁盘的结构：</p>
<p><img src="/Mysql索引及算法原理/timg-6.png" alt=""></p>
<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<h5 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h5><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p>程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h5 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h5><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<p>Dmax=floor(pagesize/(keysize + datasize + pointsize))</p>
<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p>
<h4 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h4><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p>
<h5 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h5><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p>
<p><img src="/Mysql索引及算法原理/timg-7.png" alt=""></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="/Mysql索引及算法原理/timg-8.png" alt=""></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h5 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h5><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="/Mysql索引及算法原理/timg-9.png" alt=""></p>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><img src="/Mysql索引及算法原理/timg-10.png" alt=""></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h5 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h5><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p>
<p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p>
<p><img src="/Mysql索引及算法原理/timg-11.png" alt=""></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p>
<p><img src="/Mysql索引及算法原理/timg-12.png" alt=""></p>
<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p>注：本文摘取自<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a> 如需阅读更详细内容请移步原博。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper集群搭建]]></title>
      <url>https://glenen.github.io/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本文只会涉及zookeeper的单机安装和集群搭建，都是自己亲身经历搭建过程，不会涉及任何有关zookeeper原理、分布式算法及分布式锁如何实现等，因为我自己都没搞懂……前不久看了《从paxos到zookeeper》，看到paxos算法，也没仔细弄懂，就头晕转移到其他书籍了。以后如果有时间，会再回头去看看那本书，再把有关原理的东西贴上来。</p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>本次搭建集群的是两台机器，自己在公司内部申请的两个docker容器，系统环境是centos6.5。centos7不建议使用，并且好像默认开启了防火墙。因为公司内部申请的，所以申请时候就预装了部署项目所必需的一些环境，详情如下图所示：</p>
<a id="more"></a>
<p><img src="/zookeeper集群搭建/timg-0.png" alt=""></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。ZooKeeper 是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。ZooKeeper官网：<a href="http://zookeeper.apache.org/" target="_blank" rel="external">http://zookeeper.apache.org/</a></p>
<h4 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>ssh命令登陆到自己的申请的虚拟机，在根目录下新建了一个zookeeper文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[...]$ mkdir zookeeper</div><div class="line">[...]$ cd zookeeper</div><div class="line">[...]$ wget http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.9/</div><div class="line">[...]$ unzip zookeeper-3.4.9.tar.gz</div></pre></td></tr></table></figure>
<p>wget命令下载默认是占用全部网络带宽，所以我下载的时候还是很快的，关于该命令在使用时的一些设置，可自行查阅。至此，zookeeper已经下载并安装好了，以下就是进行一些集群所需的配置。</p>
<p>注：也可在自己本机上下载zookeeper压缩包，然后通过scp命令或者Filezilla工具传输到虚拟机，但解压后，进入../bin/目录后，会出现启动脚本是白色的，这是因为该文件没有执行权限，可通过<code>chmod *** ***.sh</code>命令修改文件权限即可。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>1、在zookeeper目录下，新建data文件数据目录和日志目录：<code>[...]$ mkdir data 和 [...]$ mkdir logs</code></p>
<p>2、进入conf目录，conf目录下修改文件名 zoo_sample.cfg 改为 zoo.cfg，编辑配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[...]$ cd zookeeper-3.4.9/conf</div><div class="line">[...]$ mv zoo_sample.cfg zoo.cfg</div><div class="line">[...]$ sudo vim zoo.cfg</div></pre></td></tr></table></figure>
<p>打开后如下图所示(该图是我配置好后的)：</p>
<p><img src="/zookeeper集群搭建/timg-1.png" alt=""></p>
<p><strong><em>tickTime</em></strong> = # Zookeeper服务器心跳时间，单位毫秒!</p>
<p><strong><em>initLimit</em></strong> = # 投票选举新leader的初始化时间!</p>
<p><strong><em>syncLimit</em></strong> = # Leader与Follower之间的最大响应时间单位，响应超过syncLimit*tickTime，Leader认为Follwer挂掉，从服务器列表中删除Follwer!</p>
<p><strong><em>dataDir</em></strong> = # 数据持久化路径!</p>
<p><strong><em>dataLogDir</em></strong> = # 日志保存路径  这个要自己新建，具体目录根据自己的实际情况为准!</p>
<p><strong><em>clientPort</em></strong> = # 连接端口！</p>
<p><strong><em>server.num</em></strong> = <em>*</em>:2888:3888，该处配置的是集群服务器的IP列表，有多少台就配置多少，别写错！</p>
<h5 id="新增myid文件"><a href="#新增myid文件" class="headerlink" title="新增myid文件"></a>新增myid文件</h5><p>进入我们刚才在zookeeper目录下新建的data文件夹，创建名为myid的文件：<code>[...]$ sudo vi myid</code>。切换至插入模式，匹配着zoo.cfg配置文件中的<strong><em>server.num</em></strong>中的num来填写。本服务器的IP对应的num值是多少，就把该num值写入myid文件中保存并退出即可。每台服务器都必需对应配置好。</p>
<h5 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h5><p>进入bin目录，该目录下有一系列启动脚本，每台都登陆启动即可。如下图所示：</p>
<p><img src="/zookeeper集群搭建/timg-2.png" alt=""></p>
<p>启动zookeeper服务器：<code>sudo ./zkServer.sh start</code></p>
<p>关闭zookeeper服务器：<code>sudo ./zkServer.sh stop</code></p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> zookeeper </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[内存分配策略]]></title>
      <url>https://glenen.github.io/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：总结可能会有瑕疵……仅供参考……看看就行……转载请注明出处。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>对象主要在堆上分配，但也有可能经过JIT编译后被拆散为标量类型并间接地栈上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。</p>
<a id="more"></a>
<h4 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h4><p>大多数情况下，对象在Eden区分配，当Eden没有足够空间进行分配时，虚拟机将发起一次Minor GC。Minor GC：指发生在新生代的垃圾回收动作，因为java对象大多都具有朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>Full GC：发生在老年代的GC，出现了Full GC，经常会伴随至少一次Minor GC，但并非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Full GC的策略选择过程。Full GC的速度一般会比Minor GC慢10倍以上。</p>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象指需要大量连续内存空间的java对象，最典型的就是那种很长的字符串以及数组。java虚拟机说：“比遇到一个大对象更加坏的消息就是遇到一群‘朝生夕死’的‘短命大对象’。所以写程序时应到避免”。</p>
<p>虚拟机提供了一个-XX:PretenureSizeThreshold参数(只对Serial和Par New有效)，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个对象年龄Age计数器，如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移到Survivor空间中，并且对象年龄设为1.对象在Survivor区每经历一次Minor GC年龄就增加一岁，当它年龄增加到一定程度(默认15岁，可通过-XX:MaxTenuringThreshold设置)，将会被晋升到老年代中。</p>
<h5 id="对象年龄判定"><a href="#对象年龄判定" class="headerlink" title="对象年龄判定"></a>对象年龄判定</h5><p>为了更好适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可直接进入老年代。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么可以确保Minor GC是安全的。</p>
<p>如果不成立，虚拟机会检查HandlePromotionfailure设置值是否允许担保失败，如果允许，那么会继续检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将会尝试着进行一次Minor GC，尽管这次Minor GC是冒险的。如果小于，或者HandlePromotionfailure设置不允许冒险，那这时也要改为进行一次了Full GC。</p>
<p>JDK 6后规则为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[垃圾收集器]]></title>
      <url>https://glenen.github.io/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：总结可能会有瑕疵……仅供参考……看看就行……转载请注明出处。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>如下图所示：展示了7种作用于不同分代的收集器，如果两个收集器之间有连线，则它们可以搭配使用。收集器所处的区域，则代表它属于新生代还是老年代收集器。</p>
<a id="more"></a>
<p><img src="/垃圾收集器/hotspot垃圾收集器.png" alt=""></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>最基本、发展历史最悠久的收集器。单线程收集器，其进行垃圾收集时，必须暂停其他工作线程，直到它收集结束。虚拟机运行在client模式下的默认新生代收集器。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>Serial收集器的多线程版本。是许多运行在Server模式下的虚拟机中首选的新生代收集器。在JDK1.5中与CMS搭配使用。默认开启的收集线程数与CPU的数量相等，可以使用-XX:ParallelGCThreads参数限制垃圾收集的线程数。</p>
<p>并行Parallel：多条垃圾收集线程并行工作，此时用户线程仍然处于等待状态。</p>
<p>并发Concurrent：用户线程与垃圾收集线程同时执行，不一定并行，可能会交替执行，用户程序继续执行，而垃圾收集线程运行于另一个CPU上。</p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>采用复制算法且并行的多线程收集器。其目标是达到一个可控制的吞吐量throughput = 运行用户代码时间／(运行用户代码时间 + 垃圾收集时间)。停顿时间越短越适合与用户交互的程序，良好的反应速度能提升用户体验，而高吞吐量可以高效的利用CPU时间，尽快完成程序的运算任务，适用于在后台计算而不需要太多交互的任务。</p>
<p>-XX:MaxGCPauseMillis参数：控制最大垃圾收集停顿时间，大于0的毫秒数；-XX:GCTimeRatio参数：直接设置吞吐量大小，大于0且小于100的整数，相当于吞吐量的倒数。其具有自适应调节策略，打开开关-XX:UseAdaptiveSizePolicy参数即可。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial收集器老年代版本，单线程收集器，使用“标记—整理”算法，主要在于给Client模式下的虚拟机使用。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel老年代版本，使用多线程和“标记—整理”算法。在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Sca收集器加Parallel Old收集器组合。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>一种以获取最短回收停顿时间为目标的收集器，采用“标记—清除算法”，主要用于互联网站或者B/S系统的服务端。</p>
<p>初始标记：仅仅标记GC Roots能直接关联到的对象，需要“Stop The World” —&gt;  并发标记：进行GC Roots Tracing过程 —&gt; 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间稍比初始标记长，远比并发标记短 —&gt; 并发清除。</p>
<p>缺点：1、对CPU资源非常敏感；2、无法处理浮动垃圾；3、产生大量空间碎片。</p>
<h4 id="G1-Garbge-First-收集器"><a href="#G1-Garbge-First-收集器" class="headerlink" title="G1(Garbge-First)收集器"></a>G1(Garbge-First)收集器</h4><p>当今收集器技术发展最前沿的成果之一，面向服务端应用的垃圾收集器。特点：1、并行与并发；2、分代收集；3、空间整合；4、可预测的停顿。此时堆内存布局：java堆划分为多个大小相等的独立区域Region，虽然还保留新生代和老年代概念，但新生代和老年代不再是物理隔离的，它们都是一部分Region(不需要连续)的集合。</p>
<h5 id="可预测的停顿时间模型"><a href="#可预测的停顿时间模型" class="headerlink" title="可预测的停顿时间模型"></a>可预测的停顿时间模型</h5><p>因为它可以有计划地避免在整个java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<h5 id="Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法"><a href="#Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法" class="headerlink" title="Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法"></a>Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法</h5><p>G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行垃圾回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<p>步骤：初始标记—并发标记—最终标记—筛选回收。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[垃圾回收策略]]></title>
      <url>https://glenen.github.io/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：总结可能会有瑕疵……仅供参考……看看就行……转载请注明出处。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分的主要内容是了解虚拟机如何判定对象的存活状态，采用什么样的垃圾回收算法和hotspot虚拟机垃圾回收的机制。</p>
<h4 id="判断对象是否存活算法"><a href="#判断对象是否存活算法" class="headerlink" title="判断对象是否存活算法"></a>判断对象是否存活算法</h4><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1，当引用失效时，计数器值减1，任何时刻计数器为0的对象就是不可能再被使用的。实现简单，判定效率高，很多应用案例。但java虚拟机并未使用该算法(很难解决对象之间相互循环引用的问题)。如下代码所示：</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 演示JVM没有通过计算计数算法来判断对象的存活：解决相互引用问题</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2016-12-27</div><div class="line"> */</div><div class="line">@SuppressWarnings(<span class="string">"all"</span>)</div><div class="line">public class ReferenceCountGCTest &#123;</div><div class="line"></div><div class="line">    private ReferenceCountGCTest instance = null;</div><div class="line">    private static final int _1MB = 1024 * 1024;</div><div class="line">    /**</div><div class="line">     * 该属性存在的意义是占用内存，以便能在GC日志中看清楚是否被回收过</div><div class="line">     */</div><div class="line">    private byte[] bigSize = new byte[2 * _1MB];</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">testGC</span></span>() &#123;</div><div class="line">        ReferenceCountGCTest A = new ReferenceCountGCTest();</div><div class="line">        ReferenceCountGCTest B = new ReferenceCountGCTest();</div><div class="line"></div><div class="line">        A.instance = B;</div><div class="line">        B.instance = A;</div><div class="line"></div><div class="line">        A = null;</div><div class="line">        B = null;</div><div class="line"></div><div class="line">        // 该处触发垃圾回收：观察GC日志变化</div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>java、C#使用，基本思路是通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。如下图所示：</p>
<p><img src="/垃圾回收策略/可达性分析算法.png" alt=""></p>
<p>图中7、8、9对象虽然之间相互引用，但是他们没有与“GC Roots”对象相关联，垃圾回收的时候会被回收，其他与引用链的对象则不会。</p>
<h5 id="java中可作为GC-Roots对象包括"><a href="#java中可作为GC-Roots对象包括" class="headerlink" title="java中可作为GC Roots对象包括"></a>java中可作为GC Roots对象包括</h5><p>1.虚拟机栈(栈帧中的本地变量表)中引用的对象；2.方法区中类静态属性引用的对象；3.方法区中常量引用的对象；4.本地方法栈中JNI(一般说Native方法)引用的对象。</p>
<h4 id="宣告对象死亡"><a href="#宣告对象死亡" class="headerlink" title="宣告对象死亡"></a>宣告对象死亡</h4><p>当根据可达性分析算法分析到该对象没有链接到“GC Roots”的引用链时，并不会真正的宣告该对象死亡。真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后，没有发现与GC Roots相连接的引用链，那它将会被第一次标记且进行一次筛选，筛选的条件是是此对象是否有必要执行finalize()方法。没有必要执行：1、对象没有覆盖该方法；2、该方法已被虚拟机调用过。如果有必要执行该方法，则对象会被放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它(触发但不承诺等待它运行结束)。</p>
<p>finalize()方法是对象逃脱死亡的最后一次机会(重新与引用链上的任何一个对象建立关联即可，如把自己(this关键字)赋值给某个类变量或者对象的成员变量)。稍后GC将对叫做F-Queue队列中的对象进行第二次小规模的标记(成功自救的移除“即将回收”的集合)。如下代码演示了对象逃逸：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * finalize()演示垃圾回收逃逸和回收</div><div class="line"> *</div><div class="line"> * &lt;p&gt;1.一个对象当要被回收的时候可以逃逸.&lt;br&gt;</div><div class="line"> * 2.一个对象只能有一次机会逃逸，因为finalize最多只能被系统调用一次.</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2016-12-29</div><div class="line"> */</div><div class="line">public class FinalizeEscapeGCTest &#123;</div><div class="line"></div><div class="line">    private static FinalizeEscapeGCTest SAVE_HOOK = null;</div><div class="line"></div><div class="line">    private void isAlive() &#123;</div><div class="line">        System.out.println(&quot;yes, i am still alive :)&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void finalize() throws Throwable &#123;</div><div class="line">        super.finalize();</div><div class="line">        System.out.println(&quot;method finalize executed...&quot;);</div><div class="line">        FinalizeEscapeGCTest.SAVE_HOOK = this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        SAVE_HOOK = new FinalizeEscapeGCTest();</div><div class="line">        /*the object escape at first*/</div><div class="line">        SAVE_HOOK = null;</div><div class="line">        System.gc();</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(500);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        if (SAVE_HOOK == null) &#123;</div><div class="line">            System.out.println(&quot;no, i am dead :(&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            SAVE_HOOK.isAlive();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /*the object escape for twice failed*/</div><div class="line">        SAVE_HOOK = null;</div><div class="line">        System.gc();</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(500);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        if (SAVE_HOOK == null) &#123;</div><div class="line">            System.out.println(&quot;no, i am dead :(&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            SAVE_HOOK.isAlive();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h5><p>运行代价昂贵、不确定性大、无法保证各个对象的调用顺序，其所能做的工作try-finally或其他方法能做更好更及时。</p>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>回收主要部分：废弃常量和无用的类。回收废弃常量与堆中对象的回收非常类似。判定无用的类：1、该类的所有的实例都已经被回收；2、加载该类的ClassLoader已经被回收；3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。无用类可以被回收，但不是必然被回收，HotSpot虚拟机提供-Xnoclassgc参数进行控制。</p>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h5><p>分为“标记”“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。问题：1、效率低，标记和清除两个过程都效率低；2、空间，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。如图所示：</p>
<p><img src="/垃圾回收策略/标记—清理算法.png" alt=""></p>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块地内存用完了，将还存活着地对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。优点：分配时不用考虑内存碎片，按顺序分配，实现简单，运行高效。代价：将内存缩小为了原来的一半，未免太高了点。</p>
<p>现代商业虚拟机都采用此种收集算法来回收新生代，IBM研究：新生代中的对象98%是“朝生夕死”的。HotSpot中，Eden与Survivor的大小比例为8:1，即新生代中可用的内存空间为新生代容量的90%。如图所示：</p>
<p><img src="/垃圾回收策略/复制算法.png" alt=""></p>
<h5 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h5><p>根据老年代的特点，提出了该算法，标记过程仍然与“标记—清除”算法一样，但后续步骤不是对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。如图所示：</p>
<p><img src="/垃圾回收策略/标记—整理算法.png" alt=""></p>
<h4 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h4><h5 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h5><p>可达性分析必须在一个能确保一致性的快照中进行，一致性：整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现出现分析过程中对象引用关系还在不断的变化，否则无法保证分析结果的准确性。该点是导致GC进行时必须停顿所有java执行线程的一个重要原因。</p>
<h5 id="HotSpot实现枚举"><a href="#HotSpot实现枚举" class="headerlink" title="HotSpot实现枚举"></a>HotSpot实现枚举</h5><p>使用一组称为OopMap的数据结构，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
<h5 id="安全点safepoint"><a href="#安全点safepoint" class="headerlink" title="安全点safepoint"></a>安全点safepoint</h5><p>HotSpot没有为每条指令都生成OopMap，只是在“特定位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都停顿下来开始GC，只有在到达安全点时才停止。safepoint选定标准：是否具有让程序长时间执行的特征。所以只有指令复用如方法调用、循环跳转、异常跳转等具有这些功能等指令才会产生safepoint。如何在GC发生时让所有线程都“跑”到最近的安全点上再停顿下来。</p>
<h5 id="主动式中断"><a href="#主动式中断" class="headerlink" title="主动式中断"></a>主动式中断</h5><p>当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时去轮询这个标志，发现中断标志为真时就自己挂起中断。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
<h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的safepoint。但是当线程处于Sleep或者Blocked状态，就无法响应JVM的中断请求，“走”到安全点地方去挂起中断，JVM也不可能等待线程重新被分配CPU时间。安全区域safe region：在一段代码片段中，引用关系不会发生变化。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树的Morris遍历]]></title>
      <url>https://glenen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84Morris%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本博文所设计内容均为本人亲自所著，为工作闲暇之余及大学时代所积累，涉及思路不会描述太仔细，仅供参考。</p>
<p>二叉树的递归遍历、借助栈数据结构遍历较简单，不做赘述，此处给出二叉树的最优遍历方法：Morris遍历，时间复杂度O(n)，空间复杂度O(1)。</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先给出一棵二叉树：</p>
<p><img src="/二叉树的Morris遍历/二叉树—Morris.png" alt="通"></p>
<p>如图所示，这树比较奇特，没啥别的，就是叶子节点多了些箭头指向自己上层的节点。平时叶子节点都是干干净净的，今天突然冒出来必然不是冒然的。今天我们就要运用这些箭头完成节点控制权的转移。</p>
<p>如我们所知，二叉树由上层节点向下层节点转移很容易，因为它有从父节点指向孩子节点的指针，但是孩子节点向父节点转移就没那么容易了—没有直接的指向指针。我们借助栈结构遍历时候，其实做的工作就是完成节点控制权的转移。但现在我们可以利用叶子节点那些大量指向Null的空闲指针来帮助我们完成其节点控制权的转移，从而完成二叉树的遍历。</p>
<p>此处给出大体方向，详细点的代码中注释，后序我选择放弃—因为难啊！</p>
<p>1.第一个目标！就是让整颗二叉树中的节点都过一把当头节点的隐，当然，前提是它得有孩子。</p>
<p>2.第二个目标！每个节点当头节点时，都让以它为头节点的左子树的最右边的叶子节点的right Null指针指向该头节点。</p>
<p>3.第三个目标！按照我们的意愿控制节点的控制权的转移。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 定义二叉树</div><div class="line"> */</div><div class="line">@Data</div><div class="line">public class Node &#123;</div><div class="line">   /**</div><div class="line">    * 节点值</div><div class="line">    */</div><div class="line">    private int dataValue;</div><div class="line">   /**</div><div class="line">    * 左孩子节点</div><div class="line">    */</div><div class="line">    private Node left;</div><div class="line">   /**</div><div class="line">    * 右孩子节点</div><div class="line">    */</div><div class="line">    private Node right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Morris 中序遍历</div><div class="line"> *</div><div class="line"> * @param 头节点</div><div class="line"> */</div><div class="line">public static void midTraversal(Node head) &#123;</div><div class="line">        <span class="keyword">if</span> (head == null) &#123;</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.print(<span class="string">"midTraversal:"</span>);</div><div class="line">            Node cur1 = head;</div><div class="line">            Node cur2 = null;</div><div class="line">            <span class="keyword">while</span> (cur1 != null) &#123;</div><div class="line">                cur2 = cur1.left;</div><div class="line">                <span class="keyword">if</span> (cur2 != null) &#123;</div><div class="line">                    // 找到每棵二叉树的左子树的最右叶子节点</div><div class="line">                    <span class="keyword">while</span> (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;</div><div class="line">                        cur2 = cur2.right;</div><div class="line">                    &#125;</div><div class="line">                    // 让该叶子节点的right Null指针指向其头节点</div><div class="line">                    <span class="keyword">if</span> (cur2.right == null) &#123;</div><div class="line">                        // 把以cur1为头节点的左子树最右节点的right空指针指向cur1</div><div class="line">                        cur2.right = cur1;</div><div class="line">                        // 控制权转移给它左孩子，继续寻找最右               </div><div class="line">                        // 叶子节点的right Null指针指向头节点的操作</div><div class="line">                        cur1 = cur1.left;</div><div class="line">                        <span class="built_in">continue</span>;</div><div class="line">                    // 还原以前的二叉树结构</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        cur2.right = null;</div><div class="line">                    &#125;</div><div class="line">                    System.out.print(cur1.dataValue + <span class="string">" "</span>);</div><div class="line">                    // 根据我们建立的right指针控制节点的转移</div><div class="line">                    cur1 = cur1.right;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">```  </div><div class="line"></div><div class="line">哈------------哈------------哈---------------哈-----------------哈</div><div class="line"></div><div class="line">``` bash</div><div class="line">/**</div><div class="line"> * Morris 先序遍历</div><div class="line"> *</div><div class="line"> * @param 头节点</div><div class="line"> */</div><div class="line">public static void preTraversal(Node head) &#123;</div><div class="line">        <span class="keyword">if</span> (head == null) &#123;</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            System.out.print(<span class="string">"preTraversal:"</span>);</div><div class="line">            Node cur1 = head;</div><div class="line">            Node cur2 = null;</div><div class="line">            <span class="keyword">while</span> (cur1 != null) &#123;</div><div class="line">                cur2 = cur1.left;</div><div class="line">                <span class="keyword">if</span> (cur2 != null) &#123;</div><div class="line">                    // 找到每棵二叉树的左子树的最右叶子节点</div><div class="line">                    <span class="keyword">while</span> (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;</div><div class="line">                        cur2 = cur2.right;</div><div class="line">                    &#125;</div><div class="line">                    // 让该叶子节点的right Null指针指向其头节点</div><div class="line">                    <span class="keyword">if</span> (cur2.right == null) &#123;</div><div class="line">                        // 把以cur1为头节点的左子树最右节点的right空指针指向cur1</div><div class="line">                        cur2.right = cur1;</div><div class="line">                        System.out.print(cur1.dataValue + <span class="string">" "</span>);</div><div class="line">                        <span class="built_in">continue</span>;</div><div class="line">                    // 还原以前的二叉树结构</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        cur2.right = null;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    // 根据我们建立的right指针控制节点的转移</div><div class="line">                    cur1 = cur1.right;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[可持久化数据结构]]></title>
      <url>https://glenen.github.io/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>When you hear the word persistence in programming, most often, you think of an application saving its data to some type of storage, such as a database, so that the data can be retrieved later when the application is run again. There is, however, another meaning for the word persistence when it is used to describe data structures, particularly those used in functional programming languages. In that context, a persistent data structure is a data structure capable of preserving the current version of itself when modified. In essence, a persistent data structure is immutable.</p>
<p>当你在编程过程中听到持久化这个单词的时候，大多数情况下，你会认为是应用程序将其数据为存储为某种类型的文件中，例如数据库，以便于以后当应用程序再次运行时能够从介质中重新获取数据。然而这里的持久化讲的是另外一个意思，用其来描述一种数据结构，通常会用在一些函数式的编程语言中。从这个意义上来讲，一个具有持久化能力的数据结构在其被修改后可以保存当前的状态，从本质上来说，这样的数据结构是不可改变类型（immutable）。</p>
<a id="more"></a>
<p>An example of a class that uses this type of persistence in the .NET Framework is the string class. Once a string object is created, it cannot be changed. Any operation that appears to change a string generates a new string instead. Thus, each version of a string object can be preserved. An advantage for a persistent class like the string class is that it basically gives you undo functionality built-in. As newer versions of a persistent object are created, older versions can be pushed onto a stack and popped off when you want to undo an operation. Another advantage is that because persistent data structures cannot change state, they are easier to reason about and are thread safe.</p>
<p>.NET Framework中的String类正好是使用了持久化能力的一个例子。一旦创建了一个String类型实例，它便不能被改变了，对于欲改变其值的任何操作都将被产生一个新的String对象，通过这样，每一个版本的String实例都将被驻留下来。这样的具有持久化特点的类型像String类型都内置了撤销（Undo）功能，当该对象的新一个版本产生的时候，旧版本将被压入栈中，如果需要执行撤销动作的时候，只需将旧版本从堆栈中取出。另外一个优点是由于可持久化数据类型不能更改其内部状态，很容易得知它是线程安全的。</p>
<p>There is an overhead that comes with persistent data structures, however. Each operation that changes a persistent data structure creates a new version of that data structure. This can involve a good deal of copying to create the new version. This cost can be mitigated to a large degree by reusing as much of the internal structure of the old version in creating a new one. I will explore this idea in making two common data structures persistent: the singly linked list and the binary tree, and describe a third data structure that combines the two. I will also describe several classes I have created that are persistent versions of some of the classes in the System.Collections namespace.</p>
<p>然而持久化的数据结构会带来一些开销，任何改变持久化数据结构的操作都将创建一个新的版本，这可能会涉及到大量的拷贝操作，通常我们可以通过重用旧版本对象的内部数据结构来创建一个新的对象，这种办法可以极大地降低拷贝操作所带来的消耗。我将会通过两个常用的数据结构来阐述这个思想：单向列表以及二叉树，然后通过这两个数据结构来组合第三个数据结构。同时我也会讲述System.Collection命名空间下面的那些持久化的类型。</p>
<h4 id="Persistent-Singly-Linked-Lists"><a href="#Persistent-Singly-Linked-Lists" class="headerlink" title="Persistent Singly Linked Lists"></a>Persistent Singly Linked Lists</h4><h4 id="持久化的单向链表"><a href="#持久化的单向链表" class="headerlink" title="持久化的单向链表"></a>持久化的单向链表</h4><p>The singly linked list is one of the most widely used data structures in programming. It consists of a series of nodes linked together one right after the other. Each node has a reference to the node that comes after it, and the last node in the list terminates with a null reference. To traverse a singly linked list, you begin at the head of the list and move from one node to the next until you have reached the node you are looking for or have reached the last node:</p>
<p>单向链表是一个在编程中使用非常广泛的基础数据结构，它是由一系列相互链接的节点组成。每一个节点都拥有一个指向下一个节点的引用，链表中的最后一个节点将拥有一个空引用。如果你想遍历一个单向链表，可以从第一个节点开始，逐个向后移动，直到到达最后的节点。如下图所示：</p>
<p><img src="/可持久化数据结构/LinkedList-0.png" alt=""></p>
<p>Let’s insert a new item into the list. This list is not persistent, meaning that it can be changed in-place without generating a new version. After taking a look at the insertion operation on a non-persistent list, we’ll look at the same operation on a persistent list.</p>
<p>让我们插入一个新的节点到这个链表中去，并且该链表是非持久化的，也就是说这个链表可以被改变而无需产生一个新的版本。在查看了非持久化链表的插入操作之后，我们将会查看同样的操作在持久化链表中。</p>
<p>Inserting a new item into a singly linked list involves creating a new node:</p>
<p>插入一个新的节点到单向列表中会涉及到创建一个新的节点：</p>
<p><img src="/可持久化数据结构/LinkedList-1.png" alt=""></p>
<p>We will insert the new node at the fourth position in the list. First, we traverse the list until we’ve reached that position. Then the node that will precede the new node is unlinked from the next node…</p>
<p>我们将会在第四个位置插入新的节点，第一我们遍历链表到达指定位置，也就是插入节点前面的那个节点，将其与后面节点断开。</p>
<p><img src="/可持久化数据结构/LinkedList-2.png" alt=""></p>
<p>…and relinked to the new node. The new node is, in turn, linked to the remaining nodes in the list:</p>
<p>然后链接该节点与待插入节点，在下来，链接新的节点与上一步剩余的节点。</p>
<p><img src="/可持久化数据结构/LinkedList-3.png" alt=""></p>
<p>Inserting a new item into a persistent singly linked list will not alter the existing list but create a new version with the item inserted into it. Instead of copying the entire list and then inserting the item into the copy, a better strategy is to reuse as much of the old list as possible. Since the nodes themselves are persistent, we don’t have to worry about aliasing problems.</p>
<p>如果插入一个新的节点到持久化的单向链表中，我们不应该改变当前链表的状态，而需要创建一个新的链表而后插入指定节点。相对于拷贝当前链表，而后插入指定节点，一个更好的策略是尽可能的重用旧的链表。因为节点本身是可持久化的，所以我们不必担心对象混淆的问题。</p>
<p>To insert a new node at the fourth position, we traverse the list as before only copying each node along the way. Each copied node is linked to the next copied node:</p>
<p>为了插入新节点到第四个位置，我们遍历链表到指定位置，拷贝每个遍历节点，同时指定拷贝的节点指向其下一个节点的拷贝。</p>
<p><img src="/可持久化数据结构/LinkedList-4.png" alt=""></p>
<p>The last copied node is linked to the new node, and the new node is linked to the remaining nodes in the old list:</p>
<p>最后一个拷贝的节点指向新的插入节点，而后，新节点指向旧链表剩下的节点。</p>
<p><img src="/可持久化数据结构/LinkedList-5.png" alt=""></p>
<p>On an average, about N/2 nodes will be copied in the persistent version for insertions and deletions, where N equals the number of nodes in the list. This isn’t terribly efficient but does give us some savings. One persistent data structure where this approach to singly linked list buys us a lot is the stack. Imagine the above data structure with insertions and deletions restricted to the head of the list. In this case, N nodes can be reused for pushing items onto a stack and N - 1 nodes can be reused for popping a stack.</p>
<p>平均来看，对于插入和删除操作，大约有N/2的节点将被拷贝，而N等于链表长度。这并不是特别的高效，仅仅只是节省了一些空间。与通过这样的方式来构建单向链表一样的一个数据结构是堆栈，我们可以想象一下在链表起始位置的插入以及删除操作，在这个场景中，对于堆栈来讲，压栈操作时全部节点都可以被重用，而出栈操作也有N-1个节点被重用。 </p>
<h4 id="Persistent-Binary-Trees"><a href="#Persistent-Binary-Trees" class="headerlink" title="Persistent Binary Trees"></a>Persistent Binary Trees</h4><h4 id="持久化二叉树"><a href="#持久化二叉树" class="headerlink" title="持久化二叉树"></a>持久化二叉树</h4><p>A binary tree is a collection of nodes in which each node contains two links, one to its left child and another to its right child. Each child is itself a node, and either or both of the child nodes can be null, meaning that a node may have zero to two children. In the binary search tree version, each node usually stores a key/value pair. The tree is searched and ordered according to its keys. The key stored at a node is always greater than the keys stored in its left descendents and always less than the keys stored in its right descendents. This makes searching for any particular key very fast.</p>
<p>一个二叉树是一系列节点的集合，每一个节点都包含有两个子节点，一个称之为左节点，而另一个称之为右节点。而子节点也是这样一个节点，也有一个左节点和一个右节点，当然也可以没有子节点，也就是说一个节点可能有零个或者两个子节点。在二叉查找树中，每一个节点通常包含了一个键值对，树结构将会依照节点的键来进行查找和组织。节点的键会永远大于其左节点的键，永远小于其右节点的键，这将使得对于特定键的查找非常迅速。</p>
<p>Here is an example of a binary search tree. The keys are listed as numbers; the values have been omitted but are assumed to exist. Notice how each key as you descend to the left is less than the key of its predecessor, and vice versa as you descend to the right:</p>
<p>下图是一个二叉查找树的例子，节点的键作为数字被列出，而节点的值则被忽略尽管是始终存在的。注意到每一个左边节点的键值一定会小于它的父节点即前驱节点，而每一个右边节点的键值一定大于其父节点键值。 </p>
<p><img src="/可持久化数据结构/PersistentTree-0.png" alt=""></p>
<p>Changing the value of a particular node in a non-persistent tree involves starting at the root of the tree and searching for a particular key associated with that value, and then changing the value once the node has been found. Changing a persistent tree, on the other hand, generates a new version of the tree. We will use the same strategy in implementing a persistent binary tree as we did for the persistent singly linked list, which is to reuse as much of the data structure as possible when making a new version.</p>
<p>如果在一个非持久化的树中更改一个特定节点的值，我们会从根节点按照特定键值开始搜索，如果找到则直接更改该节点的值。但是如果是在一个持久化的树上的话，换句话说，我们需要创建一个新版本的树，同时还需要保持同实现一个持久化的二叉树或者单向链表一样的策略，即尽可能的重用当前的数据来创建一个新的版本。</p>
<p>Let’s change the value stored in the node with the key 7. As the search for the key leads us down the tree, we copy each node along the way. If we descend to the left, we point the previously copied node’s left child to the currently copied node. The previous node’s right child continues to point to nodes in the older version. If we descend to the right, we do just the opposite.</p>
<p>下面让我们来尝试改变键为7的节点的值，按照自顶向下查找该节点的路径，我们需要拷贝该路径上的每一个节点。如果转向左边，需要将上一个拷贝的节点指向当前拷贝节点，而前一个节点的右侧节点则继续指向原来旧版本的节点。如果转向右边，则采用相反的做法。</p>
<p>This illustrates the “spine” of the search down the tree. The red nodes are the only nodes that need to be copied in making a new version of the tree:</p>
<p>下图列出了在树上自顶向下搜索特定节点的路径，在构建新版本的树的时候仅仅需要拷贝那些红色的节点。</p>
<p><img src="/可持久化数据结构/PersistentTree-1.png" alt=""></p>
<p>You can see that the majority of the nodes do not need to be copied. Assuming the binary tree is balanced, the number of nodes that need to be copied any time a write operation is performed is at most O(Log N), where Log is base 2. This is much more efficient than the persistent singly linked list.</p>
<p>你能够发现大多数节点是不要拷贝的，假定二叉树是平衡的，在每一次节点值的写操作中需要拷贝的节点数目大约是O（LogN），对数的底为2。显然比起持久化的单向链表效率很高。</p>
<p>Insertions and deletions work the same way, only steps should be taken to keep the tree in balance, such as using an AVL tree. If a binary tree becomes degenerate, we run into the same efficiency problems as we did with the singly linked list.</p>
<p>插入以及删除操作将按照同样的方式进行，但是一些额外的保持树平衡的操作还是必须的，例如使用AVL树作为底层数据结构的时候。如果二叉树变得很不平衡，我们将会碰到同样的效率问题如同在持久化单向链表是一样。</p>
<h4 id="Random-Access-Lists"><a href="#Random-Access-Lists" class="headerlink" title="Random Access Lists"></a>Random Access Lists</h4><h4 id="随机存取链表"><a href="#随机存取链表" class="headerlink" title="随机存取链表"></a>随机存取链表</h4><p>An interesting persistent data structure that combines the singly linked list with the binary tree is Chris Okasaki’s random-access list. This data structure allows for random access of its items as well as adding and removing items from the beginning of the list. It is structured as a singly linked list of completely balanced binary trees. The advantage of this data structure is that it allows access, insertion, and removal of the head of the list in O(1) time as well as provides logarithmic performance in randomly accessing its items.</p>
<p>一个比较有意思的持久化数据结构是Chris Okasaki的随机存取列表，它结合了单向链表和二叉树的特点。这个数据结构除了允许用户随机操作其节点外，还支持在列表的起始位置添加和删除节点。它被组织成为一个使用二叉树来平衡的单向链表，其优点是当在其起始位置进行节点操作时，只需要O(1)的复杂度，而在随机操作节点的时候，也只有O(Log(N)).</p>
<p>Here is a random-access list with 13 items:</p>
<p>下面是一个具有13个子节点的随机存取列表： </p>
<p><img src="/可持久化数据结构/RandomAccessList-0.png" alt=""></p>
<p>When a node is added to the list, the first two root nodes (if they exist) are checked to see if they both have the same height. If so, the new node is made the parent of the first two nodes; the current head of the list is made the left child of the new node, and the second root node is made the right child. If the first two root nodes do not have the same height, the new node is simply placed at the beginning of the list and linked to the next tree in the list.</p>
<p>当添加一个节点到列表中的时候，前两个根节点会被查看它们的高度是否相同，如果是的话，那新的节点将是这两个节点的父节点，第一个节点将会作为插入节点的左子节点，而第二个节点会作为右节点。而如果这两个节点高度不同，新的节将会直接被放在节点的起始位置，然后链接到剩余节点。</p>
<p>To remove the head of the list, the root node at the beginning of the list is removed, with its left child becoming the new head and its right child becoming the root of the second tree in the list. The new head of the list is right linked with the next root node in the list:</p>
<p>如果要删除链表的头节点，也就是要删除链表的起始根节点，然后将其左侧子节点作为新的头节点，而右侧子节点则作为链表中第个树的根节点。新的头节点会指向链表中向右的第二个根节点。</p>
<p><img src="/可持久化数据结构/RandomAccessList-1.png" alt=""></p>
<p>Keep in mind that all operations that change a random-access list do not change the existing list but rather generate a new version representing the change. As much of the old list is reused in creating a new version.</p>
<p>记住所有改变随机存取列表的操作都不会改变现有列表，而是创建一个新的版本，并且在创建新版本的时候要尽可能充用现有列表。</p>
<h4 id="Immutable-Collections"><a href="#Immutable-Collections" class="headerlink" title="Immutable Collections"></a>Immutable Collections</h4><h4 id="不可改变集合类型"><a href="#不可改变集合类型" class="headerlink" title="不可改变集合类型"></a>不可改变集合类型</h4><p>Included with this article are a number of persistent collection classes I have created. These classes are in a namespace called ImmutableCollections. I have created persistent versions of some of the collection classes in the System.Collections namespace. I will describe each one and some of the challenges in making them persistent. There are several collection classes that are currently missing; I need to add a queue, for example. Hopefully, I will get to those in time. Also, even though I’ve taken steps to make these classes efficient, they cannot compete with the System.Collections classes in terms of speed, but they really aren’t meant to. They are meant to provide the advantages of immutability while providing reasonable performance.</p>
<p>在本文中我创建了许多持久化的集合类型，放在命名空间ImmutableCollections下。对于System.Collection命名空间下的一些集合类，我也创建了一个持久化的版本。我将会逐个讲述这些类型，阐述在持久化这些类时所遇到的问题及挑战。当然有一些遗漏的，例如Queue。希望有时间我能够将它们补上。尽管我已经采取了一些措施来提高性能，在存取速度上这些类还是不能与System.Collection命名空间的类相比较，但是这些类具有不可变类型的优点，而且具有合理的可以接收的性能。</p>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>This one was easy. Simply create a persistent singly linked list and limit insertions and deletions to the head of the list. Since this class is persistent, popping a stack returns a new version of the stack with the next item in the old stack as the new top. In the System.Collections.Stack version, popping the stack returns the top of the stack. The question for the persistent version was how to make the top of the stack available since it cannot be returned when the stack is popped. I chose to create a Top property that represents the top of the stack.</p>
<p>这个类是比较容易的，可以创建一个持久化的单向链表，然后限定只能在起始位置进行插入和删除操作。因为这个类是持久化的，出栈操作将会返回一个新版本的堆栈，这个堆栈以旧堆栈的第二个节点为头节点。在System.Collection命名空间下，出栈操作仅仅只是删除栈顶元素并返回。</p>
<h5 id="SortedList"><a href="#SortedList" class="headerlink" title="SortedList"></a>SortedList</h5><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>The SortedList uses AVL tree algorithms to keep the tree in balance. I found it useful to create an IAvlNode interface. Two classes implement this interface, the AvlNode class and the NullAvlNode class. The NullAvlNode class implements the null object design pattern. This simplified many of the algorithms.</p>
<p>有序列表使用了AVL树的算法来保持树节点的平衡，我创建了一个叫IAvlNode的接口，有两个类实现了这个接口，它们分别是AvlNode以及NullAvlNode类。NullAvlNode类利用了Null对象的设计模式，这将会简化一些算法。</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><p>This is the class that proved most challenging. Like the SortedList, it uses a persistent AVL tree as its data structure. However, unlike the SortedList, items are accessed by index (or by position) rather than by key. I have to admit that the algorithms for accessing and inserting items in a binary tree by index weren’t intuitive to me, so I turned to Knuth. Specifically, I used Algorithms B and C in section 6.2.3 in volume 3 of The Art of Computer Programming.</p>
<p>这个类的实现会遇到更多的挑战。与有序列表相同的是它也使用了持久化的AVL树来作为其底层的数据结构，不同的地方是是用户只能通过顺序索引来操作列表元素而不是字符串索引。不得不说的是我的本意并不是在一个二叉树上按照顺序索引来操纵和插入列表元素，所以我查看了Knuth的书籍，准确地来讲是使用了计算机编程的艺术第三卷6.2.3中的算法B和C。</p>
<p>I made an assumption about the ArrayList in order to improve performance. I assumed that the Add method is by far the most used method. However, adding items to the ArrayList one right after the other causes a lot of tree rotations to keep the tree in balance. To solve this, I created a template tree that is already completely balanced. Since this template tree is immutable, it can exist at the class level and be shared amongst all of the instances of the class.</p>
<p>为了提高动态数组的性能，我做了一个假设。假定Add方法是动态数组使用最多的方法，然而为了保持树的平衡，添加对象操作会引起多次的树旋转。为了解决这个问题，我创建了一个完全平衡的模板树，因为这个树是不可更改的，它可以在类的级别上存在，且能够被所有类的实例所共享。</p>
<p>When an instance of the ArrayList class is created, it takes a small subtree of the template tree. As items are added, the nodes in the template tree are replaced with new nodes. Since the tree is completely balanced, no rebalancing is necessary. If the subtree gets filled up, another subtree of equal height is taken from the template tree and joined to the existing tree. Insertions and deletions are handled normally with rebalancing performed if necessary. Again, the assumption is that adding items to the ArrayList occurs much more frequently than inserting or deleting items.</p>
<p>当一个动态数组的实例被创建的时候，它会抓住模板树的一个子树。当添加子节点的时候，模板树上的节点将会被新添的节点所替换，因为模板树本身就是平衡的，所以无需平衡树的操作。如果这个子树已经被填满，则会在模板树上抓取高度相同的另外一个子树，然后加入当前存在的树。当然插入和删除操作就需要进行平衡操作了。再一次强调的是我们的假设是添加节点的操作会远多于插入以及删除操作，才可以这样做。</p>
<h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>The Array class uses the random access list structure to provide a persistent array with logarithmic performance. Unlike a random access list, it has a fixed size.</p>
<p>数组类使用随机存取列表作为基础的数据结构，而随机存取列表在进行查找的时候只有Log（N）的复杂度，与随机存取列表不同的是，数据具有固定的长度。</p>
<h5 id="RandomAccessList"><a href="#RandomAccessList" class="headerlink" title="RandomAccessList"></a>RandomAccessList</h5><h5 id="随机存取列表"><a href="#随机存取列表" class="headerlink" title="随机存取列表"></a>随机存取列表</h5><p>This class does not have a parallel in the System.Collections namespace, but it was one of the first persistent classes I wrote, and I decided to include it here. It’s a straightforward implementation of Chris Okasaki’s random-access list described above. This data structure was designed to be used in functional languages where lists have three basic operations: Cons, Head, and Tail. Cons adds an item to the head of the list, Head is the first item in the list, and Tail represents all of the items in the list except for the Head.</p>
<p>这个类型在.NET类库的System.Collection命名空间下没有对应的实现类，但是它是我写的第一个持久化类，所以我决定在这里也介绍一下。在Chris Okasaki的文章中有一个简单易懂的实现，在一些函数式语言中会经常用到这个数据结构，通常它有三个基本操作：Cons，Head和Tail，Cons会添加一个新的对象到这个列表对象的开头，而Head将会返回列表的第一个对象，通过Tail会得到列表中除了第一个对象外的所有对象。</p>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>Persistent data structures help simplify programming by eliminating a whole class of bugs associated with side-effects and synchronization issues. They are not a cure-all but are a useful tool for helping a programmer deal with complexity. I have explored ways of making data structures persistent and have provided a small .NET library of persistent data structures. I hope you have enjoyed the article, and as always, I welcome feedback.</p>
<p>持久化数据结构会有助于简化编程，将一些线程同步的问题消除掉。它并不是解救一切的灵丹妙药，而是帮助程序员减低程序复杂度的一个工具。我已经阐述了如何构建持久化数据的多种方法，并且打包成一个小的.NET类库。我希望你能够从本文中受益，并且永远欢迎您的反馈信息。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p>本帖转载自：<a href="http://www.cnblogs.com/tedzhao/archive/2008/11/12/1332112.html" target="_blank" rel="external">http://www.cnblogs.com/tedzhao/archive/2008/11/12/1332112.html</a></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HotSpot虚拟机对象]]></title>
      <url>https://glenen.github.io/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：总结可能会有瑕疵……仅供参考……看看就行……转载请注明出处。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分的主要内容是了解虚拟机中的数据以及它们是如何创建、如何布局、如何访问的。</p>
<h4 id="hotspot虚拟机对象"><a href="#hotspot虚拟机对象" class="headerlink" title="hotspot虚拟机对象"></a>hotspot虚拟机对象</h4><h5 id="对象的创建步骤"><a href="#对象的创建步骤" class="headerlink" title="对象的创建步骤"></a>对象的创建步骤</h5><p>虚拟机遇到一条new指令 -&gt; 检查这个指令的参数是否能在常量池中定位到一个类的符号引用 -&gt; 检查这个符号引用代表的类是否已被加载、解析和初始化过 -&gt; 检查都通过后，为新生对象分配内存 -&gt; 内存分配完成，将内存空间都初始化为零值，不包括对象头 ：该操作保证对象的字段在java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值 -&gt; 对对象进行必要设置，如对象是哪个类实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息 -&gt; 执行<init>方法将对象进行意愿初始化(字节码中是否跟随invokespecial指令决定)。</init></p>
<a id="more"></a>
<h5 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h5><p>1、指针碰撞：java堆中内存是绝对规整的，所有用过的内存都放一边，空闲的内存放一边，中间放着一个指针作为分界点的指示器；此时分配内存就仅仅把指针向空闲空间那边移动对象大小相等的距离。</p>
<p>2、空闲列表：java堆中内存并不规整，已用和空闲内存相互交错，此时虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配内存的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表记录。</p>
<h5 id="java堆是否规整"><a href="#java堆是否规整" class="headerlink" title="java堆是否规整"></a>java堆是否规整</h5><p>由所采用的垃圾收集器是否带有压缩整理功能决定，即与采用具体的垃圾回收算法有关系。使用Serial、ParNew等带Compact过程等收集器时，系统采用指针碰撞；使用CMS这种基于Mark-Sweep算法等收集器时，通常采用空闲列表。</p>
<h5 id="内存分配中的并发处理"><a href="#内存分配中的并发处理" class="headerlink" title="内存分配中的并发处理"></a>内存分配中的并发处理</h5><p>1、对分配内存空间的动作进行同步处理—采用CAS配上失败重试的方式保证更新操作的原子性。</p>
<p>2、内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机使用TLAB配置：-XX:+/-UseTLAB 参数设定。</p>
<h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>对象的内存布局：对象头Header、实例数据Instance Data、对齐填充Padding。 </p>
<p>对象头：包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志等，这部分数据等长度在32位和64位的虚拟机中分别为32bit和64bit，官方称“Mark Word”。对象需要存储的运行时数据其实超过Mark Word，考虑到空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，根据对象状态复用自己存储空间。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个类型指针来确定这个对象属于哪个类的实例，注意查找对象的元数据信息并不一定要经过对象本身。如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为从数组的元数据中无法确定数组的大小。</p>
<p>实例数据部分：是对象真正存储的有效信息，即在程序代码中所定义的各种类型的字段内容，包括继承而来和自身定义的。存储顺序受虚拟机分配策略参数和字段在java源码中定义的顺序影响，相同宽度的字段总是被分配到一起。父类中定义的变量会出现在子类之前，CompactFields参数值为true（默认true），则子类中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<p>对齐填充：并不是必然存在的，并无特别意义，仅起着占位符的作用。HotSpot VM对象的大小必须是8字节的整数倍，而对象头部分正好是1倍或者2倍8字节，所以当对象实例数据部分没有对齐时，就需要对齐填充来补充。</p>
<h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>java程序需要通过栈上的reference数据来操作堆上的具体对象。</p>
<p>句柄访问：java堆中划分出一块内存来作为句柄，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体信息。优势：reference中存储的是稳定的句柄地址，在对象移动（垃圾收集时对象移动是非常普遍的行为）时只会改变句柄中的实例数据指针。如下图所示：</p>
<p><img src="/HotSpot虚拟机对象/通过句柄访问对象.png" alt="通过句柄访问对象"></p>
<p>直接指针访问：java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的就是对象地址。优势：速度更快，节省了一次指针定位的时间开销，但reference存储的地址信息则会改变。HotSpot使用。如下图所示：</p>
<p><img src="/HotSpot虚拟机对象/通过直接指针访问对象.png" alt="通过直接指针访问对象"></p>
<h4 id="OOM异常"><a href="#OOM异常" class="headerlink" title="OOM异常"></a>OOM异常</h4><h5 id="java堆溢出"><a href="#java堆溢出" class="headerlink" title="java堆溢出"></a>java堆溢出</h5><p>解决手段是先通过映像分析工具对Dump出来的堆转储快照<br>进行分析，判断是内存泄漏还是内存溢出。如果内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，即可定位到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。如果内存溢出，应当检查虚拟机堆参数(-Xmx与-Xms)，与机器物理内存对比是否还可以调大，从代码检查是否存在生命周期是否过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h5 id="虚拟机栈溢出"><a href="#虚拟机栈溢出" class="headerlink" title="虚拟机栈溢出"></a>虚拟机栈溢出</h5><p>HotSpot栈容量只由-Xss参数设置(-Xoss设置本地方法栈，但由于不区分，所以实际无效)。开发多线程的应用时特别注意，出现StackOverFlowError异常时有错误堆栈可以阅读，找到问题相对容易，使用虚拟机默认参数，栈深度在大多数情况下达到1000—2000 完全没问题，正常方法调用包括递归该深度完全够用。</p>
<p>重点：如果建立多线程导致内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，只能通过减少最大堆和减少栈容量来换取更多的线程。</p>
<h5 id="方法区异常-包括常量池"><a href="#方法区异常-包括常量池" class="headerlink" title="方法区异常(包括常量池)"></a>方法区异常(包括常量池)</h5><p>String.intern()作用：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的string对象，否则将此String对象包含的字符串添加到常量池，并返回此String对象的引用。</p>
<h5 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h5><p>DirectMemory容量可通过-XX: MaxDirectMemorySize = 10M指定，不指定则默认与java堆最大值一样。直接内存溢出的明显特征，Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序又直接或者间接使用了NIO，则可考虑检查是否直接内存溢出。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[java运行时数据区域]]></title>
      <url>https://glenen.github.io/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：总结可能会有瑕疵……仅供参考……看看就行……转载请注明出处。</p>
<p>本书作者前面用了很多篇幅描述java虚拟机及JDK的发展历史，此部分并没有做笔记，如需了解，请移步阅读原著即可。</p>
<h5 id="java优点"><a href="#java优点" class="headerlink" title="java优点"></a>java优点</h5><p>摆脱硬件平台束缚，一次编写到处运行；相对安全的内存管理与访问机制，避免内存泄漏与指针越界；热点代码检测和运行时编译及优化，java应用能随着运行时间的增加而获得更高的性能；拥有一套完善的API。</p>
<a id="more"></a>
<h5 id="java技术体系"><a href="#java技术体系" class="headerlink" title="java技术体系"></a>java技术体系</h5><p>java虚拟机：编译器与解释器。发展历史中出现过各种虚拟机。通用平台上运行的商用虚拟机：HotSpot ，JRockit ，J9。 特定硬件平台专用虚拟机：Azul VM  和  BEA Liquid VM。总结如下图所示：</p>
<p><img src="/java运行时数据区域/java技术体系.png" alt="java技术体系"></p>
<h5 id="java未来"><a href="#java未来" class="headerlink" title="java未来"></a>java未来</h5><p>模块化：解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。</p>
<p>混合语言编程：每种语言解决自己擅长的问题。</p>
<p>多核并行：多线程，充分利用CPU。进一步丰富语法及64位虚拟机</p>
<h4 id="java运行时数据区域"><a href="#java运行时数据区域" class="headerlink" title="java运行时数据区域"></a>java运行时数据区域</h4><p>java虚拟机在运行java程序时会把它所管理的内存划分为不同的数据区域，有的区域会随着虚拟机进程的启动而存在，有的则依赖于用户线程的启动和结束而创建和销毁。大体划分图如下：</p>
<p><img src="/java运行时数据区域/jvm运行时内存图.png" alt="jvm运行时内存图"></p>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>线程私有的一块较小内存空间，可以看作是当前线程所执行字节码的行号指示器。虚拟机的模型概念里，字节码解释器工作时就是通过改变程序计数器的值来选取下一条需要执行的字节码指令。</p>
<p>为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器且互不影响独立存储。程序计数器是唯一一个在java虚拟机规范中没有规定任何OutOFMemoryError情况的区域，如果线程正在执行一个java方法，则其记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，则其值为空。</p>
<h5 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h5><p>线程私有，生命周期与线程相同，其描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址），其在帧中的内存空间大小在编译期已确定，运行期不会改变其大小。</p>
<p>StackOverFlowError：线程请求的栈深度大于虚拟机所允许的栈深度；OutOFMemoryError：虚拟机动态扩展时无法申请到足够的内存。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>与虚拟机栈发挥到作用非常相似，但其为虚拟机使用到的Native方法服务。甚至有的虚拟机（HotSpot）将它们合二为一，也会抛出StackOverFlowError 和 OutOFMemoryError异常。</p>
<h5 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h5><p>内存管理最大的一块，被所有线程共享，在虚拟机启动时创建。其唯一目的就是存放对象实例及数组。java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。如果在堆中没有内存来完成实例分配且无法再扩展时，抛出OutOFMemoryError异常。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>与java堆一样，各线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。此区域的内存回收目标主要是针对常量池的回收和对类型的卸载，内存回收难但却必要。当其无法满足内存分配需求时，抛出OutOFMemoryError异常。</p>
<p>注：方法区是java虚拟机的规范，JDK1.7及以前版本，永久代是方法区的一个实现，但是JDK1.8后，hotspot移除了永久代，取而代之的是元空间，符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。元空间的本质和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</p>
<p>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<p>JDK1.8后的java内存模型大概如下图所示：</p>
<p><img src="/java运行时数据区域/JDK1.8 jvm运行时内存图.png" alt=""></p>
<h5 id="运行时常量区"><a href="#运行时常量区" class="headerlink" title="运行时常量区"></a>运行时常量区</h5><p>方法区的一部分，Class文件常量池用于存放编译期生成的各种字面量和符号引用。运行时常量池相对于Class文件常量池具有动态性，且每一部分的格式都没有严格规定。动态特性利用的比较多的是String  类的intern()方法。常量池无法再申请到内存时抛出OutOFMemoryError异常。</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>不属于虚拟机运行时数据区的一部分，也并非虚拟机规范中定义的内存区域。但该部分内存被频繁使用，且也可能导致OutOFMemoryError异常。NIO(New Input/output)类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，该种方式在一些场景中显著提高性能，因为避免了在java堆和Native堆中来回复制数据。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[韶华倾付]]></title>
      <url>https://glenen.github.io/%E9%9F%B6%E5%8D%8E%E5%80%BE%E4%BB%98/</url>
      <content type="html"><![CDATA[<p>情感此物很奇怪，总是会在生活里，慢慢忘记了回忆。</p>
<p>开始忘记，有那么一张脸，他最初走进我的世界，是以怎样的表情。<br>也许是在一个阳光明媚的午后。<br>也许是在一个风景秀丽的公园。<br>也许是在一座人声鼎沸的都市。<br>也许，你就这样带着来自幸福的期许。<br>如此翩翩舞动而来。</p>
<p><img src="/韶华倾付/timg-0.png" alt=""></p>
<a id="more"></a>
<p>爱的你，如今在一座据说很恐怖的城市独自工作和生活。<br>为了梦想，或者说为了生存，你留在了那里。<br>那座城市，也许只是你的一个想象。<br>它出现于一夜之间，像海市蜃楼一样虚幻而美丽。<br>你走得越近，就越看不清它。<br>你凝视着它，为它哭，为它笑。<br>久而久之，你终于发现，原来它只是你的一个影子。<br>偶有微光，照亮你前行的方向。</p>
<p><img src="/韶华倾付/timg-1.png" alt=""></p>
<p>自从你工作之后，诸多不易，诸多辛劳，即便不说，其实我也大略的知道。<br>然而，你给了我一个承诺，我就哪里都不会去，只是站在这里等着你。<br>恩爱两不疑，如此坚定和执着。</p>
<p>牵挂的人，未来已经在前方等着你。<br>请勇敢的去拥抱它。<br>别念过去，别畏将来。<br>我会是你最温暖的港湾。</p>
<p><img src="/韶华倾付/timg-2.png" alt=""></p>
<p>爱情许是最美好的感觉。<br>时光不会伤害它。<br>而它之于你我，不是肌肤之亲，也不是一蔬一饭。<br>它是一种不死的欲望，是平凡生活中的英雄梦想。<br>所以放心的去拼搏吧，站在你身后的，是永恒不变的我，和我的心。</p>
]]></content>
      
        <categories>
            
            <category> 心灵 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
