<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[zookeeper集群搭建]]></title>
      <url>https://glenen.github.io/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本文只会涉及zookeeper的单机安装和集群搭建，都是自己亲身经历搭建过程，不会涉及任何有关zookeeper原理、分布式算法及分布式锁如何实现等，因为我自己都没搞懂……前不久看了《从paxos到zookeeper》，看到paxos算法，也没仔细弄懂，就头晕转移到其他书籍了。以后如果有时间，会再回头去看看那本书，再把有关原理的东西贴上来。</p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>本次搭建集群的是两台机器，自己在公司内部申请的两个docker容器，系统环境是centos6.5。centos7不建议使用，并且好像默认开启了防火墙。因为公司内部申请的，所以申请时候就预装了部署项目所必需的一些环境，详情如下图所示：</p>
<a id="more"></a>
<p><img src="/zookeeper集群搭建/timg-0.png" alt=""></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。ZooKeeper 是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。ZooKeeper官网：<a href="http://zookeeper.apache.org/" target="_blank" rel="external">http://zookeeper.apache.org/</a></p>
<h4 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>ssh命令登陆到自己的申请的虚拟机，在根目录下新建了一个zookeeper文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[...]$ mkdir zookeeper</div><div class="line">[...]$ cd zookeeper</div><div class="line">[...]$ wget http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.9/</div><div class="line">[...]$ unzip zookeeper-3.4.9.tar.gz</div></pre></td></tr></table></figure>
<p>wget命令下载默认是占用全部网络带宽，所以我下载的时候还是很快的，关于该命令在使用时的一些设置，可自行查阅。至此，zookeeper已经下载并安装好了，以下就是进行一些集群所需的配置。</p>
<p>注：也可在自己本机上下载zookeeper压缩包，然后通过scp命令或者Filezilla工具传输到虚拟机，但解压后，进入../bin/目录后，会出现启动脚本是白色的，这是因为该文件没有执行权限，可通过<code>chmod *** ***.sh</code>命令修改文件权限即可。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>1、在zookeeper目录下，新建data文件数据目录和日志目录：<code>[...]$ mkdir data 和 [...]$ mkdir logs</code></p>
<p>2、进入conf目录，conf目录下修改文件名 zoo_sample.cfg 改为 zoo.cfg，编辑配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[...]$ cd zookeeper-3.4.9/conf</div><div class="line">[...]$ mv zoo_sample.cfg zoo.cfg</div><div class="line">[...]$ sudo vim zoo.cfg</div></pre></td></tr></table></figure>
<p>打开后如下图所示(改图是我配置好后的)：</p>
<p><img src="/zookeeper集群搭建/timg-1.png" alt=""></p>
<p><strong><em>tickTime</em></strong> = # Zookeeper服务器心跳时间，单位毫秒!</p>
<p><strong><em>initLimit</em></strong> = # 投票选举新leader的初始化时间!</p>
<p><strong><em>syncLimit</em></strong> = # Leader与Follower之间的最大响应时间单位，响应超过syncLimit*tickTime，Leader认为Follwer挂掉，从服务器列表中删除Follwer!</p>
<p><strong><em>dataDir</em></strong> = # 数据持久化路径!</p>
<p><strong><em>dataLogDir</em></strong> = # 日志保存路径  这个要自己新建，具体目录根据自己的实际情况为准!</p>
<p><strong><em>clientPort</em></strong> = # 连接端口！</p>
<p><strong><em>server.num</em></strong> = <em>*</em>:2888:3888，该处配置的是集群服务器的IP列表，有多少台就配置多少，别写错！</p>
<h5 id="新增myid文件"><a href="#新增myid文件" class="headerlink" title="新增myid文件"></a>新增myid文件</h5><p>进入我们刚才在zookeeper目录下新建的data文件夹，创建名为myid的文件：<code>[...]$ sudo vi myid</code>。切换至插入模式，匹配着zoo.cfg配置文件中的<strong><em>server.num</em></strong>中的num来填写。本服务器的IP对应的num值是多少，就把该num值写入myid文件中保存并退出即可。每台服务器都必需对应配置好。</p>
<h5 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h5><p>进入bin目录，该目录下有一系列启动脚本，每台都登陆启动即可。如下图所示：</p>
<p><img src="/zookeeper集群搭建/timg-2.png" alt=""></p>
<p>启动zookeeper服务器：<code>sudo ./zkServer.sh start</code></p>
<p>关闭zookeeper服务器：<code>sudo ./zkServer.sh stop</code></p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> zookeeper </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[内存分配策略]]></title>
      <url>https://glenen.github.io/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本博文所有内容均为本人阅读《深入理解java虚拟机：jvm高级特性与最佳实践》书时所记，所用图也是亲笔所画。转载请注明出处，仅供参考。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>对象主要在堆上分配，但也有可能经过JIT编译后被拆散为标量类型并间接地栈上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。</p>
<a id="more"></a>
<h4 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h4><p>大多数情况下，对象在Eden区分配，当Eden没有足够空间进行分配时，虚拟机将发起一次Minor GC。Minor GC：指发生在新生代的垃圾回收动作，因为java对象大多都具有朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>Full GC：发生在老年代的GC，出现了Full GC，经常会伴随至少一次Minor GC，但并非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Full GC的策略选择过程。Full GC的速度一般会比Minor GC慢10倍以上。</p>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象指需要大量连续内存空间的java对象，最典型的就是那种很长的字符串以及数组。java虚拟机说：“比遇到一个大对象更加坏的消息就是遇到一群‘朝生夕死’的‘短命大对象’。所以写程序时应到避免”。</p>
<p>虚拟机提供了一个-XX:PretenureSizeThreshold参数(只对Serial和Par New有效)，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个对象年龄Age计数器，如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移到Survivor空间中，并且对象年龄设为1.对象在Survivor区每经历一次Minor GC年龄就增加一岁，当它年龄增加到一定程度(默认15岁，可通过-XX:MaxTenuringThreshold设置)，将会被晋升到老年代中。</p>
<h5 id="对象年龄判定"><a href="#对象年龄判定" class="headerlink" title="对象年龄判定"></a>对象年龄判定</h5><p>为了更好适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可直接进入老年代。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么可以确保Minor GC是安全的。</p>
<p>如果不成立，虚拟机会检查HandlePromotionfailure设置值是否允许担保失败，如果允许，那么会继续检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将会尝试着进行一次Minor GC，尽管这次Minor GC是冒险的。如果小于，或者HandlePromotionfailure设置不允许冒险，那这时也要改为进行一次了Full GC。</p>
<p>JDK 6后规则为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[垃圾收集器]]></title>
      <url>https://glenen.github.io/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本博文所有内容均为本人阅读《深入理解java虚拟机：jvm高级特性与最佳实践》书时所记，所用图也是亲笔所画。转载请注明出处，仅供参考。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>如下图所示：展示了7种作用于不同分代的收集器，如果两个收集器之间有连线，则它们可以搭配使用。收集器所处的区域，则代表它属于新生代还是老年代收集器。</p>
<a id="more"></a>
<p><img src="/垃圾收集器/hotspot垃圾收集器.png" alt=""></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>最基本、发展历史最悠久的收集器。单线程收集器，其进行垃圾收集时，必须暂停其他工作线程，直到它收集结束。虚拟机运行在client模式下的默认新生代收集器。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>Serial收集器的多线程版本。是许多运行在Server模式下的虚拟机中首选的新生代收集器。在JDK1.5中与CMS搭配使用。默认开启的收集线程数与CPU的数量相等，可以使用-XX:ParallelGCThreads参数限制垃圾收集的线程数。</p>
<p>并行Parallel：多条垃圾收集线程并行工作，此时用户线程仍然处于等待状态。</p>
<p>并发Concurrent：用户线程与垃圾收集线程同时执行，不一定并行，可能会交替执行，用户程序继续执行，而垃圾收集线程运行于另一个CPU上。</p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>采用复制算法且并行的多线程收集器。其目标是达到一个可控制的吞吐量throughput = 运行用户代码时间／(运行用户代码时间 + 垃圾收集时间)。停顿时间越短越适合与用户交互的程序，良好的反应速度能提升用户体验，而高吞吐量可以高效的利用CPU时间，尽快完成程序的运算任务，适用于在后台计算而不需要太多交互的任务。</p>
<p>-XX:MaxGCPauseMillis参数：控制最大垃圾收集停顿时间，大于0的毫秒数；-XX:GCTimeRatio参数：直接设置吞吐量大小，大于0且小于100的整数，相当于吞吐量的倒数。其具有自适应调节策略，打开开关-XX:UseAdaptiveSizePolicy参数即可。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial收集器老年代版本，单线程收集器，使用“标记—整理”算法，主要在于给Client模式下的虚拟机使用。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel老年代版本，使用多线程和“标记—整理”算法。在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Sca收集器加Parallel Old收集器组合。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>一种以获取最短回收停顿时间为目标的收集器，采用“标记—清除算法”，主要用于互联网站或者B/S系统的服务端。</p>
<p>初始标记：仅仅标记GC Roots能直接关联到的对象，需要“Stop The World” —&gt;  并发标记：进行GC Roots Tracing过程 —&gt; 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间稍比初始标记长，远比并发标记短 —&gt; 并发清除。</p>
<p>缺点：1、对CPU资源非常敏感；2、无法处理浮动垃圾；3、产生大量空间碎片。</p>
<h4 id="G1-Garbge-First-收集器"><a href="#G1-Garbge-First-收集器" class="headerlink" title="G1(Garbge-First)收集器"></a>G1(Garbge-First)收集器</h4><p>当今收集器技术发展最前沿的成果之一，面向服务端应用的垃圾收集器。特点：1、并行与并发；2、分代收集；3、空间整合；4、可预测的停顿。此时堆内存布局：java堆划分为多个大小相等的独立区域Region，虽然还保留新生代和老年代概念，但新生代和老年代不再是物理隔离的，它们都是一部分Region(不需要连续)的集合。</p>
<h5 id="可预测的停顿时间模型"><a href="#可预测的停顿时间模型" class="headerlink" title="可预测的停顿时间模型"></a>可预测的停顿时间模型</h5><p>因为它可以有计划地避免在整个java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<h5 id="Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法"><a href="#Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法" class="headerlink" title="Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法"></a>Region之间对象引用及其他收集器中新生代与老年代的对象引用解决办法</h5><p>G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行垃圾回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<p>步骤：初始标记—并发标记—最终标记—筛选回收。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[垃圾回收策略]]></title>
      <url>https://glenen.github.io/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本博文所有内容均为本人阅读《深入理解java虚拟机：jvm高级特性与最佳实践》书时所记，所用图也是亲笔所画。转载请注明出处，仅供参考。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分的主要内容是了解虚拟机如何判定对象的存活状态，采用什么样的垃圾回收算法和hotspot虚拟机垃圾回收的机制。</p>
<h4 id="判断对象是否存活算法"><a href="#判断对象是否存活算法" class="headerlink" title="判断对象是否存活算法"></a>判断对象是否存活算法</h4><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1，当引用失效时，计数器值减1，任何时刻计数器为0的对象就是不可能再被使用的。实现简单，判定效率高，很多应用案例。但java虚拟机并未使用该算法(很难解决对象之间相互循环引用的问题)。如下代码所示：</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 演示JVM没有通过计算计数算法来判断对象的存活：解决相互引用问题</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2016-12-27</div><div class="line"> */</div><div class="line">@SuppressWarnings(<span class="string">"all"</span>)</div><div class="line">public class ReferenceCountGCTest &#123;</div><div class="line"></div><div class="line">    private ReferenceCountGCTest instance = null;</div><div class="line">    private static final int _1MB = 1024 * 1024;</div><div class="line">    /**</div><div class="line">     * 该属性存在的意义是占用内存，以便能在GC日志中看清楚是否被回收过</div><div class="line">     */</div><div class="line">    private byte[] bigSize = new byte[2 * _1MB];</div><div class="line"></div><div class="line">    public static void <span class="function"><span class="title">testGC</span></span>() &#123;</div><div class="line">        ReferenceCountGCTest A = new ReferenceCountGCTest();</div><div class="line">        ReferenceCountGCTest B = new ReferenceCountGCTest();</div><div class="line"></div><div class="line">        A.instance = B;</div><div class="line">        B.instance = A;</div><div class="line"></div><div class="line">        A = null;</div><div class="line">        B = null;</div><div class="line"></div><div class="line">        // 该处触发垃圾回收：观察GC日志变化</div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>java、C#使用，基本思路是通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。如下图所示：</p>
<p><img src="/垃圾回收策略/可达性分析算法.png" alt=""></p>
<p>图中7、8、9对象虽然之间相互引用，但是他们没有与“GC Roots”对象相关联，垃圾回收的时候会被回收，其他与引用链的对象则不会。</p>
<h5 id="java中可作为GC-Roots对象包括"><a href="#java中可作为GC-Roots对象包括" class="headerlink" title="java中可作为GC Roots对象包括"></a>java中可作为GC Roots对象包括</h5><p>1.虚拟机栈(栈帧中的本地变量表)中引用的对象；2.方法区中类静态属性引用的对象；3.方法区中常量引用的对象；4.本地方法栈中JNI(一般说Native方法)引用的对象。</p>
<h4 id="宣告对象死亡"><a href="#宣告对象死亡" class="headerlink" title="宣告对象死亡"></a>宣告对象死亡</h4><p>当根据可达性分析算法分析到该对象没有链接到“GC Roots”的引用链时，并不会真正的宣告该对象死亡。真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后，没有发现与GC Roots相连接的引用链，那它将会被第一次标记且进行一次筛选，筛选的条件是是此对象是否有必要执行finalize()方法。没有必要执行：1、对象没有覆盖该方法；2、该方法已被虚拟机调用过。如果有必要执行该方法，则对象会被放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它(触发但不承诺等待它运行结束)。</p>
<p>finalize()方法是对象逃脱死亡的最后一次机会(重新与引用链上的任何一个对象建立关联即可，如把自己(this关键字)赋值给某个类变量或者对象的成员变量)。稍后GC将对叫做F-Queue队列中的对象进行第二次小规模的标记(成功自救的移除“即将回收”的集合)。如下代码演示了对象逃逸：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * finalize()演示垃圾回收逃逸和回收</div><div class="line"> *</div><div class="line"> * &lt;p&gt;1.一个对象当要被回收的时候可以逃逸.&lt;br&gt;</div><div class="line"> * 2.一个对象只能有一次机会逃逸，因为finalize最多只能被系统调用一次.</div><div class="line"> *</div><div class="line"> * @author Glenn</div><div class="line"> * @since 2016-12-29</div><div class="line"> */</div><div class="line">public class FinalizeEscapeGCTest &#123;</div><div class="line"></div><div class="line">    private static FinalizeEscapeGCTest SAVE_HOOK = null;</div><div class="line"></div><div class="line">    private void isAlive() &#123;</div><div class="line">        System.out.println(&quot;yes, i am still alive :)&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void finalize() throws Throwable &#123;</div><div class="line">        super.finalize();</div><div class="line">        System.out.println(&quot;method finalize executed...&quot;);</div><div class="line">        FinalizeEscapeGCTest.SAVE_HOOK = this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        SAVE_HOOK = new FinalizeEscapeGCTest();</div><div class="line">        /*the object escape at first*/</div><div class="line">        SAVE_HOOK = null;</div><div class="line">        System.gc();</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(500);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        if (SAVE_HOOK == null) &#123;</div><div class="line">            System.out.println(&quot;no, i am dead :(&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            SAVE_HOOK.isAlive();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /*the object escape for twice failed*/</div><div class="line">        SAVE_HOOK = null;</div><div class="line">        System.gc();</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(500);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        if (SAVE_HOOK == null) &#123;</div><div class="line">            System.out.println(&quot;no, i am dead :(&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            SAVE_HOOK.isAlive();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h5><p>运行代价昂贵、不确定性大、无法保证各个对象的调用顺序，其所能做的工作try-finally或其他方法能做更好更及时。</p>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>回收主要部分：废弃常量和无用的类。回收废弃常量与堆中对象的回收非常类似。判定无用的类：1、该类的所有的实例都已经被回收；2、加载该类的ClassLoader已经被回收；3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。无用类可以被回收，但不是必然被回收，HotSpot虚拟机提供-Xnoclassgc参数进行控制。</p>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h5><p>分为“标记”“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。问题：1、效率低，标记和清除两个过程都效率低；2、空间，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。如图所示：</p>
<p><img src="/垃圾回收策略/标记—清理算法.png" alt=""></p>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块地内存用完了，将还存活着地对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。优点：分配时不用考虑内存碎片，按顺序分配，实现简单，运行高效。代价：将内存缩小为了原来的一半，未免太高了点。</p>
<p>现代商业虚拟机都采用此种收集算法来回收新生代，IBM研究：新生代中的对象98%是“朝生夕死”的。HotSpot中，Eden与Survivor的大小比例为8:1，即新生代中可用的内存空间为新生代容量的90%。如图所示：</p>
<p><img src="/垃圾回收策略/复制算法.png" alt=""></p>
<h5 id="标记—整理算法"><a href="#标记—整理算法" class="headerlink" title="标记—整理算法"></a>标记—整理算法</h5><p>根据老年代的特点，提出了该算法，标记过程仍然与“标记—清除”算法一样，但后续步骤不是对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。如图所示：</p>
<p><img src="/垃圾回收策略/标记—整理算法.png" alt=""></p>
<h4 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h4><h5 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h5><p>可达性分析必须在一个能确保一致性的快照中进行，一致性：整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现出现分析过程中对象引用关系还在不断的变化，否则无法保证分析结果的准确性。该点是导致GC进行时必须停顿所有java执行线程的一个重要原因。</p>
<h5 id="HotSpot实现枚举"><a href="#HotSpot实现枚举" class="headerlink" title="HotSpot实现枚举"></a>HotSpot实现枚举</h5><p>使用一组称为OopMap的数据结构，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
<h5 id="安全点safepoint"><a href="#安全点safepoint" class="headerlink" title="安全点safepoint"></a>安全点safepoint</h5><p>HotSpot没有为每条指令都生成OopMap，只是在“特定位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都停顿下来开始GC，只有在到达安全点时才停止。safepoint选定标准：是否具有让程序长时间执行的特征。所以只有指令复用如方法调用、循环跳转、异常跳转等具有这些功能等指令才会产生safepoint。如何在GC发生时让所有线程都“跑”到最近的安全点上再停顿下来。</p>
<h5 id="主动式中断"><a href="#主动式中断" class="headerlink" title="主动式中断"></a>主动式中断</h5><p>当GC需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个标志，各个线程执行时去轮询这个标志，发现中断标志为真时就自己挂起中断。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
<h5 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h5><p>safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的safepoint。但是当线程处于Sleep或者Blocked状态，就无法响应JVM的中断请求，“走”到安全点地方去挂起中断，JVM也不可能等待线程重新被分配CPU时间。安全区域safe region：在一段代码片段中，引用关系不会发生变化。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树遍历—Morris遍历]]></title>
      <url>https://glenen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E2%80%94Morris%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本博文所设计内容均为本人亲自所著，为工作闲暇之余及大学时代所积累，涉及思路不会描述太仔细，仅供参考。</p>
<p>上篇博文运用了借助栈数据结构的方式实现了二叉树的先、中、后序遍历，但也提及了此方法并不是最佳的遍历方式，因为它的空间复杂度还可以从O(h)继续优化，不言而喻，比该空间复杂度更优的基本就是O(1)了。嗯，是的，那就是俗称Morris的遍历。</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先给出一棵二叉树：</p>
<p><img src="/二叉树遍历—Morris遍历/二叉树—Morris.png" alt="通"></p>
<p>如图所示，这树比较奇特，没啥别的，就是叶子节点多了些箭头指向自己上层的节点。平时叶子节点都是干干净净的，今天突然冒出来必然不是冒然的。今天我们就要运用这些箭头完成节点控制权的转移。</p>
<p>如我们所知，二叉树由上层节点向下层节点转移很容易，因为它有从父节点指向孩子节点的指针，但是孩子节点向父节点转移就没那么容易了—没有直接的指向指针。我们借助栈结构遍历时候，其实做的工作就是完成节点控制权的转移。但现在我们可以利用叶子节点那些大量指向Null的空闲指针来帮助我们完成其节点控制权的转移，从而完成二叉树的遍历。</p>
<p>此处给出大体方向，详细点的代码中注释，后序我选择放弃—因为难啊！</p>
<p>1.第一个目标！就是让整颗二叉树中的节点都过一把当头节点的隐，当然，前提是它得有孩子。</p>
<p>2.第二个目标！每个节点当头节点时，都让以它为头节点的左子树的最右边的叶子节点的right Null指针指向该头节点。</p>
<p>3.第三个目标！按照我们的意愿控制节点的控制权的转移。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="bash">/**
 * Morris 中序遍历
 *
 * @param 头节点
 */
public static void midTraversal(Node head) {
        <span class="keyword">if</span> (head == null) {
            <span class="built_in">return</span>;
        } <span class="keyword">else</span> {
            System.out.print(<span class="string">"midTraversal:"</span>);
            Node cur1 = head;
            Node cur2 = null;
            <span class="keyword">while</span> (cur1 != null) {
                cur2 = cur1.left;
                <span class="keyword">if</span> (cur2 != null) {
                    // 找到每棵二叉树的左子树的最右叶子节点
                    <span class="keyword">while</span> (cur2.right != null &amp;&amp; cur2.right != cur1) {
                        cur2 = cur2.right;
                    }
                    // 让该叶子节点的right Null指针指向其头节点
                    <span class="keyword">if</span> (cur2.right == null) {
                        // 把以cur1为头节点的左子树最右节点的right空指针指向cur1
                        cur2.right = cur1;
                        // 控制权转移给它左孩子，继续寻找最右               
                        // 叶子节点的right Null指针指向头节点的操作
                        cur1 = cur1.left;
                        <span class="built_in">continue</span>;
                    // 还原以前的二叉树结构
                    } <span class="keyword">else</span> {
                        cur2.right = null;
                    }
                    System.out.print(cur1.dataValue + <span class="string">" "</span>);
                    // 根据我们建立的right指针控制节点的转移
                    cur1 = cur1.right;
                }
            }
        }
        System.out.println();
    }
</code></pre>
<pre><code class="bash">/**
 * Morris 先序遍历
 *
 * @param 头节点
 */
public static void preTraversal(Node head) {
        <span class="keyword">if</span> (head == null) {
            <span class="built_in">return</span>;
        } <span class="keyword">else</span> {
            System.out.print(<span class="string">"preTraversal:"</span>);
            Node cur1 = head;
            Node cur2 = null;
            <span class="keyword">while</span> (cur1 != null) {
                cur2 = cur1.left;
                <span class="keyword">if</span> (cur2 != null) {
                    // 找到每棵二叉树的左子树的最右叶子节点
                    <span class="keyword">while</span> (cur2.right != null &amp;&amp; cur2.right != cur1) {
                        cur2 = cur2.right;
                    }
                    // 让该叶子节点的right Null指针指向其头节点
                    <span class="keyword">if</span> (cur2.right == null) {
                        // 把以cur1为头节点的左子树最右节点的right空指针指向cur1
                        cur2.right = cur1;
                        System.out.print(cur1.dataValue + <span class="string">" "</span>);
                        <span class="built_in">continue</span>;
                    // 还原以前的二叉树结构
                    } <span class="keyword">else</span> {
                        cur2.right = null;
                    }
                } <span class="keyword">else</span> {
                    // 根据我们建立的right指针控制节点的转移
                    cur1 = cur1.right;
                }
            }
        }
        System.out.println();
    }
</code></pre>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> 二叉树 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[日常总结—1]]></title>
      <url>https://glenen.github.io/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93%E2%80%941/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>该总结属于原理性总结，根据自身状况而总结，并非详细总结。转载请注明出处，仅供参考。</p>
<h4 id="注解annotation"><a href="#注解annotation" class="headerlink" title="注解annotation"></a>注解annotation</h4><h5 id="annotation原理"><a href="#annotation原理" class="headerlink" title="annotation原理"></a>annotation原理</h5><p>一种元数据，即描述数据的数据。注解就是一个继承自‘java.lang.annotation.Annotation’的接口，java通过动态代理的方式为你生成了一个实现了“接口”的实例（对于当前的实体来说，例如类、方法、属性域等，这个代理对象是单例的），然后对该代理实例的属性赋值，这样就可以在程序运行时（如果将注解设置为运行时可见的话）通过反射获取到注解的配置信息。注解的属性设置是在编译时就确定了的，通过CLHSDB在eden区找到注解实例。类型<code>com/sun/proxy/$Proxy1</code>是JDK动态代理生成对象时的默认类型，其中<code>com.sun.proxy</code>是默认的包名，定义于<code>ReflectUtil</code>类的<code>PROXY_PACKAGE</code>字段中。代理类名<code>$PROXY1</code>包含两部分，其中前缀<code>$PROXY</code>是JDK种默认的代理类类名前缀，后的1是自增的结果。</p>
<a id="more"></a>
<h5 id="自定义annotation"><a href="#自定义annotation" class="headerlink" title="自定义annotation"></a>自定义annotation</h5><p>4个用于描述自定义注解的注解：1.@Target  2.@Retention  3.@Documented  4.@Inherited。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Target(ElementType.METHOD)</div><div class="line">@Retention(RetentionPolicy.SOURCE)</div><div class="line">public @interface Override&#123;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数据库索引-分类及创建索引原则略"><a href="#数据库索引-分类及创建索引原则略" class="headerlink" title="数据库索引(分类及创建索引原则略)"></a>数据库索引(分类及创建索引原则略)</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。</p>
<h5 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h5><p>优点：1:创建唯一性索引，可以保证数据库表中每一行数据的唯一性  2:大大加快数据的检索速度（主要）  3: 加速表和表之间的连接  4:使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能  等等。</p>
<p>缺点：1: 创建索引和维护索引要耗费时间  2: 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大  3: 对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<h5 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h5><p>局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中 。</p>
<p>磁盘预读：磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数。</p>
<p>B-Tree索引：根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<h4 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>悲观锁：数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。</p>
<p>乐观锁：相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>悲观锁：往往依靠数据库提供的锁机制(也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据)。</p>
<p>乐观锁：大多是基于数据版本(Version)记录机制实现。即为数据增加一个版本标识(只要是可以用来作为判断的字段都行)，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。本质还是通过CAS(compare and swap)机制完成，包括JDK中的原子类的各种操作都是CAS处理并发(各种封装的根本还是Unsafe类)，防止数据脏读。</p>
<h5 id="mysql几个有用sql语句"><a href="#mysql几个有用sql语句" class="headerlink" title="mysql几个有用sql语句"></a>mysql几个有用sql语句</h5><p>Select…For Update: 该语句用来锁定特定的行（如果有where子句，就是满足where条件的那些行）。当这些行被锁定后，其他会话可以选择这些行，但不能更改或删除这些行，直到该语句的事务被commit语句或rollback语句结束为止(和SELECT … LOCK IN SHARE MODE类似)。</p>
<p>insert ignore into…：插入数据，根据主键或者唯一索引判断记录是否存在，不存在则插入，存在则忽略，以警告形式返回。</p>
<p>insert into…on duplicate key update…：插入时根据主键或者唯一索引判断记录是否存在，不存在则插入，存在则更新指定字段的内容，其他字段不变。</p>
<p>replace into：根据主键或者唯一索引判断记录，不存在，则插入，没有赋值的字段，插入后该字段为空，存在则先删除记录再插入。</p>
<p>insert into…select…where not exist：根据select的条件判断是否插入，不止可以通过主键或者唯一索引，还可通过其他条件。</p>
<h4 id="重定向与转发"><a href="#重定向与转发" class="headerlink" title="重定向与转发"></a>重定向与转发</h4><h5 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h5><p>重定向：重定向是客户端行为，客户浏览器发送http请求——&gt;web服务器接受后发送302状态码响应及对应新的location给客户浏览器——&gt;客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址——&gt;服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。在重定向的过程中，传输的信息会被丢失。</p>
<p>转发：转发是服务器行为。客户浏览器发送http请求——&gt;web服务器接受此请求——&gt;调用内部的一个方法在容器内部完成请求处理和转发动作——&gt;将目标资源发送给客户；在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。传输的信息不会丢失。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> 总结 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[可持久化数据结构]]></title>
      <url>https://glenen.github.io/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>When you hear the word persistence in programming, most often, you think of an application saving its data to some type of storage, such as a database, so that the data can be retrieved later when the application is run again. There is, however, another meaning for the word persistence when it is used to describe data structures, particularly those used in functional programming languages. In that context, a persistent data structure is a data structure capable of preserving the current version of itself when modified. In essence, a persistent data structure is immutable.</p>
<p>当你在编程过程中听到持久化这个单词的时候，大多数情况下，你会认为是应用程序将其数据为存储为某种类型的文件中，例如数据库，以便于以后当应用程序再次运行时能够从介质中重新获取数据。然而这里的持久化讲的是另外一个意思，用其来描述一种数据结构，通常会用在一些函数式的编程语言中。从这个意义上来讲，一个具有持久化能力的数据结构在其被修改后可以保存当前的状态，从本质上来说，这样的数据结构是不可改变类型（immutable）。</p>
<a id="more"></a>
<p>An example of a class that uses this type of persistence in the .NET Framework is the string class. Once a string object is created, it cannot be changed. Any operation that appears to change a string generates a new string instead. Thus, each version of a string object can be preserved. An advantage for a persistent class like the string class is that it basically gives you undo functionality built-in. As newer versions of a persistent object are created, older versions can be pushed onto a stack and popped off when you want to undo an operation. Another advantage is that because persistent data structures cannot change state, they are easier to reason about and are thread safe.</p>
<p>.NET Framework中的String类正好是使用了持久化能力的一个例子。一旦创建了一个String类型实例，它便不能被改变了，对于欲改变其值的任何操作都将被产生一个新的String对象，通过这样，每一个版本的String实例都将被驻留下来。这样的具有持久化特点的类型像String类型都内置了撤销（Undo）功能，当该对象的新一个版本产生的时候，旧版本将被压入栈中，如果需要执行撤销动作的时候，只需将旧版本从堆栈中取出。另外一个优点是由于可持久化数据类型不能更改其内部状态，很容易得知它是线程安全的。</p>
<p>There is an overhead that comes with persistent data structures, however. Each operation that changes a persistent data structure creates a new version of that data structure. This can involve a good deal of copying to create the new version. This cost can be mitigated to a large degree by reusing as much of the internal structure of the old version in creating a new one. I will explore this idea in making two common data structures persistent: the singly linked list and the binary tree, and describe a third data structure that combines the two. I will also describe several classes I have created that are persistent versions of some of the classes in the System.Collections namespace.</p>
<p>然而持久化的数据结构会带来一些开销，任何改变持久化数据结构的操作都将创建一个新的版本，这可能会涉及到大量的拷贝操作，通常我们可以通过重用旧版本对象的内部数据结构来创建一个新的对象，这种办法可以极大地降低拷贝操作所带来的消耗。我将会通过两个常用的数据结构来阐述这个思想：单向列表以及二叉树，然后通过这两个数据结构来组合第三个数据结构。同时我也会讲述System.Collection命名空间下面的那些持久化的类型。</p>
<h4 id="Persistent-Singly-Linked-Lists"><a href="#Persistent-Singly-Linked-Lists" class="headerlink" title="Persistent Singly Linked Lists"></a>Persistent Singly Linked Lists</h4><h4 id="持久化的单向链表"><a href="#持久化的单向链表" class="headerlink" title="持久化的单向链表"></a>持久化的单向链表</h4><p>The singly linked list is one of the most widely used data structures in programming. It consists of a series of nodes linked together one right after the other. Each node has a reference to the node that comes after it, and the last node in the list terminates with a null reference. To traverse a singly linked list, you begin at the head of the list and move from one node to the next until you have reached the node you are looking for or have reached the last node:</p>
<p>单向链表是一个在编程中使用非常广泛的基础数据结构，它是由一系列相互链接的节点组成。每一个节点都拥有一个指向下一个节点的引用，链表中的最后一个节点将拥有一个空引用。如果你想遍历一个单向链表，可以从第一个节点开始，逐个向后移动，直到到达最后的节点。如下图所示：</p>
<p><img src="/可持久化数据结构/LinkedList-0.png" alt=""></p>
<p>Let’s insert a new item into the list. This list is not persistent, meaning that it can be changed in-place without generating a new version. After taking a look at the insertion operation on a non-persistent list, we’ll look at the same operation on a persistent list.</p>
<p>让我们插入一个新的节点到这个链表中去，并且该链表是非持久化的，也就是说这个链表可以被改变而无需产生一个新的版本。在查看了非持久化链表的插入操作之后，我们将会查看同样的操作在持久化链表中。</p>
<p>Inserting a new item into a singly linked list involves creating a new node:</p>
<p>插入一个新的节点到单向列表中会涉及到创建一个新的节点：</p>
<p><img src="/可持久化数据结构/LinkedList-1.png" alt=""></p>
<p>We will insert the new node at the fourth position in the list. First, we traverse the list until we’ve reached that position. Then the node that will precede the new node is unlinked from the next node…</p>
<p>我们将会在第四个位置插入新的节点，第一我们遍历链表到达指定位置，也就是插入节点前面的那个节点，将其与后面节点断开。</p>
<p><img src="/可持久化数据结构/LinkedList-2.png" alt=""></p>
<p>…and relinked to the new node. The new node is, in turn, linked to the remaining nodes in the list:</p>
<p>然后链接该节点与待插入节点，在下来，链接新的节点与上一步剩余的节点。</p>
<p><img src="/可持久化数据结构/LinkedList-3.png" alt=""></p>
<p>Inserting a new item into a persistent singly linked list will not alter the existing list but create a new version with the item inserted into it. Instead of copying the entire list and then inserting the item into the copy, a better strategy is to reuse as much of the old list as possible. Since the nodes themselves are persistent, we don’t have to worry about aliasing problems.</p>
<p>如果插入一个新的节点到持久化的单向链表中，我们不应该改变当前链表的状态，而需要创建一个新的链表而后插入指定节点。相对于拷贝当前链表，而后插入指定节点，一个更好的策略是尽可能的重用旧的链表。因为节点本身是可持久化的，所以我们不必担心对象混淆的问题。</p>
<p>To insert a new node at the fourth position, we traverse the list as before only copying each node along the way. Each copied node is linked to the next copied node:</p>
<p>为了插入新节点到第四个位置，我们遍历链表到指定位置，拷贝每个遍历节点，同时指定拷贝的节点指向其下一个节点的拷贝。</p>
<p><img src="/可持久化数据结构/LinkedList-4.png" alt=""></p>
<p>The last copied node is linked to the new node, and the new node is linked to the remaining nodes in the old list:</p>
<p>最后一个拷贝的节点指向新的插入节点，而后，新节点指向旧链表剩下的节点。</p>
<p><img src="/可持久化数据结构/LinkedList-5.png" alt=""></p>
<p>On an average, about N/2 nodes will be copied in the persistent version for insertions and deletions, where N equals the number of nodes in the list. This isn’t terribly efficient but does give us some savings. One persistent data structure where this approach to singly linked list buys us a lot is the stack. Imagine the above data structure with insertions and deletions restricted to the head of the list. In this case, N nodes can be reused for pushing items onto a stack and N - 1 nodes can be reused for popping a stack.</p>
<p>平均来看，对于插入和删除操作，大约有N/2的节点将被拷贝，而N等于链表长度。这并不是特别的高效，仅仅只是节省了一些空间。与通过这样的方式来构建单向链表一样的一个数据结构是堆栈，我们可以想象一下在链表起始位置的插入以及删除操作，在这个场景中，对于堆栈来讲，压栈操作时全部节点都可以被重用，而出栈操作也有N-1个节点被重用。 </p>
<h4 id="Persistent-Binary-Trees"><a href="#Persistent-Binary-Trees" class="headerlink" title="Persistent Binary Trees"></a>Persistent Binary Trees</h4><h4 id="持久化二叉树"><a href="#持久化二叉树" class="headerlink" title="持久化二叉树"></a>持久化二叉树</h4><p>A binary tree is a collection of nodes in which each node contains two links, one to its left child and another to its right child. Each child is itself a node, and either or both of the child nodes can be null, meaning that a node may have zero to two children. In the binary search tree version, each node usually stores a key/value pair. The tree is searched and ordered according to its keys. The key stored at a node is always greater than the keys stored in its left descendents and always less than the keys stored in its right descendents. This makes searching for any particular key very fast.</p>
<p>一个二叉树是一系列节点的集合，每一个节点都包含有两个子节点，一个称之为左节点，而另一个称之为右节点。而子节点也是这样一个节点，也有一个左节点和一个右节点，当然也可以没有子节点，也就是说一个节点可能有零个或者两个子节点。在二叉查找树中，每一个节点通常包含了一个键值对，树结构将会依照节点的键来进行查找和组织。节点的键会永远大于其左节点的键，永远小于其右节点的键，这将使得对于特定键的查找非常迅速。</p>
<p>Here is an example of a binary search tree. The keys are listed as numbers; the values have been omitted but are assumed to exist. Notice how each key as you descend to the left is less than the key of its predecessor, and vice versa as you descend to the right:</p>
<p>下图是一个二叉查找树的例子，节点的键作为数字被列出，而节点的值则被忽略尽管是始终存在的。注意到每一个左边节点的键值一定会小于它的父节点即前驱节点，而每一个右边节点的键值一定大于其父节点键值。 </p>
<p><img src="/可持久化数据结构/PersistentTree-0.png" alt=""></p>
<p>Changing the value of a particular node in a non-persistent tree involves starting at the root of the tree and searching for a particular key associated with that value, and then changing the value once the node has been found. Changing a persistent tree, on the other hand, generates a new version of the tree. We will use the same strategy in implementing a persistent binary tree as we did for the persistent singly linked list, which is to reuse as much of the data structure as possible when making a new version.</p>
<p>如果在一个非持久化的树中更改一个特定节点的值，我们会从根节点按照特定键值开始搜索，如果找到则直接更改该节点的值。但是如果是在一个持久化的树上的话，换句话说，我们需要创建一个新版本的树，同时还需要保持同实现一个持久化的二叉树或者单向链表一样的策略，即尽可能的重用当前的数据来创建一个新的版本。</p>
<p>Let’s change the value stored in the node with the key 7. As the search for the key leads us down the tree, we copy each node along the way. If we descend to the left, we point the previously copied node’s left child to the currently copied node. The previous node’s right child continues to point to nodes in the older version. If we descend to the right, we do just the opposite.</p>
<p>下面让我们来尝试改变键为7的节点的值，按照自顶向下查找该节点的路径，我们需要拷贝该路径上的每一个节点。如果转向左边，需要将上一个拷贝的节点指向当前拷贝节点，而前一个节点的右侧节点则继续指向原来旧版本的节点。如果转向右边，则采用相反的做法。</p>
<p>This illustrates the “spine” of the search down the tree. The red nodes are the only nodes that need to be copied in making a new version of the tree:</p>
<p>下图列出了在树上自顶向下搜索特定节点的路径，在构建新版本的树的时候仅仅需要拷贝那些红色的节点。</p>
<p><img src="/可持久化数据结构/PersistentTree-1.png" alt=""></p>
<p>You can see that the majority of the nodes do not need to be copied. Assuming the binary tree is balanced, the number of nodes that need to be copied any time a write operation is performed is at most O(Log N), where Log is base 2. This is much more efficient than the persistent singly linked list.</p>
<p>你能够发现大多数节点是不要拷贝的，假定二叉树是平衡的，在每一次节点值的写操作中需要拷贝的节点数目大约是O（LogN），对数的底为2。显然比起持久化的单向链表效率很高。</p>
<p>Insertions and deletions work the same way, only steps should be taken to keep the tree in balance, such as using an AVL tree. If a binary tree becomes degenerate, we run into the same efficiency problems as we did with the singly linked list.</p>
<p>插入以及删除操作将按照同样的方式进行，但是一些额外的保持树平衡的操作还是必须的，例如使用AVL树作为底层数据结构的时候。如果二叉树变得很不平衡，我们将会碰到同样的效率问题如同在持久化单向链表是一样。</p>
<h4 id="Random-Access-Lists"><a href="#Random-Access-Lists" class="headerlink" title="Random Access Lists"></a>Random Access Lists</h4><h4 id="随机存取链表"><a href="#随机存取链表" class="headerlink" title="随机存取链表"></a>随机存取链表</h4><p>An interesting persistent data structure that combines the singly linked list with the binary tree is Chris Okasaki’s random-access list. This data structure allows for random access of its items as well as adding and removing items from the beginning of the list. It is structured as a singly linked list of completely balanced binary trees. The advantage of this data structure is that it allows access, insertion, and removal of the head of the list in O(1) time as well as provides logarithmic performance in randomly accessing its items.</p>
<p>一个比较有意思的持久化数据结构是Chris Okasaki的随机存取列表，它结合了单向链表和二叉树的特点。这个数据结构除了允许用户随机操作其节点外，还支持在列表的起始位置添加和删除节点。它被组织成为一个使用二叉树来平衡的单向链表，其优点是当在其起始位置进行节点操作时，只需要O(1)的复杂度，而在随机操作节点的时候，也只有O(Log(N)).</p>
<p>Here is a random-access list with 13 items:</p>
<p>下面是一个具有13个子节点的随机存取列表： </p>
<p><img src="/可持久化数据结构/RandomAccessList-0.png" alt=""></p>
<p>When a node is added to the list, the first two root nodes (if they exist) are checked to see if they both have the same height. If so, the new node is made the parent of the first two nodes; the current head of the list is made the left child of the new node, and the second root node is made the right child. If the first two root nodes do not have the same height, the new node is simply placed at the beginning of the list and linked to the next tree in the list.</p>
<p>当添加一个节点到列表中的时候，前两个根节点会被查看它们的高度是否相同，如果是的话，那新的节点将是这两个节点的父节点，第一个节点将会作为插入节点的左子节点，而第二个节点会作为右节点。而如果这两个节点高度不同，新的节将会直接被放在节点的起始位置，然后链接到剩余节点。</p>
<p>To remove the head of the list, the root node at the beginning of the list is removed, with its left child becoming the new head and its right child becoming the root of the second tree in the list. The new head of the list is right linked with the next root node in the list:</p>
<p>如果要删除链表的头节点，也就是要删除链表的起始根节点，然后将其左侧子节点作为新的头节点，而右侧子节点则作为链表中第个树的根节点。新的头节点会指向链表中向右的第二个根节点。</p>
<p><img src="/可持久化数据结构/RandomAccessList-1.png" alt=""></p>
<p>Keep in mind that all operations that change a random-access list do not change the existing list but rather generate a new version representing the change. As much of the old list is reused in creating a new version.</p>
<p>记住所有改变随机存取列表的操作都不会改变现有列表，而是创建一个新的版本，并且在创建新版本的时候要尽可能充用现有列表。</p>
<h4 id="Immutable-Collections"><a href="#Immutable-Collections" class="headerlink" title="Immutable Collections"></a>Immutable Collections</h4><h4 id="不可改变集合类型"><a href="#不可改变集合类型" class="headerlink" title="不可改变集合类型"></a>不可改变集合类型</h4><p>Included with this article are a number of persistent collection classes I have created. These classes are in a namespace called ImmutableCollections. I have created persistent versions of some of the collection classes in the System.Collections namespace. I will describe each one and some of the challenges in making them persistent. There are several collection classes that are currently missing; I need to add a queue, for example. Hopefully, I will get to those in time. Also, even though I’ve taken steps to make these classes efficient, they cannot compete with the System.Collections classes in terms of speed, but they really aren’t meant to. They are meant to provide the advantages of immutability while providing reasonable performance.</p>
<p>在本文中我创建了许多持久化的集合类型，放在命名空间ImmutableCollections下。对于System.Collection命名空间下的一些集合类，我也创建了一个持久化的版本。我将会逐个讲述这些类型，阐述在持久化这些类时所遇到的问题及挑战。当然有一些遗漏的，例如Queue。希望有时间我能够将它们补上。尽管我已经采取了一些措施来提高性能，在存取速度上这些类还是不能与System.Collection命名空间的类相比较，但是这些类具有不可变类型的优点，而且具有合理的可以接收的性能。</p>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>This one was easy. Simply create a persistent singly linked list and limit insertions and deletions to the head of the list. Since this class is persistent, popping a stack returns a new version of the stack with the next item in the old stack as the new top. In the System.Collections.Stack version, popping the stack returns the top of the stack. The question for the persistent version was how to make the top of the stack available since it cannot be returned when the stack is popped. I chose to create a Top property that represents the top of the stack.</p>
<p>这个类是比较容易的，可以创建一个持久化的单向链表，然后限定只能在起始位置进行插入和删除操作。因为这个类是持久化的，出栈操作将会返回一个新版本的堆栈，这个堆栈以旧堆栈的第二个节点为头节点。在System.Collection命名空间下，出栈操作仅仅只是删除栈顶元素并返回。</p>
<h5 id="SortedList"><a href="#SortedList" class="headerlink" title="SortedList"></a>SortedList</h5><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>The SortedList uses AVL tree algorithms to keep the tree in balance. I found it useful to create an IAvlNode interface. Two classes implement this interface, the AvlNode class and the NullAvlNode class. The NullAvlNode class implements the null object design pattern. This simplified many of the algorithms.</p>
<p>有序列表使用了AVL树的算法来保持树节点的平衡，我创建了一个叫IAvlNode的接口，有两个类实现了这个接口，它们分别是AvlNode以及NullAvlNode类。NullAvlNode类利用了Null对象的设计模式，这将会简化一些算法。</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><p>This is the class that proved most challenging. Like the SortedList, it uses a persistent AVL tree as its data structure. However, unlike the SortedList, items are accessed by index (or by position) rather than by key. I have to admit that the algorithms for accessing and inserting items in a binary tree by index weren’t intuitive to me, so I turned to Knuth. Specifically, I used Algorithms B and C in section 6.2.3 in volume 3 of The Art of Computer Programming.</p>
<p>这个类的实现会遇到更多的挑战。与有序列表相同的是它也使用了持久化的AVL树来作为其底层的数据结构，不同的地方是是用户只能通过顺序索引来操作列表元素而不是字符串索引。不得不说的是我的本意并不是在一个二叉树上按照顺序索引来操纵和插入列表元素，所以我查看了Knuth的书籍，准确地来讲是使用了计算机编程的艺术第三卷6.2.3中的算法B和C。</p>
<p>I made an assumption about the ArrayList in order to improve performance. I assumed that the Add method is by far the most used method. However, adding items to the ArrayList one right after the other causes a lot of tree rotations to keep the tree in balance. To solve this, I created a template tree that is already completely balanced. Since this template tree is immutable, it can exist at the class level and be shared amongst all of the instances of the class.</p>
<p>为了提高动态数组的性能，我做了一个假设。假定Add方法是动态数组使用最多的方法，然而为了保持树的平衡，添加对象操作会引起多次的树旋转。为了解决这个问题，我创建了一个完全平衡的模板树，因为这个树是不可更改的，它可以在类的级别上存在，且能够被所有类的实例所共享。</p>
<p>When an instance of the ArrayList class is created, it takes a small subtree of the template tree. As items are added, the nodes in the template tree are replaced with new nodes. Since the tree is completely balanced, no rebalancing is necessary. If the subtree gets filled up, another subtree of equal height is taken from the template tree and joined to the existing tree. Insertions and deletions are handled normally with rebalancing performed if necessary. Again, the assumption is that adding items to the ArrayList occurs much more frequently than inserting or deleting items.</p>
<p>当一个动态数组的实例被创建的时候，它会抓住模板树的一个子树。当添加子节点的时候，模板树上的节点将会被新添的节点所替换，因为模板树本身就是平衡的，所以无需平衡树的操作。如果这个子树已经被填满，则会在模板树上抓取高度相同的另外一个子树，然后加入当前存在的树。当然插入和删除操作就需要进行平衡操作了。再一次强调的是我们的假设是添加节点的操作会远多于插入以及删除操作，才可以这样做。</p>
<h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>The Array class uses the random access list structure to provide a persistent array with logarithmic performance. Unlike a random access list, it has a fixed size.</p>
<p>数组类使用随机存取列表作为基础的数据结构，而随机存取列表在进行查找的时候只有Log（N）的复杂度，与随机存取列表不同的是，数据具有固定的长度。</p>
<h5 id="RandomAccessList"><a href="#RandomAccessList" class="headerlink" title="RandomAccessList"></a>RandomAccessList</h5><h5 id="随机存取列表"><a href="#随机存取列表" class="headerlink" title="随机存取列表"></a>随机存取列表</h5><p>This class does not have a parallel in the System.Collections namespace, but it was one of the first persistent classes I wrote, and I decided to include it here. It’s a straightforward implementation of Chris Okasaki’s random-access list described above. This data structure was designed to be used in functional languages where lists have three basic operations: Cons, Head, and Tail. Cons adds an item to the head of the list, Head is the first item in the list, and Tail represents all of the items in the list except for the Head.</p>
<p>这个类型在.NET类库的System.Collection命名空间下没有对应的实现类，但是它是我写的第一个持久化类，所以我决定在这里也介绍一下。在Chris Okasaki的文章中有一个简单易懂的实现，在一些函数式语言中会经常用到这个数据结构，通常它有三个基本操作：Cons，Head和Tail，Cons会添加一个新的对象到这个列表对象的开头，而Head将会返回列表的第一个对象，通过Tail会得到列表中除了第一个对象外的所有对象。</p>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>Persistent data structures help simplify programming by eliminating a whole class of bugs associated with side-effects and synchronization issues. They are not a cure-all but are a useful tool for helping a programmer deal with complexity. I have explored ways of making data structures persistent and have provided a small .NET library of persistent data structures. I hope you have enjoyed the article, and as always, I welcome feedback.</p>
<p>持久化数据结构会有助于简化编程，将一些线程同步的问题消除掉。它并不是解救一切的灵丹妙药，而是帮助程序员减低程序复杂度的一个工具。我已经阐述了如何构建持久化数据的多种方法，并且打包成一个小的.NET类库。我希望你能够从本文中受益，并且永远欢迎您的反馈信息。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4><p>本帖转载自：<a href="http://www.cnblogs.com/tedzhao/archive/2008/11/12/1332112.html" target="_blank" rel="external">http://www.cnblogs.com/tedzhao/archive/2008/11/12/1332112.html</a></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[HotSpot虚拟机对象]]></title>
      <url>https://glenen.github.io/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本博文所有内容均为本人阅读《深入理解java虚拟机：jvm高级特性与最佳实践》书时所记，所用图也是亲笔所画。转载请注明出处，仅供参考。</p>
<h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>此部分的主要内容是了解虚拟机中的数据以及它们是如何创建、如何布局、如何访问的。</p>
<h4 id="hotspot虚拟机对象"><a href="#hotspot虚拟机对象" class="headerlink" title="hotspot虚拟机对象"></a>hotspot虚拟机对象</h4><h5 id="对象的创建步骤"><a href="#对象的创建步骤" class="headerlink" title="对象的创建步骤"></a>对象的创建步骤</h5><p>虚拟机遇到一条new指令 -&gt; 检查这个指令的参数是否能在常量池中定位到一个类的符号引用 -&gt; 检查这个符号引用代表的类是否已被加载、解析和初始化过 -&gt; 检查都通过后，为新生对象分配内存 -&gt; 内存分配完成，将内存空间都初始化为零值，不包括对象头 ：该操作保证对象的字段在java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值 -&gt; 对对象进行必要设置，如对象是哪个类实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息 -&gt; 执行<init>方法将对象进行意愿初始化(字节码中是否跟随invokespecial指令决定)。</init></p>
<a id="more"></a>
<h5 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h5><p>1、指针碰撞：java堆中内存是绝对规整的，所有用过的内存都放一边，空闲的内存放一边，中间放着一个指针作为分界点的指示器；此时分配内存就仅仅把指针向空闲空间那边移动对象大小相等的距离。</p>
<p>2、空闲列表：java堆中内存并不规整，已用和空闲内存相互交错，此时虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配内存的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表记录。</p>
<h5 id="java堆是否规整"><a href="#java堆是否规整" class="headerlink" title="java堆是否规整"></a>java堆是否规整</h5><p>由所采用的垃圾收集器是否带有压缩整理功能决定，即与采用具体的垃圾回收算法有关系。使用Serial、ParNew等带Compact过程等收集器时，系统采用指针碰撞；使用CMS这种基于Mark-Sweep算法等收集器时，通常采用空闲列表。</p>
<h5 id="内存分配中的并发处理"><a href="#内存分配中的并发处理" class="headerlink" title="内存分配中的并发处理"></a>内存分配中的并发处理</h5><p>1、对分配内存空间的动作进行同步处理—采用CAS配上失败重试的方式保证更新操作的原子性。</p>
<p>2、内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机使用TLAB配置：-XX:+/-UseTLAB 参数设定。</p>
<h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>对象的内存布局：对象头Header、实例数据Instance Data、对齐填充Padding。 </p>
<p>对象头：包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志等，这部分数据等长度在32位和64位的虚拟机中分别为32bit和64bit，官方称“Mark Word”。对象需要存储的运行时数据其实超过Mark Word，考虑到空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，根据对象状态复用自己存储空间。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个类型指针来确定这个对象属于哪个类的实例，注意查找对象的元数据信息并不一定要经过对象本身。如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为从数组的元数据中无法确定数组的大小。</p>
<p>实例数据部分：是对象真正存储的有效信息，即在程序代码中所定义的各种类型的字段内容，包括继承而来和自身定义的。存储顺序受虚拟机分配策略参数和字段在java源码中定义的顺序影响，相同宽度的字段总是被分配到一起。父类中定义的变量会出现在子类之前，CompactFields参数值为true（默认true），则子类中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<p>对齐填充：并不是必然存在的，并无特别意义，仅起着占位符的作用。HotSpot VM对象的大小必须是8字节的整数倍，而对象头部分正好是1倍或者2倍8字节，所以当对象实例数据部分没有对齐时，就需要对齐填充来补充。</p>
<h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>java程序需要通过栈上的reference数据来操作堆上的具体对象。</p>
<p>句柄访问：java堆中划分出一块内存来作为句柄，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体信息。优势：reference中存储的是稳定的句柄地址，在对象移动（垃圾收集时对象移动是非常普遍的行为）时只会改变句柄中的实例数据指针。如下图所示：</p>
<p><img src="/HotSpot虚拟机对象/通过句柄访问对象.png" alt="通过句柄访问对象"></p>
<p>直接指针访问：java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的就是对象地址。优势：速度更快，节省了一次指针定位的时间开销，但reference存储的地址信息则会改变。HotSpot使用。如下图所示：</p>
<p><img src="/HotSpot虚拟机对象/通过直接指针访问对象.png" alt="通过直接指针访问对象"></p>
<h4 id="OOM异常"><a href="#OOM异常" class="headerlink" title="OOM异常"></a>OOM异常</h4><h5 id="java堆溢出"><a href="#java堆溢出" class="headerlink" title="java堆溢出"></a>java堆溢出</h5><p>解决手段是先通过映像分析工具对Dump出来的堆转储快照<br>进行分析，判断是内存泄漏还是内存溢出。如果内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，即可定位到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。如果内存溢出，应当检查虚拟机堆参数(-Xmx与-Xms)，与机器物理内存对比是否还可以调大，从代码检查是否存在生命周期是否过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h5 id="虚拟机栈溢出"><a href="#虚拟机栈溢出" class="headerlink" title="虚拟机栈溢出"></a>虚拟机栈溢出</h5><p>HotSpot栈容量只由-Xss参数设置(-Xoss设置本地方法栈，但由于不区分，所以实际无效)。开发多线程的应用时特别注意，出现StackOverFlowError异常时有错误堆栈可以阅读，找到问题相对容易，使用虚拟机默认参数，栈深度在大多数情况下达到1000—2000 完全没问题，正常方法调用包括递归该深度完全够用。</p>
<p>重点：如果建立多线程导致内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，只能通过减少最大堆和减少栈容量来换取更多的线程。</p>
<h5 id="方法区异常-包括常量池"><a href="#方法区异常-包括常量池" class="headerlink" title="方法区异常(包括常量池)"></a>方法区异常(包括常量池)</h5><p>String.intern()作用：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的string对象，否则将此String对象包含的字符串添加到常量池，并返回此String对象的引用。</p>
<h5 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h5><p>DirectMemory容量可通过-XX: MaxDirectMemorySize = 10M指定，不指定则默认与java堆最大值一样。直接内存溢出的明显特征，Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序又直接或者间接使用了NIO，则可考虑检查是否直接内存溢出。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[java运行时数据区域]]></title>
      <url>https://glenen.github.io/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本博文所有内容均为本人阅读《深入理解java虚拟机：jvm高级特性与最佳实践》书时所记，所用图也是亲笔所画。转载请注明出处，仅供参考。</p>
<p>本书作者前面用了很多篇幅描述java虚拟机及JDK的发展历史，此部分并没有做笔记，如需了解，请移步阅读原著即可。</p>
<h5 id="java优点"><a href="#java优点" class="headerlink" title="java优点"></a>java优点</h5><p>摆脱硬件平台束缚，一次编写到处运行；相对安全的内存管理与访问机制，避免内存泄漏与指针越界；热点代码检测和运行时编译及优化，java应用能随着运行时间的增加而获得更高的性能；拥有一套完善的API。</p>
<a id="more"></a>
<h5 id="java技术体系"><a href="#java技术体系" class="headerlink" title="java技术体系"></a>java技术体系</h5><p>java虚拟机：编译器与解释器。发展历史中出现过各种虚拟机。通用平台上运行的商用虚拟机：HotSpot ，JRockit ，J9。 特定硬件平台专用虚拟机：Azul VM  和  BEA Liquid VM。总结如下图所示：</p>
<p><img src="/java运行时数据区域/java技术体系.png" alt="java技术体系"></p>
<h5 id="java未来"><a href="#java未来" class="headerlink" title="java未来"></a>java未来</h5><p>模块化：解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。</p>
<p>混合语言编程：每种语言解决自己擅长的问题。</p>
<p>多核并行：多线程，充分利用CPU。进一步丰富语法及64位虚拟机</p>
<h4 id="java运行时数据区域"><a href="#java运行时数据区域" class="headerlink" title="java运行时数据区域"></a>java运行时数据区域</h4><p>java虚拟机在运行java程序时会把它所管理的内存划分为不同的数据区域，有的区域会随着虚拟机进程的启动而存在，有的则依赖于用户线程的启动和结束而创建和销毁。大体划分图如下：</p>
<p><img src="/java运行时数据区域/jvm运行时内存图.png" alt="jvm运行时内存图"></p>
<h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>线程私有的一块较小内存空间，可以看作是当前线程所执行字节码的行号指示器。虚拟机的模型概念里，字节码解释器工作时就是通过改变程序计数器的值来选取下一条需要执行的字节码指令。</p>
<p>为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器且互不影响独立存储。程序计数器是唯一一个在java虚拟机规范中没有规定任何OutOFMemoryError情况的区域，如果线程正在执行一个java方法，则其记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，则其值为空。</p>
<h5 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h5><p>线程私有，生命周期与线程相同，其描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址），其在帧中的内存空间大小在编译期已确定，运行期不会改变其大小。</p>
<p>StackOverFlowError：线程请求的栈深度大于虚拟机所允许的栈深度；OutOFMemoryError：虚拟机动态扩展时无法申请到足够的内存。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>与虚拟机栈发挥到作用非常相似，但其为虚拟机使用到的Native方法服务。甚至有的虚拟机（HotSpot）将它们合二为一，也会抛出StackOverFlowError 和 OutOFMemoryError异常。</p>
<h5 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h5><p>内存管理最大的一块，被所有线程共享，在虚拟机启动时创建。其唯一目的就是存放对象实例及数组。java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。如果在堆中没有内存来完成实例分配且无法再扩展时，抛出OutOFMemoryError异常。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>与java堆一样，各线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。此区域的内存回收目标主要是针对常量池的回收和对类型的卸载，内存回收难但却必要。当其无法满足内存分配需求时，抛出OutOFMemoryError异常。</p>
<h5 id="运行时常量区"><a href="#运行时常量区" class="headerlink" title="运行时常量区"></a>运行时常量区</h5><p>方法区的一部分，Class文件常量池用于存放编译期生成的各种字面量和符号引用。运行时常量池相对于Class文件常量池具有动态性，且每一部分的格式都没有严格规定。动态特性利用的比较多的是String  类的intern()方法。常量池无法再申请到内存时抛出OutOFMemoryError异常。</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>不属于虚拟机运行时数据区的一部分，也并非虚拟机规范中定义的内存区域。但该部分内存被频繁使用，且也可能导致OutOFMemoryError异常。NIO(New Input/output)类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，该种方式在一些场景中显著提高性能，因为避免了在java堆和Native堆中来回复制数据。</p>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> JVM原理 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树遍历—借助栈]]></title>
      <url>https://glenen.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94%E5%80%9F%E5%8A%A9%E6%A0%88/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>写在最前：本博文所设计内容均为本人亲自所著，为工作闲暇之余及大学时代所积累，涉及思路不会描述太仔细，仅供参考。</p>
<p>二叉树的遍历种类可谓多：深度优先遍历DFS——借助栈，打破砂锅问到底，控制好节点的访问权即可。广度优先遍历BFS——借助队列，浅尝则止。层序遍历——借助队列，父节点出队之时即它孩子入队之日。</p>
<p>今天所记录的是二叉树的先、中、后序遍历，遍历的方法也是很多：递归、借助栈、递归加迭代、Morris遍历(最佳方式，后续会补上博文)。前三种方式中，时间复杂度均为O(n)，空间复杂度O(logn)。递归方式也最简单，本质是借助函数栈。在此研究的是借助栈实现三种遍历，不难但却给我们传递了一种借助数据结构解决问题的思想，还是非常值得体会的。</p>
<a id="more"></a>
<h5 id="一棵二叉树图："><a href="#一棵二叉树图：" class="headerlink" title="一棵二叉树图："></a>一棵二叉树图：</h5><p><img src="/二叉树遍历——借助栈/二叉树.png" alt="二叉树"></p>
<h5 id="java定义二叉树数据结构："><a href="#java定义二叉树数据结构：" class="headerlink" title="java定义二叉树数据结构："></a>java定义二叉树数据结构：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 定义二叉树</div><div class="line"> */</div><div class="line">@Data</div><div class="line">private class Node &#123;</div><div class="line">    /**</div><div class="line">     * 节点值</div><div class="line">     */</div><div class="line">    private int dataValue;</div><div class="line">    /**</div><div class="line">     * 左孩子节点</div><div class="line">     */</div><div class="line">    private Node left;</div><div class="line">    /**</div><div class="line">     * 右孩子节点</div><div class="line">     */</div><div class="line">    private Node right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：因为本人IDE测试都写在一个类中，所有采用了内部类定义结构。</p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>头节点 —&gt; 左孩子节点 —&gt; 右孩子节点。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>头节点最先压入栈 —&gt; 弹出并打印其节点值 —&gt; 顺序检查其右、左孩子节点是否为null —&gt; 不为null的入栈 —&gt; 继续第二步骤及其后续 —&gt; 栈为空后退出循环。</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 二叉树先序遍历：借助栈</div><div class="line"> *</div><div class="line"> * @param head 头节点</div><div class="line"> */</div><div class="line">public static void preTraversal(Node head) &#123;</div><div class="line">    <span class="keyword">if</span> (head == null) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.print(<span class="string">"preTraversal:"</span>);</div><div class="line">        Stack&lt;Node&gt; temp = new Stack&lt;&gt;();</div><div class="line">        // 头节点压入栈</div><div class="line">        temp.push(head);</div><div class="line">        <span class="keyword">while</span> (!temp.isEmpty()) &#123;</div><div class="line">            head = temp.pop();</div><div class="line">            System.out.print(head.dataValue + <span class="string">" "</span>);</div><div class="line">            // 右孩子先入栈</div><div class="line">            <span class="keyword">if</span> (head.right != null) &#123;</div><div class="line">                temp.push(head.right);</div><div class="line">            &#125;</div><div class="line">            // 左孩子后入栈</div><div class="line">            <span class="keyword">if</span> (head.left != null) &#123;</div><div class="line">                temp.push(head.left);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>左孩子节点 —&gt; 头节点 —&gt; 右孩子节点。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>头节点压入栈 —&gt; 递归将其左孩子及左孩子一条斜线上的节点压入栈：左孩子及左孩子的左孩子… —&gt; 最左的左孩子为null时：弹出栈顶节点 —&gt; 打印其节点值，并把它右孩子节点入栈 —&gt; 继续第二步骤及后续 —&gt; 栈为空时退出循环。</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 二叉树中序遍历：借助栈</div><div class="line"> *</div><div class="line"> * @param head 头节点</div><div class="line"> */</div><div class="line">public static void midTraversal(Node head) &#123;</div><div class="line">    <span class="keyword">if</span> (head == null) &#123;</div><div class="line">        <span class="built_in">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.print(<span class="string">"midTraversal:"</span>);</div><div class="line">        Stack&lt;Node&gt; temp = new Stack&lt;&gt;();</div><div class="line">        temp.push(head);</div><div class="line">        <span class="keyword">while</span> (!temp.isEmpty() || head != null) &#123;</div><div class="line">            // 连续把二叉树最左一条斜线上的节点压入栈</div><div class="line">            <span class="keyword">if</span> (head.left != null) &#123;</div><div class="line">                temp.push(head.left);</div><div class="line">                head = head.left;</div><div class="line">            // 弹出栈顶节点，让其右孩子继续上述过程</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                head = temp.pop();</div><div class="line">                System.out.print(head.dataValue + <span class="string">" "</span>);</div><div class="line">                head = head.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>左孩子节点 —&gt; 右孩子节点 —&gt; 头节点。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>此处借助两个栈实现，也更好理解，当然也可以借助一个栈结构实现。<br>头节点入栈1 —&gt; 栈1弹出节点并压入栈2 —&gt;  顺序检测弹出节点的左、右孩子是否为null —&gt; 不为null则顺序压入栈1 —&gt; 继续步骤2及其后续 —&gt; 栈1为空则退出循环 —&gt; 此时栈2中的节点顺序已是后序遍历顺序，循环弹出打印其节点即可。</p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code class="bash">/**
 * 二叉树后序遍历：借助栈
 *
 * @param head 头节点
 */
public static void behTraversal(Node head) {
    <span class="keyword">if</span> (head == null) {
        <span class="built_in">return</span>;
    } <span class="keyword">else</span> {
        // 借助两个栈来完成
        Stack&lt;Node&gt; temp1 = new Stack&lt;&gt;();
        Stack&lt;Node&gt; temp2 = new Stack&lt;&gt;();
        System.out.print(<span class="string">"behTraversal:"</span>);
        temp1.push(head);
        <span class="keyword">while</span> (!temp1.isEmpty()) {
            head = temp1.pop();
            temp2.push(head);
            // 入栈顺序很重要
            <span class="keyword">if</span> (head.left != null) {
                temp1.push(head.left);
            }
            <span class="keyword">if</span> (head.right != null) {
                temp1.push(head.right);
            }
        }
        // temp2栈中的顺序已是后序
        <span class="keyword">while</span> (!temp2.isEmpty()) {
            System.out.print(temp2.pop() + <span class="string">" "</span>);
        }
    }
    System.out.println();
}
</code></pre>
<h4 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h4>]]></content>
      
        <categories>
            
            <category> 二叉树 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[韶华倾付]]></title>
      <url>https://glenen.github.io/%E9%9F%B6%E5%8D%8E%E5%80%BE%E4%BB%98/</url>
      <content type="html"><![CDATA[<p>情感此物很奇怪，总是会在生活里，慢慢忘记了回忆。</p>
<p>开始忘记，有那么一张脸，他最初走进我的世界，是以怎样的表情。<br>也许是在一个阳光明媚的午后。<br>也许是在一个风景秀丽的公园。<br>也许是在一座人声鼎沸的都市。<br>也许，你就这样带着来自幸福的期许。<br>如此翩翩舞动而来。</p>
<p><img src="/韶华倾付/timg-0.png" alt=""></p>
<a id="more"></a>
<p>爱的你，如今在一座据说很恐怖的城市独自工作和生活。<br>为了梦想，或者说为了生存，你留在了那里。<br>那座城市，也许只是你的一个想象。<br>它出现于一夜之间，像海市蜃楼一样虚幻而美丽。<br>你走得越近，就越看不清它。<br>你凝视着它，为它哭，为它笑。<br>久而久之，你终于发现，原来它只是你的一个影子。<br>偶有微光，照亮你前行的方向。</p>
<p><img src="/韶华倾付/timg-1.png" alt=""></p>
<p>自从你工作之后，诸多不易，诸多辛劳，即便不说，其实我也大略的知道。<br>然而，你给了我一个承诺，我就哪里都不会去，只是站在这里等着你。<br>恩爱两不疑，如此坚定和执着。</p>
<p>牵挂的人，未来已经在前方等着你。<br>请勇敢的去拥抱它。<br>别念过去，别畏将来。<br>我会是你最温暖的港湾。</p>
<p><img src="/韶华倾付/timg-2.png" alt=""></p>
<p>爱情许是最美好的感觉。<br>时光不会伤害它。<br>而它之于你我，不是肌肤之亲，也不是一蔬一饭。<br>它是一种不死的欲望，是平凡生活中的英雄梦想。<br>所以放心的去拼搏吧，站在你身后的，是永恒不变的我，和我的心。</p>
]]></content>
      
        <categories>
            
            <category> 心灵情感 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
